//! Types for the `EC2` service.

/// The [`AWS::EC2::CapacityReservation`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html) resource type.
#[derive(Debug, Default)]
pub struct CapacityReservation {
    properties: CapacityReservationProperties
}

/// Properties for the `CapacityReservation` resource.
#[derive(Debug, Default)]
pub struct CapacityReservationProperties {
    /// Property [`AvailabilityZone`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-availabilityzone).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub availability_zone: ::Value<String>,
    /// Property [`EbsOptimized`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-ebsoptimized).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub ebs_optimized: Option<::Value<bool>>,
    /// Property [`EndDate`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-enddate).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub end_date: Option<::Value<String>>,
    /// Property [`EndDateType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-enddatetype).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub end_date_type: Option<::Value<String>>,
    /// Property [`EphemeralStorage`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-ephemeralstorage).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub ephemeral_storage: Option<::Value<bool>>,
    /// Property [`InstanceCount`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-instancecount).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub instance_count: ::Value<u32>,
    /// Property [`InstanceMatchCriteria`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-instancematchcriteria).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub instance_match_criteria: Option<::Value<String>>,
    /// Property [`InstancePlatform`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-instanceplatform).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub instance_platform: ::Value<String>,
    /// Property [`InstanceType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-instancetype).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub instance_type: ::Value<String>,
    /// Property [`OutPostArn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-outpostarn).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub out_post_arn: Option<::Value<String>>,
    /// Property [`PlacementGroupArn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-placementgrouparn).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub placement_group_arn: Option<::Value<String>>,
    /// Property [`TagSpecifications`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-tagspecifications).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub tag_specifications: Option<::ValueList<self::capacity_reservation::TagSpecification>>,
    /// Property [`Tenancy`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-tenancy).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub tenancy: Option<::Value<String>>,
}

impl ::serde::Serialize for CapacityReservationProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "AvailabilityZone", &self.availability_zone)?;
        if let Some(ref ebs_optimized) = self.ebs_optimized {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "EbsOptimized", ebs_optimized)?;
        }
        if let Some(ref end_date) = self.end_date {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "EndDate", end_date)?;
        }
        if let Some(ref end_date_type) = self.end_date_type {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "EndDateType", end_date_type)?;
        }
        if let Some(ref ephemeral_storage) = self.ephemeral_storage {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "EphemeralStorage", ephemeral_storage)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstanceCount", &self.instance_count)?;
        if let Some(ref instance_match_criteria) = self.instance_match_criteria {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstanceMatchCriteria", instance_match_criteria)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstancePlatform", &self.instance_platform)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstanceType", &self.instance_type)?;
        if let Some(ref out_post_arn) = self.out_post_arn {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "OutPostArn", out_post_arn)?;
        }
        if let Some(ref placement_group_arn) = self.placement_group_arn {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "PlacementGroupArn", placement_group_arn)?;
        }
        if let Some(ref tag_specifications) = self.tag_specifications {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "TagSpecifications", tag_specifications)?;
        }
        if let Some(ref tenancy) = self.tenancy {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tenancy", tenancy)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for CapacityReservationProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<CapacityReservationProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = CapacityReservationProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type CapacityReservationProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut availability_zone: Option<::Value<String>> = None;
                let mut ebs_optimized: Option<::Value<bool>> = None;
                let mut end_date: Option<::Value<String>> = None;
                let mut end_date_type: Option<::Value<String>> = None;
                let mut ephemeral_storage: Option<::Value<bool>> = None;
                let mut instance_count: Option<::Value<u32>> = None;
                let mut instance_match_criteria: Option<::Value<String>> = None;
                let mut instance_platform: Option<::Value<String>> = None;
                let mut instance_type: Option<::Value<String>> = None;
                let mut out_post_arn: Option<::Value<String>> = None;
                let mut placement_group_arn: Option<::Value<String>> = None;
                let mut tag_specifications: Option<::ValueList<self::capacity_reservation::TagSpecification>> = None;
                let mut tenancy: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "AvailabilityZone" => {
                            availability_zone = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "EbsOptimized" => {
                            ebs_optimized = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "EndDate" => {
                            end_date = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "EndDateType" => {
                            end_date_type = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "EphemeralStorage" => {
                            ephemeral_storage = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "InstanceCount" => {
                            instance_count = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "InstanceMatchCriteria" => {
                            instance_match_criteria = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "InstancePlatform" => {
                            instance_platform = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "InstanceType" => {
                            instance_type = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "OutPostArn" => {
                            out_post_arn = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "PlacementGroupArn" => {
                            placement_group_arn = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TagSpecifications" => {
                            tag_specifications = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tenancy" => {
                            tenancy = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(CapacityReservationProperties {
                    availability_zone: availability_zone.ok_or(::serde::de::Error::missing_field("AvailabilityZone"))?,
                    ebs_optimized: ebs_optimized,
                    end_date: end_date,
                    end_date_type: end_date_type,
                    ephemeral_storage: ephemeral_storage,
                    instance_count: instance_count.ok_or(::serde::de::Error::missing_field("InstanceCount"))?,
                    instance_match_criteria: instance_match_criteria,
                    instance_platform: instance_platform.ok_or(::serde::de::Error::missing_field("InstancePlatform"))?,
                    instance_type: instance_type.ok_or(::serde::de::Error::missing_field("InstanceType"))?,
                    out_post_arn: out_post_arn,
                    placement_group_arn: placement_group_arn,
                    tag_specifications: tag_specifications,
                    tenancy: tenancy,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for CapacityReservation {
    type Properties = CapacityReservationProperties;
    const TYPE: &'static str = "AWS::EC2::CapacityReservation";
    fn properties(&self) -> &CapacityReservationProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut CapacityReservationProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for CapacityReservation {}

impl From<CapacityReservationProperties> for CapacityReservation {
    fn from(properties: CapacityReservationProperties) -> CapacityReservation {
        CapacityReservation { properties }
    }
}

/// The [`AWS::EC2::CapacityReservationFleet`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html) resource type.
#[derive(Debug, Default)]
pub struct CapacityReservationFleet {
    properties: CapacityReservationFleetProperties
}

/// Properties for the `CapacityReservationFleet` resource.
#[derive(Debug, Default)]
pub struct CapacityReservationFleetProperties {
    /// Property [`AllocationStrategy`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-allocationstrategy).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub allocation_strategy: Option<::Value<String>>,
    /// Property [`EndDate`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-enddate).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub end_date: Option<::Value<String>>,
    /// Property [`InstanceMatchCriteria`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-instancematchcriteria).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub instance_match_criteria: Option<::Value<String>>,
    /// Property [`InstanceTypeSpecifications`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-instancetypespecifications).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub instance_type_specifications: Option<::ValueList<self::capacity_reservation_fleet::InstanceTypeSpecification>>,
    /// Property [`NoRemoveEndDate`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-noremoveenddate).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub no_remove_end_date: Option<::Value<bool>>,
    /// Property [`RemoveEndDate`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-removeenddate).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub remove_end_date: Option<::Value<bool>>,
    /// Property [`TagSpecifications`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-tagspecifications).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub tag_specifications: Option<::ValueList<self::capacity_reservation_fleet::TagSpecification>>,
    /// Property [`Tenancy`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-tenancy).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub tenancy: Option<::Value<String>>,
    /// Property [`TotalTargetCapacity`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-totaltargetcapacity).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub total_target_capacity: Option<::Value<u32>>,
}

impl ::serde::Serialize for CapacityReservationFleetProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref allocation_strategy) = self.allocation_strategy {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "AllocationStrategy", allocation_strategy)?;
        }
        if let Some(ref end_date) = self.end_date {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "EndDate", end_date)?;
        }
        if let Some(ref instance_match_criteria) = self.instance_match_criteria {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstanceMatchCriteria", instance_match_criteria)?;
        }
        if let Some(ref instance_type_specifications) = self.instance_type_specifications {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstanceTypeSpecifications", instance_type_specifications)?;
        }
        if let Some(ref no_remove_end_date) = self.no_remove_end_date {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "NoRemoveEndDate", no_remove_end_date)?;
        }
        if let Some(ref remove_end_date) = self.remove_end_date {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "RemoveEndDate", remove_end_date)?;
        }
        if let Some(ref tag_specifications) = self.tag_specifications {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "TagSpecifications", tag_specifications)?;
        }
        if let Some(ref tenancy) = self.tenancy {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tenancy", tenancy)?;
        }
        if let Some(ref total_target_capacity) = self.total_target_capacity {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "TotalTargetCapacity", total_target_capacity)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for CapacityReservationFleetProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<CapacityReservationFleetProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = CapacityReservationFleetProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type CapacityReservationFleetProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut allocation_strategy: Option<::Value<String>> = None;
                let mut end_date: Option<::Value<String>> = None;
                let mut instance_match_criteria: Option<::Value<String>> = None;
                let mut instance_type_specifications: Option<::ValueList<self::capacity_reservation_fleet::InstanceTypeSpecification>> = None;
                let mut no_remove_end_date: Option<::Value<bool>> = None;
                let mut remove_end_date: Option<::Value<bool>> = None;
                let mut tag_specifications: Option<::ValueList<self::capacity_reservation_fleet::TagSpecification>> = None;
                let mut tenancy: Option<::Value<String>> = None;
                let mut total_target_capacity: Option<::Value<u32>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "AllocationStrategy" => {
                            allocation_strategy = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "EndDate" => {
                            end_date = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "InstanceMatchCriteria" => {
                            instance_match_criteria = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "InstanceTypeSpecifications" => {
                            instance_type_specifications = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "NoRemoveEndDate" => {
                            no_remove_end_date = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "RemoveEndDate" => {
                            remove_end_date = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TagSpecifications" => {
                            tag_specifications = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tenancy" => {
                            tenancy = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TotalTargetCapacity" => {
                            total_target_capacity = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(CapacityReservationFleetProperties {
                    allocation_strategy: allocation_strategy,
                    end_date: end_date,
                    instance_match_criteria: instance_match_criteria,
                    instance_type_specifications: instance_type_specifications,
                    no_remove_end_date: no_remove_end_date,
                    remove_end_date: remove_end_date,
                    tag_specifications: tag_specifications,
                    tenancy: tenancy,
                    total_target_capacity: total_target_capacity,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for CapacityReservationFleet {
    type Properties = CapacityReservationFleetProperties;
    const TYPE: &'static str = "AWS::EC2::CapacityReservationFleet";
    fn properties(&self) -> &CapacityReservationFleetProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut CapacityReservationFleetProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for CapacityReservationFleet {}

impl From<CapacityReservationFleetProperties> for CapacityReservationFleet {
    fn from(properties: CapacityReservationFleetProperties) -> CapacityReservationFleet {
        CapacityReservationFleet { properties }
    }
}

/// The [`AWS::EC2::CarrierGateway`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-carriergateway.html) resource type.
#[derive(Debug, Default)]
pub struct CarrierGateway {
    properties: CarrierGatewayProperties
}

/// Properties for the `CarrierGateway` resource.
#[derive(Debug, Default)]
pub struct CarrierGatewayProperties {
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-carriergateway.html#cfn-ec2-carriergateway-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
    /// Property [`VpcId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-carriergateway.html#cfn-ec2-carriergateway-vpcid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub vpc_id: ::Value<String>,
}

impl ::serde::Serialize for CarrierGatewayProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "VpcId", &self.vpc_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for CarrierGatewayProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<CarrierGatewayProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = CarrierGatewayProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type CarrierGatewayProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut tags: Option<::ValueList<::Tag>> = None;
                let mut vpc_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "VpcId" => {
                            vpc_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(CarrierGatewayProperties {
                    tags: tags,
                    vpc_id: vpc_id.ok_or(::serde::de::Error::missing_field("VpcId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for CarrierGateway {
    type Properties = CarrierGatewayProperties;
    const TYPE: &'static str = "AWS::EC2::CarrierGateway";
    fn properties(&self) -> &CarrierGatewayProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut CarrierGatewayProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for CarrierGateway {}

impl From<CarrierGatewayProperties> for CarrierGateway {
    fn from(properties: CarrierGatewayProperties) -> CarrierGateway {
        CarrierGateway { properties }
    }
}

/// The [`AWS::EC2::ClientVpnAuthorizationRule`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html) resource type.
#[derive(Debug, Default)]
pub struct ClientVpnAuthorizationRule {
    properties: ClientVpnAuthorizationRuleProperties
}

/// Properties for the `ClientVpnAuthorizationRule` resource.
#[derive(Debug, Default)]
pub struct ClientVpnAuthorizationRuleProperties {
    /// Property [`AccessGroupId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-accessgroupid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub access_group_id: Option<::Value<String>>,
    /// Property [`AuthorizeAllGroups`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-authorizeallgroups).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub authorize_all_groups: Option<::Value<bool>>,
    /// Property [`ClientVpnEndpointId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-clientvpnendpointid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub client_vpn_endpoint_id: ::Value<String>,
    /// Property [`Description`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-description).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub description: Option<::Value<String>>,
    /// Property [`TargetNetworkCidr`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-targetnetworkcidr).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub target_network_cidr: ::Value<String>,
}

impl ::serde::Serialize for ClientVpnAuthorizationRuleProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref access_group_id) = self.access_group_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "AccessGroupId", access_group_id)?;
        }
        if let Some(ref authorize_all_groups) = self.authorize_all_groups {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "AuthorizeAllGroups", authorize_all_groups)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "ClientVpnEndpointId", &self.client_vpn_endpoint_id)?;
        if let Some(ref description) = self.description {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Description", description)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "TargetNetworkCidr", &self.target_network_cidr)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for ClientVpnAuthorizationRuleProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<ClientVpnAuthorizationRuleProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = ClientVpnAuthorizationRuleProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type ClientVpnAuthorizationRuleProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut access_group_id: Option<::Value<String>> = None;
                let mut authorize_all_groups: Option<::Value<bool>> = None;
                let mut client_vpn_endpoint_id: Option<::Value<String>> = None;
                let mut description: Option<::Value<String>> = None;
                let mut target_network_cidr: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "AccessGroupId" => {
                            access_group_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "AuthorizeAllGroups" => {
                            authorize_all_groups = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "ClientVpnEndpointId" => {
                            client_vpn_endpoint_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Description" => {
                            description = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TargetNetworkCidr" => {
                            target_network_cidr = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(ClientVpnAuthorizationRuleProperties {
                    access_group_id: access_group_id,
                    authorize_all_groups: authorize_all_groups,
                    client_vpn_endpoint_id: client_vpn_endpoint_id.ok_or(::serde::de::Error::missing_field("ClientVpnEndpointId"))?,
                    description: description,
                    target_network_cidr: target_network_cidr.ok_or(::serde::de::Error::missing_field("TargetNetworkCidr"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for ClientVpnAuthorizationRule {
    type Properties = ClientVpnAuthorizationRuleProperties;
    const TYPE: &'static str = "AWS::EC2::ClientVpnAuthorizationRule";
    fn properties(&self) -> &ClientVpnAuthorizationRuleProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut ClientVpnAuthorizationRuleProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for ClientVpnAuthorizationRule {}

impl From<ClientVpnAuthorizationRuleProperties> for ClientVpnAuthorizationRule {
    fn from(properties: ClientVpnAuthorizationRuleProperties) -> ClientVpnAuthorizationRule {
        ClientVpnAuthorizationRule { properties }
    }
}

/// The [`AWS::EC2::ClientVpnEndpoint`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html) resource type.
#[derive(Debug, Default)]
pub struct ClientVpnEndpoint {
    properties: ClientVpnEndpointProperties
}

/// Properties for the `ClientVpnEndpoint` resource.
#[derive(Debug, Default)]
pub struct ClientVpnEndpointProperties {
    /// Property [`AuthenticationOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-authenticationoptions).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub authentication_options: ::ValueList<self::client_vpn_endpoint::ClientAuthenticationRequest>,
    /// Property [`ClientCidrBlock`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-clientcidrblock).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub client_cidr_block: ::Value<String>,
    /// Property [`ClientConnectOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-clientconnectoptions).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub client_connect_options: Option<::Value<self::client_vpn_endpoint::ClientConnectOptions>>,
    /// Property [`ClientLoginBannerOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-clientloginbanneroptions).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub client_login_banner_options: Option<::Value<self::client_vpn_endpoint::ClientLoginBannerOptions>>,
    /// Property [`ConnectionLogOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-connectionlogoptions).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub connection_log_options: ::Value<self::client_vpn_endpoint::ConnectionLogOptions>,
    /// Property [`Description`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-description).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub description: Option<::Value<String>>,
    /// Property [`DnsServers`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-dnsservers).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub dns_servers: Option<::ValueList<String>>,
    /// Property [`SecurityGroupIds`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-securitygroupids).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub security_group_ids: Option<::ValueList<String>>,
    /// Property [`SelfServicePortal`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-selfserviceportal).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub self_service_portal: Option<::Value<String>>,
    /// Property [`ServerCertificateArn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-servercertificatearn).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub server_certificate_arn: ::Value<String>,
    /// Property [`SessionTimeoutHours`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-sessiontimeouthours).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub session_timeout_hours: Option<::Value<u32>>,
    /// Property [`SplitTunnel`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-splittunnel).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub split_tunnel: Option<::Value<bool>>,
    /// Property [`TagSpecifications`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-tagspecifications).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub tag_specifications: Option<::ValueList<self::client_vpn_endpoint::TagSpecification>>,
    /// Property [`TransportProtocol`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-transportprotocol).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub transport_protocol: Option<::Value<String>>,
    /// Property [`VpcId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-vpcid).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub vpc_id: Option<::Value<String>>,
    /// Property [`VpnPort`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-vpnport).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub vpn_port: Option<::Value<u32>>,
}

impl ::serde::Serialize for ClientVpnEndpointProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "AuthenticationOptions", &self.authentication_options)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "ClientCidrBlock", &self.client_cidr_block)?;
        if let Some(ref client_connect_options) = self.client_connect_options {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "ClientConnectOptions", client_connect_options)?;
        }
        if let Some(ref client_login_banner_options) = self.client_login_banner_options {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "ClientLoginBannerOptions", client_login_banner_options)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "ConnectionLogOptions", &self.connection_log_options)?;
        if let Some(ref description) = self.description {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Description", description)?;
        }
        if let Some(ref dns_servers) = self.dns_servers {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "DnsServers", dns_servers)?;
        }
        if let Some(ref security_group_ids) = self.security_group_ids {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SecurityGroupIds", security_group_ids)?;
        }
        if let Some(ref self_service_portal) = self.self_service_portal {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SelfServicePortal", self_service_portal)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "ServerCertificateArn", &self.server_certificate_arn)?;
        if let Some(ref session_timeout_hours) = self.session_timeout_hours {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SessionTimeoutHours", session_timeout_hours)?;
        }
        if let Some(ref split_tunnel) = self.split_tunnel {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SplitTunnel", split_tunnel)?;
        }
        if let Some(ref tag_specifications) = self.tag_specifications {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "TagSpecifications", tag_specifications)?;
        }
        if let Some(ref transport_protocol) = self.transport_protocol {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "TransportProtocol", transport_protocol)?;
        }
        if let Some(ref vpc_id) = self.vpc_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "VpcId", vpc_id)?;
        }
        if let Some(ref vpn_port) = self.vpn_port {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "VpnPort", vpn_port)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for ClientVpnEndpointProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<ClientVpnEndpointProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = ClientVpnEndpointProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type ClientVpnEndpointProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut authentication_options: Option<::ValueList<self::client_vpn_endpoint::ClientAuthenticationRequest>> = None;
                let mut client_cidr_block: Option<::Value<String>> = None;
                let mut client_connect_options: Option<::Value<self::client_vpn_endpoint::ClientConnectOptions>> = None;
                let mut client_login_banner_options: Option<::Value<self::client_vpn_endpoint::ClientLoginBannerOptions>> = None;
                let mut connection_log_options: Option<::Value<self::client_vpn_endpoint::ConnectionLogOptions>> = None;
                let mut description: Option<::Value<String>> = None;
                let mut dns_servers: Option<::ValueList<String>> = None;
                let mut security_group_ids: Option<::ValueList<String>> = None;
                let mut self_service_portal: Option<::Value<String>> = None;
                let mut server_certificate_arn: Option<::Value<String>> = None;
                let mut session_timeout_hours: Option<::Value<u32>> = None;
                let mut split_tunnel: Option<::Value<bool>> = None;
                let mut tag_specifications: Option<::ValueList<self::client_vpn_endpoint::TagSpecification>> = None;
                let mut transport_protocol: Option<::Value<String>> = None;
                let mut vpc_id: Option<::Value<String>> = None;
                let mut vpn_port: Option<::Value<u32>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "AuthenticationOptions" => {
                            authentication_options = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "ClientCidrBlock" => {
                            client_cidr_block = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "ClientConnectOptions" => {
                            client_connect_options = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "ClientLoginBannerOptions" => {
                            client_login_banner_options = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "ConnectionLogOptions" => {
                            connection_log_options = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Description" => {
                            description = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "DnsServers" => {
                            dns_servers = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SecurityGroupIds" => {
                            security_group_ids = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SelfServicePortal" => {
                            self_service_portal = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "ServerCertificateArn" => {
                            server_certificate_arn = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SessionTimeoutHours" => {
                            session_timeout_hours = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SplitTunnel" => {
                            split_tunnel = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TagSpecifications" => {
                            tag_specifications = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TransportProtocol" => {
                            transport_protocol = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "VpcId" => {
                            vpc_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "VpnPort" => {
                            vpn_port = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(ClientVpnEndpointProperties {
                    authentication_options: authentication_options.ok_or(::serde::de::Error::missing_field("AuthenticationOptions"))?,
                    client_cidr_block: client_cidr_block.ok_or(::serde::de::Error::missing_field("ClientCidrBlock"))?,
                    client_connect_options: client_connect_options,
                    client_login_banner_options: client_login_banner_options,
                    connection_log_options: connection_log_options.ok_or(::serde::de::Error::missing_field("ConnectionLogOptions"))?,
                    description: description,
                    dns_servers: dns_servers,
                    security_group_ids: security_group_ids,
                    self_service_portal: self_service_portal,
                    server_certificate_arn: server_certificate_arn.ok_or(::serde::de::Error::missing_field("ServerCertificateArn"))?,
                    session_timeout_hours: session_timeout_hours,
                    split_tunnel: split_tunnel,
                    tag_specifications: tag_specifications,
                    transport_protocol: transport_protocol,
                    vpc_id: vpc_id,
                    vpn_port: vpn_port,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for ClientVpnEndpoint {
    type Properties = ClientVpnEndpointProperties;
    const TYPE: &'static str = "AWS::EC2::ClientVpnEndpoint";
    fn properties(&self) -> &ClientVpnEndpointProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut ClientVpnEndpointProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for ClientVpnEndpoint {}

impl From<ClientVpnEndpointProperties> for ClientVpnEndpoint {
    fn from(properties: ClientVpnEndpointProperties) -> ClientVpnEndpoint {
        ClientVpnEndpoint { properties }
    }
}

/// The [`AWS::EC2::ClientVpnRoute`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html) resource type.
#[derive(Debug, Default)]
pub struct ClientVpnRoute {
    properties: ClientVpnRouteProperties
}

/// Properties for the `ClientVpnRoute` resource.
#[derive(Debug, Default)]
pub struct ClientVpnRouteProperties {
    /// Property [`ClientVpnEndpointId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html#cfn-ec2-clientvpnroute-clientvpnendpointid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub client_vpn_endpoint_id: ::Value<String>,
    /// Property [`Description`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html#cfn-ec2-clientvpnroute-description).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub description: Option<::Value<String>>,
    /// Property [`DestinationCidrBlock`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html#cfn-ec2-clientvpnroute-destinationcidrblock).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub destination_cidr_block: ::Value<String>,
    /// Property [`TargetVpcSubnetId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html#cfn-ec2-clientvpnroute-targetvpcsubnetid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub target_vpc_subnet_id: ::Value<String>,
}

impl ::serde::Serialize for ClientVpnRouteProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "ClientVpnEndpointId", &self.client_vpn_endpoint_id)?;
        if let Some(ref description) = self.description {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Description", description)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "DestinationCidrBlock", &self.destination_cidr_block)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "TargetVpcSubnetId", &self.target_vpc_subnet_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for ClientVpnRouteProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<ClientVpnRouteProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = ClientVpnRouteProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type ClientVpnRouteProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut client_vpn_endpoint_id: Option<::Value<String>> = None;
                let mut description: Option<::Value<String>> = None;
                let mut destination_cidr_block: Option<::Value<String>> = None;
                let mut target_vpc_subnet_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "ClientVpnEndpointId" => {
                            client_vpn_endpoint_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Description" => {
                            description = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "DestinationCidrBlock" => {
                            destination_cidr_block = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TargetVpcSubnetId" => {
                            target_vpc_subnet_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(ClientVpnRouteProperties {
                    client_vpn_endpoint_id: client_vpn_endpoint_id.ok_or(::serde::de::Error::missing_field("ClientVpnEndpointId"))?,
                    description: description,
                    destination_cidr_block: destination_cidr_block.ok_or(::serde::de::Error::missing_field("DestinationCidrBlock"))?,
                    target_vpc_subnet_id: target_vpc_subnet_id.ok_or(::serde::de::Error::missing_field("TargetVpcSubnetId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for ClientVpnRoute {
    type Properties = ClientVpnRouteProperties;
    const TYPE: &'static str = "AWS::EC2::ClientVpnRoute";
    fn properties(&self) -> &ClientVpnRouteProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut ClientVpnRouteProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for ClientVpnRoute {}

impl From<ClientVpnRouteProperties> for ClientVpnRoute {
    fn from(properties: ClientVpnRouteProperties) -> ClientVpnRoute {
        ClientVpnRoute { properties }
    }
}

/// The [`AWS::EC2::ClientVpnTargetNetworkAssociation`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpntargetnetworkassociation.html) resource type.
#[derive(Debug, Default)]
pub struct ClientVpnTargetNetworkAssociation {
    properties: ClientVpnTargetNetworkAssociationProperties
}

/// Properties for the `ClientVpnTargetNetworkAssociation` resource.
#[derive(Debug, Default)]
pub struct ClientVpnTargetNetworkAssociationProperties {
    /// Property [`ClientVpnEndpointId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpntargetnetworkassociation.html#cfn-ec2-clientvpntargetnetworkassociation-clientvpnendpointid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub client_vpn_endpoint_id: ::Value<String>,
    /// Property [`SubnetId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpntargetnetworkassociation.html#cfn-ec2-clientvpntargetnetworkassociation-subnetid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub subnet_id: ::Value<String>,
}

impl ::serde::Serialize for ClientVpnTargetNetworkAssociationProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "ClientVpnEndpointId", &self.client_vpn_endpoint_id)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "SubnetId", &self.subnet_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for ClientVpnTargetNetworkAssociationProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<ClientVpnTargetNetworkAssociationProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = ClientVpnTargetNetworkAssociationProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type ClientVpnTargetNetworkAssociationProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut client_vpn_endpoint_id: Option<::Value<String>> = None;
                let mut subnet_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "ClientVpnEndpointId" => {
                            client_vpn_endpoint_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SubnetId" => {
                            subnet_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(ClientVpnTargetNetworkAssociationProperties {
                    client_vpn_endpoint_id: client_vpn_endpoint_id.ok_or(::serde::de::Error::missing_field("ClientVpnEndpointId"))?,
                    subnet_id: subnet_id.ok_or(::serde::de::Error::missing_field("SubnetId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for ClientVpnTargetNetworkAssociation {
    type Properties = ClientVpnTargetNetworkAssociationProperties;
    const TYPE: &'static str = "AWS::EC2::ClientVpnTargetNetworkAssociation";
    fn properties(&self) -> &ClientVpnTargetNetworkAssociationProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut ClientVpnTargetNetworkAssociationProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for ClientVpnTargetNetworkAssociation {}

impl From<ClientVpnTargetNetworkAssociationProperties> for ClientVpnTargetNetworkAssociation {
    fn from(properties: ClientVpnTargetNetworkAssociationProperties) -> ClientVpnTargetNetworkAssociation {
        ClientVpnTargetNetworkAssociation { properties }
    }
}

/// The [`AWS::EC2::CustomerGateway`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html) resource type.
#[derive(Debug, Default)]
pub struct CustomerGateway {
    properties: CustomerGatewayProperties
}

/// Properties for the `CustomerGateway` resource.
#[derive(Debug, Default)]
pub struct CustomerGatewayProperties {
    /// Property [`BgpAsn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-bgpasn).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub bgp_asn: ::Value<u32>,
    /// Property [`DeviceName`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-devicename).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub device_name: Option<::Value<String>>,
    /// Property [`IpAddress`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-ipaddress).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub ip_address: ::Value<String>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
    /// Property [`Type`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-type).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub r#type: ::Value<String>,
}

impl ::serde::Serialize for CustomerGatewayProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "BgpAsn", &self.bgp_asn)?;
        if let Some(ref device_name) = self.device_name {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "DeviceName", device_name)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "IpAddress", &self.ip_address)?;
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "Type", &self.r#type)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for CustomerGatewayProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<CustomerGatewayProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = CustomerGatewayProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type CustomerGatewayProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut bgp_asn: Option<::Value<u32>> = None;
                let mut device_name: Option<::Value<String>> = None;
                let mut ip_address: Option<::Value<String>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;
                let mut r#type: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "BgpAsn" => {
                            bgp_asn = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "DeviceName" => {
                            device_name = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "IpAddress" => {
                            ip_address = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Type" => {
                            r#type = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(CustomerGatewayProperties {
                    bgp_asn: bgp_asn.ok_or(::serde::de::Error::missing_field("BgpAsn"))?,
                    device_name: device_name,
                    ip_address: ip_address.ok_or(::serde::de::Error::missing_field("IpAddress"))?,
                    tags: tags,
                    r#type: r#type.ok_or(::serde::de::Error::missing_field("Type"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for CustomerGateway {
    type Properties = CustomerGatewayProperties;
    const TYPE: &'static str = "AWS::EC2::CustomerGateway";
    fn properties(&self) -> &CustomerGatewayProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut CustomerGatewayProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for CustomerGateway {}

impl From<CustomerGatewayProperties> for CustomerGateway {
    fn from(properties: CustomerGatewayProperties) -> CustomerGateway {
        CustomerGateway { properties }
    }
}

/// The [`AWS::EC2::DHCPOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html) resource type.
#[derive(Debug, Default)]
pub struct DHCPOptions {
    properties: DHCPOptionsProperties
}

/// Properties for the `DHCPOptions` resource.
#[derive(Debug, Default)]
pub struct DHCPOptionsProperties {
    /// Property [`DomainName`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-domainname).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub domain_name: Option<::Value<String>>,
    /// Property [`DomainNameServers`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-domainnameservers).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub domain_name_servers: Option<::ValueList<String>>,
    /// Property [`NetbiosNameServers`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-netbiosnameservers).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub netbios_name_servers: Option<::ValueList<String>>,
    /// Property [`NetbiosNodeType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-netbiosnodetype).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub netbios_node_type: Option<::Value<u32>>,
    /// Property [`NtpServers`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-ntpservers).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub ntp_servers: Option<::ValueList<String>>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
}

impl ::serde::Serialize for DHCPOptionsProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref domain_name) = self.domain_name {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "DomainName", domain_name)?;
        }
        if let Some(ref domain_name_servers) = self.domain_name_servers {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "DomainNameServers", domain_name_servers)?;
        }
        if let Some(ref netbios_name_servers) = self.netbios_name_servers {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetbiosNameServers", netbios_name_servers)?;
        }
        if let Some(ref netbios_node_type) = self.netbios_node_type {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetbiosNodeType", netbios_node_type)?;
        }
        if let Some(ref ntp_servers) = self.ntp_servers {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "NtpServers", ntp_servers)?;
        }
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for DHCPOptionsProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<DHCPOptionsProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = DHCPOptionsProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type DHCPOptionsProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut domain_name: Option<::Value<String>> = None;
                let mut domain_name_servers: Option<::ValueList<String>> = None;
                let mut netbios_name_servers: Option<::ValueList<String>> = None;
                let mut netbios_node_type: Option<::Value<u32>> = None;
                let mut ntp_servers: Option<::ValueList<String>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "DomainName" => {
                            domain_name = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "DomainNameServers" => {
                            domain_name_servers = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "NetbiosNameServers" => {
                            netbios_name_servers = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "NetbiosNodeType" => {
                            netbios_node_type = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "NtpServers" => {
                            ntp_servers = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(DHCPOptionsProperties {
                    domain_name: domain_name,
                    domain_name_servers: domain_name_servers,
                    netbios_name_servers: netbios_name_servers,
                    netbios_node_type: netbios_node_type,
                    ntp_servers: ntp_servers,
                    tags: tags,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for DHCPOptions {
    type Properties = DHCPOptionsProperties;
    const TYPE: &'static str = "AWS::EC2::DHCPOptions";
    fn properties(&self) -> &DHCPOptionsProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut DHCPOptionsProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for DHCPOptions {}

impl From<DHCPOptionsProperties> for DHCPOptions {
    fn from(properties: DHCPOptionsProperties) -> DHCPOptions {
        DHCPOptions { properties }
    }
}

/// The [`AWS::EC2::EC2Fleet`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html) resource type.
#[derive(Debug, Default)]
pub struct EC2Fleet {
    properties: EC2FleetProperties
}

/// Properties for the `EC2Fleet` resource.
#[derive(Debug, Default)]
pub struct EC2FleetProperties {
    /// Property [`Context`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-context).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub context: Option<::Value<String>>,
    /// Property [`ExcessCapacityTerminationPolicy`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-excesscapacityterminationpolicy).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub excess_capacity_termination_policy: Option<::Value<String>>,
    /// Property [`LaunchTemplateConfigs`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-launchtemplateconfigs).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub launch_template_configs: ::ValueList<self::ec2_fleet::FleetLaunchTemplateConfigRequest>,
    /// Property [`OnDemandOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-ondemandoptions).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub on_demand_options: Option<::Value<self::ec2_fleet::OnDemandOptionsRequest>>,
    /// Property [`ReplaceUnhealthyInstances`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-replaceunhealthyinstances).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub replace_unhealthy_instances: Option<::Value<bool>>,
    /// Property [`SpotOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-spotoptions).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub spot_options: Option<::Value<self::ec2_fleet::SpotOptionsRequest>>,
    /// Property [`TagSpecifications`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-tagspecifications).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub tag_specifications: Option<::ValueList<self::ec2_fleet::TagSpecification>>,
    /// Property [`TargetCapacitySpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-targetcapacityspecification).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub target_capacity_specification: ::Value<self::ec2_fleet::TargetCapacitySpecificationRequest>,
    /// Property [`TerminateInstancesWithExpiration`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-terminateinstanceswithexpiration).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub terminate_instances_with_expiration: Option<::Value<bool>>,
    /// Property [`Type`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-type).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub r#type: Option<::Value<String>>,
    /// Property [`ValidFrom`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-validfrom).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub valid_from: Option<::Value<String>>,
    /// Property [`ValidUntil`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-validuntil).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub valid_until: Option<::Value<String>>,
}

impl ::serde::Serialize for EC2FleetProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref context) = self.context {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Context", context)?;
        }
        if let Some(ref excess_capacity_termination_policy) = self.excess_capacity_termination_policy {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "ExcessCapacityTerminationPolicy", excess_capacity_termination_policy)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "LaunchTemplateConfigs", &self.launch_template_configs)?;
        if let Some(ref on_demand_options) = self.on_demand_options {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "OnDemandOptions", on_demand_options)?;
        }
        if let Some(ref replace_unhealthy_instances) = self.replace_unhealthy_instances {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "ReplaceUnhealthyInstances", replace_unhealthy_instances)?;
        }
        if let Some(ref spot_options) = self.spot_options {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SpotOptions", spot_options)?;
        }
        if let Some(ref tag_specifications) = self.tag_specifications {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "TagSpecifications", tag_specifications)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "TargetCapacitySpecification", &self.target_capacity_specification)?;
        if let Some(ref terminate_instances_with_expiration) = self.terminate_instances_with_expiration {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "TerminateInstancesWithExpiration", terminate_instances_with_expiration)?;
        }
        if let Some(ref r#type) = self.r#type {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Type", r#type)?;
        }
        if let Some(ref valid_from) = self.valid_from {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "ValidFrom", valid_from)?;
        }
        if let Some(ref valid_until) = self.valid_until {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "ValidUntil", valid_until)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for EC2FleetProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<EC2FleetProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = EC2FleetProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type EC2FleetProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut context: Option<::Value<String>> = None;
                let mut excess_capacity_termination_policy: Option<::Value<String>> = None;
                let mut launch_template_configs: Option<::ValueList<self::ec2_fleet::FleetLaunchTemplateConfigRequest>> = None;
                let mut on_demand_options: Option<::Value<self::ec2_fleet::OnDemandOptionsRequest>> = None;
                let mut replace_unhealthy_instances: Option<::Value<bool>> = None;
                let mut spot_options: Option<::Value<self::ec2_fleet::SpotOptionsRequest>> = None;
                let mut tag_specifications: Option<::ValueList<self::ec2_fleet::TagSpecification>> = None;
                let mut target_capacity_specification: Option<::Value<self::ec2_fleet::TargetCapacitySpecificationRequest>> = None;
                let mut terminate_instances_with_expiration: Option<::Value<bool>> = None;
                let mut r#type: Option<::Value<String>> = None;
                let mut valid_from: Option<::Value<String>> = None;
                let mut valid_until: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "Context" => {
                            context = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "ExcessCapacityTerminationPolicy" => {
                            excess_capacity_termination_policy = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "LaunchTemplateConfigs" => {
                            launch_template_configs = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "OnDemandOptions" => {
                            on_demand_options = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "ReplaceUnhealthyInstances" => {
                            replace_unhealthy_instances = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SpotOptions" => {
                            spot_options = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TagSpecifications" => {
                            tag_specifications = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TargetCapacitySpecification" => {
                            target_capacity_specification = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TerminateInstancesWithExpiration" => {
                            terminate_instances_with_expiration = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Type" => {
                            r#type = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "ValidFrom" => {
                            valid_from = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "ValidUntil" => {
                            valid_until = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(EC2FleetProperties {
                    context: context,
                    excess_capacity_termination_policy: excess_capacity_termination_policy,
                    launch_template_configs: launch_template_configs.ok_or(::serde::de::Error::missing_field("LaunchTemplateConfigs"))?,
                    on_demand_options: on_demand_options,
                    replace_unhealthy_instances: replace_unhealthy_instances,
                    spot_options: spot_options,
                    tag_specifications: tag_specifications,
                    target_capacity_specification: target_capacity_specification.ok_or(::serde::de::Error::missing_field("TargetCapacitySpecification"))?,
                    terminate_instances_with_expiration: terminate_instances_with_expiration,
                    r#type: r#type,
                    valid_from: valid_from,
                    valid_until: valid_until,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for EC2Fleet {
    type Properties = EC2FleetProperties;
    const TYPE: &'static str = "AWS::EC2::EC2Fleet";
    fn properties(&self) -> &EC2FleetProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut EC2FleetProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for EC2Fleet {}

impl From<EC2FleetProperties> for EC2Fleet {
    fn from(properties: EC2FleetProperties) -> EC2Fleet {
        EC2Fleet { properties }
    }
}

/// The [`AWS::EC2::EIP`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html) resource type.
#[derive(Debug, Default)]
pub struct EIP {
    properties: EIPProperties
}

/// Properties for the `EIP` resource.
#[derive(Debug, Default)]
pub struct EIPProperties {
    /// Property [`Domain`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-domain).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub domain: Option<::Value<String>>,
    /// Property [`InstanceId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-instanceid).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub instance_id: Option<::Value<String>>,
    /// Property [`NetworkBorderGroup`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-networkbordergroup).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub network_border_group: Option<::Value<String>>,
    /// Property [`PublicIpv4Pool`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-publicipv4pool).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub public_ipv4_pool: Option<::Value<String>>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
    /// Property [`TransferAddress`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eip.html#cfn-ec2-eip-transferaddress).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub transfer_address: Option<::Value<String>>,
}

impl ::serde::Serialize for EIPProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref domain) = self.domain {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Domain", domain)?;
        }
        if let Some(ref instance_id) = self.instance_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstanceId", instance_id)?;
        }
        if let Some(ref network_border_group) = self.network_border_group {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetworkBorderGroup", network_border_group)?;
        }
        if let Some(ref public_ipv4_pool) = self.public_ipv4_pool {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "PublicIpv4Pool", public_ipv4_pool)?;
        }
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        if let Some(ref transfer_address) = self.transfer_address {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "TransferAddress", transfer_address)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for EIPProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<EIPProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = EIPProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type EIPProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut domain: Option<::Value<String>> = None;
                let mut instance_id: Option<::Value<String>> = None;
                let mut network_border_group: Option<::Value<String>> = None;
                let mut public_ipv4_pool: Option<::Value<String>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;
                let mut transfer_address: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "Domain" => {
                            domain = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "InstanceId" => {
                            instance_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "NetworkBorderGroup" => {
                            network_border_group = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "PublicIpv4Pool" => {
                            public_ipv4_pool = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TransferAddress" => {
                            transfer_address = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(EIPProperties {
                    domain: domain,
                    instance_id: instance_id,
                    network_border_group: network_border_group,
                    public_ipv4_pool: public_ipv4_pool,
                    tags: tags,
                    transfer_address: transfer_address,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for EIP {
    type Properties = EIPProperties;
    const TYPE: &'static str = "AWS::EC2::EIP";
    fn properties(&self) -> &EIPProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut EIPProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for EIP {}

impl From<EIPProperties> for EIP {
    fn from(properties: EIPProperties) -> EIP {
        EIP { properties }
    }
}

/// The [`AWS::EC2::EIPAssociation`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html) resource type.
#[derive(Debug, Default)]
pub struct EIPAssociation {
    properties: EIPAssociationProperties
}

/// Properties for the `EIPAssociation` resource.
#[derive(Debug, Default)]
pub struct EIPAssociationProperties {
    /// Property [`AllocationId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html#cfn-ec2-eipassociation-allocationid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub allocation_id: Option<::Value<String>>,
    /// Property [`InstanceId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html#cfn-ec2-eipassociation-instanceid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub instance_id: Option<::Value<String>>,
    /// Property [`NetworkInterfaceId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html#cfn-ec2-eipassociation-networkinterfaceid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub network_interface_id: Option<::Value<String>>,
    /// Property [`PrivateIpAddress`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-eipassociation.html#cfn-ec2-eipassociation-privateipaddress).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub private_ip_address: Option<::Value<String>>,
}

impl ::serde::Serialize for EIPAssociationProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref allocation_id) = self.allocation_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "AllocationId", allocation_id)?;
        }
        if let Some(ref instance_id) = self.instance_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstanceId", instance_id)?;
        }
        if let Some(ref network_interface_id) = self.network_interface_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetworkInterfaceId", network_interface_id)?;
        }
        if let Some(ref private_ip_address) = self.private_ip_address {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "PrivateIpAddress", private_ip_address)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for EIPAssociationProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<EIPAssociationProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = EIPAssociationProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type EIPAssociationProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut allocation_id: Option<::Value<String>> = None;
                let mut instance_id: Option<::Value<String>> = None;
                let mut network_interface_id: Option<::Value<String>> = None;
                let mut private_ip_address: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "AllocationId" => {
                            allocation_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "InstanceId" => {
                            instance_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "NetworkInterfaceId" => {
                            network_interface_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "PrivateIpAddress" => {
                            private_ip_address = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(EIPAssociationProperties {
                    allocation_id: allocation_id,
                    instance_id: instance_id,
                    network_interface_id: network_interface_id,
                    private_ip_address: private_ip_address,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for EIPAssociation {
    type Properties = EIPAssociationProperties;
    const TYPE: &'static str = "AWS::EC2::EIPAssociation";
    fn properties(&self) -> &EIPAssociationProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut EIPAssociationProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for EIPAssociation {}

impl From<EIPAssociationProperties> for EIPAssociation {
    fn from(properties: EIPAssociationProperties) -> EIPAssociation {
        EIPAssociation { properties }
    }
}

/// The [`AWS::EC2::EgressOnlyInternetGateway`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-egressonlyinternetgateway.html) resource type.
#[derive(Debug, Default)]
pub struct EgressOnlyInternetGateway {
    properties: EgressOnlyInternetGatewayProperties
}

/// Properties for the `EgressOnlyInternetGateway` resource.
#[derive(Debug, Default)]
pub struct EgressOnlyInternetGatewayProperties {
    /// Property [`VpcId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-egressonlyinternetgateway.html#cfn-ec2-egressonlyinternetgateway-vpcid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub vpc_id: ::Value<String>,
}

impl ::serde::Serialize for EgressOnlyInternetGatewayProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "VpcId", &self.vpc_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for EgressOnlyInternetGatewayProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<EgressOnlyInternetGatewayProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = EgressOnlyInternetGatewayProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type EgressOnlyInternetGatewayProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut vpc_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "VpcId" => {
                            vpc_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(EgressOnlyInternetGatewayProperties {
                    vpc_id: vpc_id.ok_or(::serde::de::Error::missing_field("VpcId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for EgressOnlyInternetGateway {
    type Properties = EgressOnlyInternetGatewayProperties;
    const TYPE: &'static str = "AWS::EC2::EgressOnlyInternetGateway";
    fn properties(&self) -> &EgressOnlyInternetGatewayProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut EgressOnlyInternetGatewayProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for EgressOnlyInternetGateway {}

impl From<EgressOnlyInternetGatewayProperties> for EgressOnlyInternetGateway {
    fn from(properties: EgressOnlyInternetGatewayProperties) -> EgressOnlyInternetGateway {
        EgressOnlyInternetGateway { properties }
    }
}

/// The [`AWS::EC2::EnclaveCertificateIamRoleAssociation`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-enclavecertificateiamroleassociation.html) resource type.
#[derive(Debug, Default)]
pub struct EnclaveCertificateIamRoleAssociation {
    properties: EnclaveCertificateIamRoleAssociationProperties
}

/// Properties for the `EnclaveCertificateIamRoleAssociation` resource.
#[derive(Debug, Default)]
pub struct EnclaveCertificateIamRoleAssociationProperties {
    /// Property [`CertificateArn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-enclavecertificateiamroleassociation.html#cfn-ec2-enclavecertificateiamroleassociation-certificatearn).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub certificate_arn: ::Value<String>,
    /// Property [`RoleArn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-enclavecertificateiamroleassociation.html#cfn-ec2-enclavecertificateiamroleassociation-rolearn).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub role_arn: ::Value<String>,
}

impl ::serde::Serialize for EnclaveCertificateIamRoleAssociationProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "CertificateArn", &self.certificate_arn)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "RoleArn", &self.role_arn)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for EnclaveCertificateIamRoleAssociationProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<EnclaveCertificateIamRoleAssociationProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = EnclaveCertificateIamRoleAssociationProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type EnclaveCertificateIamRoleAssociationProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut certificate_arn: Option<::Value<String>> = None;
                let mut role_arn: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "CertificateArn" => {
                            certificate_arn = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "RoleArn" => {
                            role_arn = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(EnclaveCertificateIamRoleAssociationProperties {
                    certificate_arn: certificate_arn.ok_or(::serde::de::Error::missing_field("CertificateArn"))?,
                    role_arn: role_arn.ok_or(::serde::de::Error::missing_field("RoleArn"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for EnclaveCertificateIamRoleAssociation {
    type Properties = EnclaveCertificateIamRoleAssociationProperties;
    const TYPE: &'static str = "AWS::EC2::EnclaveCertificateIamRoleAssociation";
    fn properties(&self) -> &EnclaveCertificateIamRoleAssociationProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut EnclaveCertificateIamRoleAssociationProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for EnclaveCertificateIamRoleAssociation {}

impl From<EnclaveCertificateIamRoleAssociationProperties> for EnclaveCertificateIamRoleAssociation {
    fn from(properties: EnclaveCertificateIamRoleAssociationProperties) -> EnclaveCertificateIamRoleAssociation {
        EnclaveCertificateIamRoleAssociation { properties }
    }
}

/// The [`AWS::EC2::FlowLog`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html) resource type.
#[derive(Debug, Default)]
pub struct FlowLog {
    properties: FlowLogProperties
}

/// Properties for the `FlowLog` resource.
#[derive(Debug, Default)]
pub struct FlowLogProperties {
    /// Property [`DeliverCrossAccountRole`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-delivercrossaccountrole).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub deliver_cross_account_role: Option<::Value<String>>,
    /// Property [`DeliverLogsPermissionArn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-deliverlogspermissionarn).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub deliver_logs_permission_arn: Option<::Value<String>>,
    /// Property [`DestinationOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-destinationoptions).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub destination_options: Option<::Value<self::flow_log::DestinationOptions>>,
    /// Property [`LogDestination`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logdestination).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub log_destination: Option<::Value<String>>,
    /// Property [`LogDestinationType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logdestinationtype).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub log_destination_type: Option<::Value<String>>,
    /// Property [`LogFormat`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logformat).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub log_format: Option<::Value<String>>,
    /// Property [`LogGroupName`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-loggroupname).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub log_group_name: Option<::Value<String>>,
    /// Property [`MaxAggregationInterval`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-maxaggregationinterval).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub max_aggregation_interval: Option<::Value<u32>>,
    /// Property [`ResourceId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-resourceid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub resource_id: ::Value<String>,
    /// Property [`ResourceType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-resourcetype).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub resource_type: ::Value<String>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
    /// Property [`TrafficType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-traffictype).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub traffic_type: Option<::Value<String>>,
}

impl ::serde::Serialize for FlowLogProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref deliver_cross_account_role) = self.deliver_cross_account_role {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "DeliverCrossAccountRole", deliver_cross_account_role)?;
        }
        if let Some(ref deliver_logs_permission_arn) = self.deliver_logs_permission_arn {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "DeliverLogsPermissionArn", deliver_logs_permission_arn)?;
        }
        if let Some(ref destination_options) = self.destination_options {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "DestinationOptions", destination_options)?;
        }
        if let Some(ref log_destination) = self.log_destination {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "LogDestination", log_destination)?;
        }
        if let Some(ref log_destination_type) = self.log_destination_type {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "LogDestinationType", log_destination_type)?;
        }
        if let Some(ref log_format) = self.log_format {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "LogFormat", log_format)?;
        }
        if let Some(ref log_group_name) = self.log_group_name {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "LogGroupName", log_group_name)?;
        }
        if let Some(ref max_aggregation_interval) = self.max_aggregation_interval {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "MaxAggregationInterval", max_aggregation_interval)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "ResourceId", &self.resource_id)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "ResourceType", &self.resource_type)?;
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        if let Some(ref traffic_type) = self.traffic_type {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "TrafficType", traffic_type)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for FlowLogProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<FlowLogProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = FlowLogProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type FlowLogProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut deliver_cross_account_role: Option<::Value<String>> = None;
                let mut deliver_logs_permission_arn: Option<::Value<String>> = None;
                let mut destination_options: Option<::Value<self::flow_log::DestinationOptions>> = None;
                let mut log_destination: Option<::Value<String>> = None;
                let mut log_destination_type: Option<::Value<String>> = None;
                let mut log_format: Option<::Value<String>> = None;
                let mut log_group_name: Option<::Value<String>> = None;
                let mut max_aggregation_interval: Option<::Value<u32>> = None;
                let mut resource_id: Option<::Value<String>> = None;
                let mut resource_type: Option<::Value<String>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;
                let mut traffic_type: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "DeliverCrossAccountRole" => {
                            deliver_cross_account_role = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "DeliverLogsPermissionArn" => {
                            deliver_logs_permission_arn = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "DestinationOptions" => {
                            destination_options = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "LogDestination" => {
                            log_destination = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "LogDestinationType" => {
                            log_destination_type = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "LogFormat" => {
                            log_format = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "LogGroupName" => {
                            log_group_name = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "MaxAggregationInterval" => {
                            max_aggregation_interval = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "ResourceId" => {
                            resource_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "ResourceType" => {
                            resource_type = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TrafficType" => {
                            traffic_type = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(FlowLogProperties {
                    deliver_cross_account_role: deliver_cross_account_role,
                    deliver_logs_permission_arn: deliver_logs_permission_arn,
                    destination_options: destination_options,
                    log_destination: log_destination,
                    log_destination_type: log_destination_type,
                    log_format: log_format,
                    log_group_name: log_group_name,
                    max_aggregation_interval: max_aggregation_interval,
                    resource_id: resource_id.ok_or(::serde::de::Error::missing_field("ResourceId"))?,
                    resource_type: resource_type.ok_or(::serde::de::Error::missing_field("ResourceType"))?,
                    tags: tags,
                    traffic_type: traffic_type,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for FlowLog {
    type Properties = FlowLogProperties;
    const TYPE: &'static str = "AWS::EC2::FlowLog";
    fn properties(&self) -> &FlowLogProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut FlowLogProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for FlowLog {}

impl From<FlowLogProperties> for FlowLog {
    fn from(properties: FlowLogProperties) -> FlowLog {
        FlowLog { properties }
    }
}

/// The [`AWS::EC2::GatewayRouteTableAssociation`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-gatewayroutetableassociation.html) resource type.
#[derive(Debug, Default)]
pub struct GatewayRouteTableAssociation {
    properties: GatewayRouteTableAssociationProperties
}

/// Properties for the `GatewayRouteTableAssociation` resource.
#[derive(Debug, Default)]
pub struct GatewayRouteTableAssociationProperties {
    /// Property [`GatewayId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-gatewayroutetableassociation.html#cfn-ec2-gatewayroutetableassociation-gatewayid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub gateway_id: ::Value<String>,
    /// Property [`RouteTableId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-gatewayroutetableassociation.html#cfn-ec2-gatewayroutetableassociation-routetableid).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub route_table_id: ::Value<String>,
}

impl ::serde::Serialize for GatewayRouteTableAssociationProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "GatewayId", &self.gateway_id)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "RouteTableId", &self.route_table_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for GatewayRouteTableAssociationProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<GatewayRouteTableAssociationProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = GatewayRouteTableAssociationProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type GatewayRouteTableAssociationProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut gateway_id: Option<::Value<String>> = None;
                let mut route_table_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "GatewayId" => {
                            gateway_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "RouteTableId" => {
                            route_table_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(GatewayRouteTableAssociationProperties {
                    gateway_id: gateway_id.ok_or(::serde::de::Error::missing_field("GatewayId"))?,
                    route_table_id: route_table_id.ok_or(::serde::de::Error::missing_field("RouteTableId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for GatewayRouteTableAssociation {
    type Properties = GatewayRouteTableAssociationProperties;
    const TYPE: &'static str = "AWS::EC2::GatewayRouteTableAssociation";
    fn properties(&self) -> &GatewayRouteTableAssociationProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut GatewayRouteTableAssociationProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for GatewayRouteTableAssociation {}

impl From<GatewayRouteTableAssociationProperties> for GatewayRouteTableAssociation {
    fn from(properties: GatewayRouteTableAssociationProperties) -> GatewayRouteTableAssociation {
        GatewayRouteTableAssociation { properties }
    }
}

/// The [`AWS::EC2::Host`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html) resource type.
#[derive(Debug, Default)]
pub struct Host {
    properties: HostProperties
}

/// Properties for the `Host` resource.
#[derive(Debug, Default)]
pub struct HostProperties {
    /// Property [`AssetId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-assetid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub asset_id: Option<::Value<String>>,
    /// Property [`AutoPlacement`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-autoplacement).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub auto_placement: Option<::Value<String>>,
    /// Property [`AvailabilityZone`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-availabilityzone).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub availability_zone: ::Value<String>,
    /// Property [`HostMaintenance`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-hostmaintenance).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub host_maintenance: Option<::Value<String>>,
    /// Property [`HostRecovery`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-hostrecovery).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub host_recovery: Option<::Value<String>>,
    /// Property [`InstanceFamily`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-instancefamily).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub instance_family: Option<::Value<String>>,
    /// Property [`InstanceType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-instancetype).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub instance_type: Option<::Value<String>>,
    /// Property [`OutpostArn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-outpostarn).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub outpost_arn: Option<::Value<String>>,
}

impl ::serde::Serialize for HostProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref asset_id) = self.asset_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "AssetId", asset_id)?;
        }
        if let Some(ref auto_placement) = self.auto_placement {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "AutoPlacement", auto_placement)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "AvailabilityZone", &self.availability_zone)?;
        if let Some(ref host_maintenance) = self.host_maintenance {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "HostMaintenance", host_maintenance)?;
        }
        if let Some(ref host_recovery) = self.host_recovery {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "HostRecovery", host_recovery)?;
        }
        if let Some(ref instance_family) = self.instance_family {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstanceFamily", instance_family)?;
        }
        if let Some(ref instance_type) = self.instance_type {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstanceType", instance_type)?;
        }
        if let Some(ref outpost_arn) = self.outpost_arn {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "OutpostArn", outpost_arn)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for HostProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<HostProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = HostProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type HostProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut asset_id: Option<::Value<String>> = None;
                let mut auto_placement: Option<::Value<String>> = None;
                let mut availability_zone: Option<::Value<String>> = None;
                let mut host_maintenance: Option<::Value<String>> = None;
                let mut host_recovery: Option<::Value<String>> = None;
                let mut instance_family: Option<::Value<String>> = None;
                let mut instance_type: Option<::Value<String>> = None;
                let mut outpost_arn: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "AssetId" => {
                            asset_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "AutoPlacement" => {
                            auto_placement = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "AvailabilityZone" => {
                            availability_zone = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "HostMaintenance" => {
                            host_maintenance = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "HostRecovery" => {
                            host_recovery = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "InstanceFamily" => {
                            instance_family = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "InstanceType" => {
                            instance_type = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "OutpostArn" => {
                            outpost_arn = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(HostProperties {
                    asset_id: asset_id,
                    auto_placement: auto_placement,
                    availability_zone: availability_zone.ok_or(::serde::de::Error::missing_field("AvailabilityZone"))?,
                    host_maintenance: host_maintenance,
                    host_recovery: host_recovery,
                    instance_family: instance_family,
                    instance_type: instance_type,
                    outpost_arn: outpost_arn,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for Host {
    type Properties = HostProperties;
    const TYPE: &'static str = "AWS::EC2::Host";
    fn properties(&self) -> &HostProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut HostProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for Host {}

impl From<HostProperties> for Host {
    fn from(properties: HostProperties) -> Host {
        Host { properties }
    }
}

/// The [`AWS::EC2::IPAM`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html) resource type.
#[derive(Debug, Default)]
pub struct IPAM {
    properties: IPAMProperties
}

/// Properties for the `IPAM` resource.
#[derive(Debug, Default)]
pub struct IPAMProperties {
    /// Property [`Description`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-description).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub description: Option<::Value<String>>,
    /// Property [`OperatingRegions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-operatingregions).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub operating_regions: Option<::ValueList<self::ipam::IpamOperatingRegion>>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
    /// Property [`Tier`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-tier).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tier: Option<::Value<String>>,
}

impl ::serde::Serialize for IPAMProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref description) = self.description {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Description", description)?;
        }
        if let Some(ref operating_regions) = self.operating_regions {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "OperatingRegions", operating_regions)?;
        }
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        if let Some(ref tier) = self.tier {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tier", tier)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for IPAMProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<IPAMProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = IPAMProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type IPAMProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut description: Option<::Value<String>> = None;
                let mut operating_regions: Option<::ValueList<self::ipam::IpamOperatingRegion>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;
                let mut tier: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "Description" => {
                            description = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "OperatingRegions" => {
                            operating_regions = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tier" => {
                            tier = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(IPAMProperties {
                    description: description,
                    operating_regions: operating_regions,
                    tags: tags,
                    tier: tier,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for IPAM {
    type Properties = IPAMProperties;
    const TYPE: &'static str = "AWS::EC2::IPAM";
    fn properties(&self) -> &IPAMProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut IPAMProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for IPAM {}

impl From<IPAMProperties> for IPAM {
    fn from(properties: IPAMProperties) -> IPAM {
        IPAM { properties }
    }
}

/// The [`AWS::EC2::IPAMAllocation`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html) resource type.
#[derive(Debug, Default)]
pub struct IPAMAllocation {
    properties: IPAMAllocationProperties
}

/// Properties for the `IPAMAllocation` resource.
#[derive(Debug, Default)]
pub struct IPAMAllocationProperties {
    /// Property [`Cidr`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html#cfn-ec2-ipamallocation-cidr).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub cidr: Option<::Value<String>>,
    /// Property [`Description`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html#cfn-ec2-ipamallocation-description).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub description: Option<::Value<String>>,
    /// Property [`IpamPoolId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html#cfn-ec2-ipamallocation-ipampoolid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub ipam_pool_id: ::Value<String>,
    /// Property [`NetmaskLength`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html#cfn-ec2-ipamallocation-netmasklength).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub netmask_length: Option<::Value<u32>>,
}

impl ::serde::Serialize for IPAMAllocationProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref cidr) = self.cidr {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Cidr", cidr)?;
        }
        if let Some(ref description) = self.description {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Description", description)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "IpamPoolId", &self.ipam_pool_id)?;
        if let Some(ref netmask_length) = self.netmask_length {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetmaskLength", netmask_length)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for IPAMAllocationProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<IPAMAllocationProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = IPAMAllocationProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type IPAMAllocationProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut cidr: Option<::Value<String>> = None;
                let mut description: Option<::Value<String>> = None;
                let mut ipam_pool_id: Option<::Value<String>> = None;
                let mut netmask_length: Option<::Value<u32>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "Cidr" => {
                            cidr = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Description" => {
                            description = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "IpamPoolId" => {
                            ipam_pool_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "NetmaskLength" => {
                            netmask_length = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(IPAMAllocationProperties {
                    cidr: cidr,
                    description: description,
                    ipam_pool_id: ipam_pool_id.ok_or(::serde::de::Error::missing_field("IpamPoolId"))?,
                    netmask_length: netmask_length,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for IPAMAllocation {
    type Properties = IPAMAllocationProperties;
    const TYPE: &'static str = "AWS::EC2::IPAMAllocation";
    fn properties(&self) -> &IPAMAllocationProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut IPAMAllocationProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for IPAMAllocation {}

impl From<IPAMAllocationProperties> for IPAMAllocation {
    fn from(properties: IPAMAllocationProperties) -> IPAMAllocation {
        IPAMAllocation { properties }
    }
}

/// The [`AWS::EC2::IPAMPool`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html) resource type.
#[derive(Debug, Default)]
pub struct IPAMPool {
    properties: IPAMPoolProperties
}

/// Properties for the `IPAMPool` resource.
#[derive(Debug, Default)]
pub struct IPAMPoolProperties {
    /// Property [`AddressFamily`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-addressfamily).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub address_family: ::Value<String>,
    /// Property [`AllocationDefaultNetmaskLength`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-allocationdefaultnetmasklength).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub allocation_default_netmask_length: Option<::Value<u32>>,
    /// Property [`AllocationMaxNetmaskLength`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-allocationmaxnetmasklength).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub allocation_max_netmask_length: Option<::Value<u32>>,
    /// Property [`AllocationMinNetmaskLength`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-allocationminnetmasklength).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub allocation_min_netmask_length: Option<::Value<u32>>,
    /// Property [`AllocationResourceTags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-allocationresourcetags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub allocation_resource_tags: Option<::ValueList<::Tag>>,
    /// Property [`AutoImport`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-autoimport).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub auto_import: Option<::Value<bool>>,
    /// Property [`AwsService`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-awsservice).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub aws_service: Option<::Value<String>>,
    /// Property [`Description`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-description).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub description: Option<::Value<String>>,
    /// Property [`IpamScopeId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-ipamscopeid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub ipam_scope_id: ::Value<String>,
    /// Property [`Locale`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-locale).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub locale: Option<::Value<String>>,
    /// Property [`ProvisionedCidrs`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-provisionedcidrs).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub provisioned_cidrs: Option<::ValueList<self::ipam_pool::ProvisionedCidr>>,
    /// Property [`PublicIpSource`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-publicipsource).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub public_ip_source: Option<::Value<String>>,
    /// Property [`PubliclyAdvertisable`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-publiclyadvertisable).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub publicly_advertisable: Option<::Value<bool>>,
    /// Property [`SourceIpamPoolId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-sourceipampoolid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub source_ipam_pool_id: Option<::Value<String>>,
    /// Property [`SourceResource`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-sourceresource).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub source_resource: Option<::Value<self::ipam_pool::SourceResource>>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
}

impl ::serde::Serialize for IPAMPoolProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "AddressFamily", &self.address_family)?;
        if let Some(ref allocation_default_netmask_length) = self.allocation_default_netmask_length {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "AllocationDefaultNetmaskLength", allocation_default_netmask_length)?;
        }
        if let Some(ref allocation_max_netmask_length) = self.allocation_max_netmask_length {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "AllocationMaxNetmaskLength", allocation_max_netmask_length)?;
        }
        if let Some(ref allocation_min_netmask_length) = self.allocation_min_netmask_length {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "AllocationMinNetmaskLength", allocation_min_netmask_length)?;
        }
        if let Some(ref allocation_resource_tags) = self.allocation_resource_tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "AllocationResourceTags", allocation_resource_tags)?;
        }
        if let Some(ref auto_import) = self.auto_import {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "AutoImport", auto_import)?;
        }
        if let Some(ref aws_service) = self.aws_service {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "AwsService", aws_service)?;
        }
        if let Some(ref description) = self.description {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Description", description)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "IpamScopeId", &self.ipam_scope_id)?;
        if let Some(ref locale) = self.locale {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Locale", locale)?;
        }
        if let Some(ref provisioned_cidrs) = self.provisioned_cidrs {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "ProvisionedCidrs", provisioned_cidrs)?;
        }
        if let Some(ref public_ip_source) = self.public_ip_source {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "PublicIpSource", public_ip_source)?;
        }
        if let Some(ref publicly_advertisable) = self.publicly_advertisable {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "PubliclyAdvertisable", publicly_advertisable)?;
        }
        if let Some(ref source_ipam_pool_id) = self.source_ipam_pool_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SourceIpamPoolId", source_ipam_pool_id)?;
        }
        if let Some(ref source_resource) = self.source_resource {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SourceResource", source_resource)?;
        }
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for IPAMPoolProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<IPAMPoolProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = IPAMPoolProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type IPAMPoolProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut address_family: Option<::Value<String>> = None;
                let mut allocation_default_netmask_length: Option<::Value<u32>> = None;
                let mut allocation_max_netmask_length: Option<::Value<u32>> = None;
                let mut allocation_min_netmask_length: Option<::Value<u32>> = None;
                let mut allocation_resource_tags: Option<::ValueList<::Tag>> = None;
                let mut auto_import: Option<::Value<bool>> = None;
                let mut aws_service: Option<::Value<String>> = None;
                let mut description: Option<::Value<String>> = None;
                let mut ipam_scope_id: Option<::Value<String>> = None;
                let mut locale: Option<::Value<String>> = None;
                let mut provisioned_cidrs: Option<::ValueList<self::ipam_pool::ProvisionedCidr>> = None;
                let mut public_ip_source: Option<::Value<String>> = None;
                let mut publicly_advertisable: Option<::Value<bool>> = None;
                let mut source_ipam_pool_id: Option<::Value<String>> = None;
                let mut source_resource: Option<::Value<self::ipam_pool::SourceResource>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "AddressFamily" => {
                            address_family = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "AllocationDefaultNetmaskLength" => {
                            allocation_default_netmask_length = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "AllocationMaxNetmaskLength" => {
                            allocation_max_netmask_length = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "AllocationMinNetmaskLength" => {
                            allocation_min_netmask_length = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "AllocationResourceTags" => {
                            allocation_resource_tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "AutoImport" => {
                            auto_import = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "AwsService" => {
                            aws_service = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Description" => {
                            description = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "IpamScopeId" => {
                            ipam_scope_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Locale" => {
                            locale = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "ProvisionedCidrs" => {
                            provisioned_cidrs = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "PublicIpSource" => {
                            public_ip_source = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "PubliclyAdvertisable" => {
                            publicly_advertisable = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SourceIpamPoolId" => {
                            source_ipam_pool_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SourceResource" => {
                            source_resource = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(IPAMPoolProperties {
                    address_family: address_family.ok_or(::serde::de::Error::missing_field("AddressFamily"))?,
                    allocation_default_netmask_length: allocation_default_netmask_length,
                    allocation_max_netmask_length: allocation_max_netmask_length,
                    allocation_min_netmask_length: allocation_min_netmask_length,
                    allocation_resource_tags: allocation_resource_tags,
                    auto_import: auto_import,
                    aws_service: aws_service,
                    description: description,
                    ipam_scope_id: ipam_scope_id.ok_or(::serde::de::Error::missing_field("IpamScopeId"))?,
                    locale: locale,
                    provisioned_cidrs: provisioned_cidrs,
                    public_ip_source: public_ip_source,
                    publicly_advertisable: publicly_advertisable,
                    source_ipam_pool_id: source_ipam_pool_id,
                    source_resource: source_resource,
                    tags: tags,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for IPAMPool {
    type Properties = IPAMPoolProperties;
    const TYPE: &'static str = "AWS::EC2::IPAMPool";
    fn properties(&self) -> &IPAMPoolProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut IPAMPoolProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for IPAMPool {}

impl From<IPAMPoolProperties> for IPAMPool {
    fn from(properties: IPAMPoolProperties) -> IPAMPool {
        IPAMPool { properties }
    }
}

/// The [`AWS::EC2::IPAMPoolCidr`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampoolcidr.html) resource type.
#[derive(Debug, Default)]
pub struct IPAMPoolCidr {
    properties: IPAMPoolCidrProperties
}

/// Properties for the `IPAMPoolCidr` resource.
#[derive(Debug, Default)]
pub struct IPAMPoolCidrProperties {
    /// Property [`Cidr`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampoolcidr.html#cfn-ec2-ipampoolcidr-cidr).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub cidr: Option<::Value<String>>,
    /// Property [`IpamPoolId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampoolcidr.html#cfn-ec2-ipampoolcidr-ipampoolid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub ipam_pool_id: ::Value<String>,
    /// Property [`NetmaskLength`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampoolcidr.html#cfn-ec2-ipampoolcidr-netmasklength).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub netmask_length: Option<::Value<u32>>,
}

impl ::serde::Serialize for IPAMPoolCidrProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref cidr) = self.cidr {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Cidr", cidr)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "IpamPoolId", &self.ipam_pool_id)?;
        if let Some(ref netmask_length) = self.netmask_length {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetmaskLength", netmask_length)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for IPAMPoolCidrProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<IPAMPoolCidrProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = IPAMPoolCidrProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type IPAMPoolCidrProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut cidr: Option<::Value<String>> = None;
                let mut ipam_pool_id: Option<::Value<String>> = None;
                let mut netmask_length: Option<::Value<u32>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "Cidr" => {
                            cidr = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "IpamPoolId" => {
                            ipam_pool_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "NetmaskLength" => {
                            netmask_length = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(IPAMPoolCidrProperties {
                    cidr: cidr,
                    ipam_pool_id: ipam_pool_id.ok_or(::serde::de::Error::missing_field("IpamPoolId"))?,
                    netmask_length: netmask_length,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for IPAMPoolCidr {
    type Properties = IPAMPoolCidrProperties;
    const TYPE: &'static str = "AWS::EC2::IPAMPoolCidr";
    fn properties(&self) -> &IPAMPoolCidrProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut IPAMPoolCidrProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for IPAMPoolCidr {}

impl From<IPAMPoolCidrProperties> for IPAMPoolCidr {
    fn from(properties: IPAMPoolCidrProperties) -> IPAMPoolCidr {
        IPAMPoolCidr { properties }
    }
}

/// The [`AWS::EC2::IPAMResourceDiscovery`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscovery.html) resource type.
#[derive(Debug, Default)]
pub struct IPAMResourceDiscovery {
    properties: IPAMResourceDiscoveryProperties
}

/// Properties for the `IPAMResourceDiscovery` resource.
#[derive(Debug, Default)]
pub struct IPAMResourceDiscoveryProperties {
    /// Property [`Description`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscovery.html#cfn-ec2-ipamresourcediscovery-description).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub description: Option<::Value<String>>,
    /// Property [`OperatingRegions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscovery.html#cfn-ec2-ipamresourcediscovery-operatingregions).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub operating_regions: Option<::ValueList<self::ipam_resource_discovery::IpamOperatingRegion>>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscovery.html#cfn-ec2-ipamresourcediscovery-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
}

impl ::serde::Serialize for IPAMResourceDiscoveryProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref description) = self.description {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Description", description)?;
        }
        if let Some(ref operating_regions) = self.operating_regions {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "OperatingRegions", operating_regions)?;
        }
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for IPAMResourceDiscoveryProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<IPAMResourceDiscoveryProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = IPAMResourceDiscoveryProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type IPAMResourceDiscoveryProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut description: Option<::Value<String>> = None;
                let mut operating_regions: Option<::ValueList<self::ipam_resource_discovery::IpamOperatingRegion>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "Description" => {
                            description = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "OperatingRegions" => {
                            operating_regions = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(IPAMResourceDiscoveryProperties {
                    description: description,
                    operating_regions: operating_regions,
                    tags: tags,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for IPAMResourceDiscovery {
    type Properties = IPAMResourceDiscoveryProperties;
    const TYPE: &'static str = "AWS::EC2::IPAMResourceDiscovery";
    fn properties(&self) -> &IPAMResourceDiscoveryProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut IPAMResourceDiscoveryProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for IPAMResourceDiscovery {}

impl From<IPAMResourceDiscoveryProperties> for IPAMResourceDiscovery {
    fn from(properties: IPAMResourceDiscoveryProperties) -> IPAMResourceDiscovery {
        IPAMResourceDiscovery { properties }
    }
}

/// The [`AWS::EC2::IPAMResourceDiscoveryAssociation`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscoveryassociation.html) resource type.
#[derive(Debug, Default)]
pub struct IPAMResourceDiscoveryAssociation {
    properties: IPAMResourceDiscoveryAssociationProperties
}

/// Properties for the `IPAMResourceDiscoveryAssociation` resource.
#[derive(Debug, Default)]
pub struct IPAMResourceDiscoveryAssociationProperties {
    /// Property [`IpamId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscoveryassociation.html#cfn-ec2-ipamresourcediscoveryassociation-ipamid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub ipam_id: ::Value<String>,
    /// Property [`IpamResourceDiscoveryId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscoveryassociation.html#cfn-ec2-ipamresourcediscoveryassociation-ipamresourcediscoveryid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub ipam_resource_discovery_id: ::Value<String>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamresourcediscoveryassociation.html#cfn-ec2-ipamresourcediscoveryassociation-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
}

impl ::serde::Serialize for IPAMResourceDiscoveryAssociationProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "IpamId", &self.ipam_id)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "IpamResourceDiscoveryId", &self.ipam_resource_discovery_id)?;
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for IPAMResourceDiscoveryAssociationProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<IPAMResourceDiscoveryAssociationProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = IPAMResourceDiscoveryAssociationProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type IPAMResourceDiscoveryAssociationProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut ipam_id: Option<::Value<String>> = None;
                let mut ipam_resource_discovery_id: Option<::Value<String>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "IpamId" => {
                            ipam_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "IpamResourceDiscoveryId" => {
                            ipam_resource_discovery_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(IPAMResourceDiscoveryAssociationProperties {
                    ipam_id: ipam_id.ok_or(::serde::de::Error::missing_field("IpamId"))?,
                    ipam_resource_discovery_id: ipam_resource_discovery_id.ok_or(::serde::de::Error::missing_field("IpamResourceDiscoveryId"))?,
                    tags: tags,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for IPAMResourceDiscoveryAssociation {
    type Properties = IPAMResourceDiscoveryAssociationProperties;
    const TYPE: &'static str = "AWS::EC2::IPAMResourceDiscoveryAssociation";
    fn properties(&self) -> &IPAMResourceDiscoveryAssociationProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut IPAMResourceDiscoveryAssociationProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for IPAMResourceDiscoveryAssociation {}

impl From<IPAMResourceDiscoveryAssociationProperties> for IPAMResourceDiscoveryAssociation {
    fn from(properties: IPAMResourceDiscoveryAssociationProperties) -> IPAMResourceDiscoveryAssociation {
        IPAMResourceDiscoveryAssociation { properties }
    }
}

/// The [`AWS::EC2::IPAMScope`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html) resource type.
#[derive(Debug, Default)]
pub struct IPAMScope {
    properties: IPAMScopeProperties
}

/// Properties for the `IPAMScope` resource.
#[derive(Debug, Default)]
pub struct IPAMScopeProperties {
    /// Property [`Description`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html#cfn-ec2-ipamscope-description).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub description: Option<::Value<String>>,
    /// Property [`IpamId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html#cfn-ec2-ipamscope-ipamid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub ipam_id: ::Value<String>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html#cfn-ec2-ipamscope-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
}

impl ::serde::Serialize for IPAMScopeProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref description) = self.description {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Description", description)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "IpamId", &self.ipam_id)?;
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for IPAMScopeProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<IPAMScopeProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = IPAMScopeProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type IPAMScopeProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut description: Option<::Value<String>> = None;
                let mut ipam_id: Option<::Value<String>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "Description" => {
                            description = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "IpamId" => {
                            ipam_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(IPAMScopeProperties {
                    description: description,
                    ipam_id: ipam_id.ok_or(::serde::de::Error::missing_field("IpamId"))?,
                    tags: tags,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for IPAMScope {
    type Properties = IPAMScopeProperties;
    const TYPE: &'static str = "AWS::EC2::IPAMScope";
    fn properties(&self) -> &IPAMScopeProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut IPAMScopeProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for IPAMScope {}

impl From<IPAMScopeProperties> for IPAMScope {
    fn from(properties: IPAMScopeProperties) -> IPAMScope {
        IPAMScope { properties }
    }
}

/// The [`AWS::EC2::Instance`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) resource type.
#[derive(Debug, Default)]
pub struct Instance {
    properties: InstanceProperties
}

/// Properties for the `Instance` resource.
#[derive(Debug, Default)]
pub struct InstanceProperties {
    /// Property [`AdditionalInfo`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-additionalinfo).
    ///
    /// Update type: _Conditional_.
    /// Conditional updates can be mutable or immutable, depending on, for example, which other properties you updated.
    /// For more information, see the relevant resource type documentation.
    pub additional_info: Option<::Value<String>>,
    /// Property [`Affinity`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-affinity).
    ///
    /// Update type: _Conditional_.
    /// Conditional updates can be mutable or immutable, depending on, for example, which other properties you updated.
    /// For more information, see the relevant resource type documentation.
    pub affinity: Option<::Value<String>>,
    /// Property [`AvailabilityZone`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-availabilityzone).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub availability_zone: Option<::Value<String>>,
    /// Property [`BlockDeviceMappings`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-blockdevicemappings).
    ///
    /// Update type: _Conditional_.
    /// Conditional updates can be mutable or immutable, depending on, for example, which other properties you updated.
    /// For more information, see the relevant resource type documentation.
    pub block_device_mappings: Option<::ValueList<self::instance::BlockDeviceMapping>>,
    /// Property [`CpuOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-cpuoptions).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub cpu_options: Option<::Value<self::instance::CpuOptions>>,
    /// Property [`CreditSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-creditspecification).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub credit_specification: Option<::Value<self::instance::CreditSpecification>>,
    /// Property [`DisableApiTermination`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-disableapitermination).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub disable_api_termination: Option<::Value<bool>>,
    /// Property [`EbsOptimized`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-ebsoptimized).
    ///
    /// Update type: _Conditional_.
    /// Conditional updates can be mutable or immutable, depending on, for example, which other properties you updated.
    /// For more information, see the relevant resource type documentation.
    pub ebs_optimized: Option<::Value<bool>>,
    /// Property [`ElasticGpuSpecifications`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-elasticgpuspecifications).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub elastic_gpu_specifications: Option<::ValueList<self::instance::ElasticGpuSpecification>>,
    /// Property [`ElasticInferenceAccelerators`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-elasticinferenceaccelerators).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub elastic_inference_accelerators: Option<::ValueList<self::instance::ElasticInferenceAccelerator>>,
    /// Property [`EnclaveOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-enclaveoptions).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub enclave_options: Option<::Value<self::instance::EnclaveOptions>>,
    /// Property [`HibernationOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-hibernationoptions).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub hibernation_options: Option<::Value<self::instance::HibernationOptions>>,
    /// Property [`HostId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-hostid).
    ///
    /// Update type: _Conditional_.
    /// Conditional updates can be mutable or immutable, depending on, for example, which other properties you updated.
    /// For more information, see the relevant resource type documentation.
    pub host_id: Option<::Value<String>>,
    /// Property [`HostResourceGroupArn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-hostresourcegrouparn).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub host_resource_group_arn: Option<::Value<String>>,
    /// Property [`IamInstanceProfile`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-iaminstanceprofile).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub iam_instance_profile: Option<::Value<String>>,
    /// Property [`ImageId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-imageid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub image_id: Option<::Value<String>>,
    /// Property [`InstanceInitiatedShutdownBehavior`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-instanceinitiatedshutdownbehavior).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub instance_initiated_shutdown_behavior: Option<::Value<String>>,
    /// Property [`InstanceType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-instancetype).
    ///
    /// Update type: _Conditional_.
    /// Conditional updates can be mutable or immutable, depending on, for example, which other properties you updated.
    /// For more information, see the relevant resource type documentation.
    pub instance_type: Option<::Value<String>>,
    /// Property [`Ipv6AddressCount`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-ipv6addresscount).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub ipv6_address_count: Option<::Value<u32>>,
    /// Property [`Ipv6Addresses`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-ipv6addresses).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub ipv6_addresses: Option<::ValueList<self::instance::InstanceIpv6Address>>,
    /// Property [`KernelId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-kernelid).
    ///
    /// Update type: _Conditional_.
    /// Conditional updates can be mutable or immutable, depending on, for example, which other properties you updated.
    /// For more information, see the relevant resource type documentation.
    pub kernel_id: Option<::Value<String>>,
    /// Property [`KeyName`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-keyname).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub key_name: Option<::Value<String>>,
    /// Property [`LaunchTemplate`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-launchtemplate).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub launch_template: Option<::Value<self::instance::LaunchTemplateSpecification>>,
    /// Property [`LicenseSpecifications`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-licensespecifications).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub license_specifications: Option<::ValueList<self::instance::LicenseSpecification>>,
    /// Property [`Monitoring`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-monitoring).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub monitoring: Option<::Value<bool>>,
    /// Property [`NetworkInterfaces`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-networkinterfaces).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub network_interfaces: Option<::ValueList<self::instance::NetworkInterface>>,
    /// Property [`PlacementGroupName`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-placementgroupname).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub placement_group_name: Option<::Value<String>>,
    /// Property [`PrivateDnsNameOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-privatednsnameoptions).
    ///
    /// Update type: _Conditional_.
    /// Conditional updates can be mutable or immutable, depending on, for example, which other properties you updated.
    /// For more information, see the relevant resource type documentation.
    pub private_dns_name_options: Option<::Value<self::instance::PrivateDnsNameOptions>>,
    /// Property [`PrivateIpAddress`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-privateipaddress).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub private_ip_address: Option<::Value<String>>,
    /// Property [`PropagateTagsToVolumeOnCreation`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-propagatetagstovolumeoncreation).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub propagate_tags_to_volume_on_creation: Option<::Value<bool>>,
    /// Property [`RamdiskId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-ramdiskid).
    ///
    /// Update type: _Conditional_.
    /// Conditional updates can be mutable or immutable, depending on, for example, which other properties you updated.
    /// For more information, see the relevant resource type documentation.
    pub ramdisk_id: Option<::Value<String>>,
    /// Property [`SecurityGroupIds`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-securitygroupids).
    ///
    /// Update type: _Conditional_.
    /// Conditional updates can be mutable or immutable, depending on, for example, which other properties you updated.
    /// For more information, see the relevant resource type documentation.
    pub security_group_ids: Option<::ValueList<String>>,
    /// Property [`SecurityGroups`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-securitygroups).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub security_groups: Option<::ValueList<String>>,
    /// Property [`SourceDestCheck`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-sourcedestcheck).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub source_dest_check: Option<::Value<bool>>,
    /// Property [`SsmAssociations`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-ssmassociations).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub ssm_associations: Option<::ValueList<self::instance::SsmAssociation>>,
    /// Property [`SubnetId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-subnetid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub subnet_id: Option<::Value<String>>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
    /// Property [`Tenancy`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-tenancy).
    ///
    /// Update type: _Conditional_.
    /// Conditional updates can be mutable or immutable, depending on, for example, which other properties you updated.
    /// For more information, see the relevant resource type documentation.
    pub tenancy: Option<::Value<String>>,
    /// Property [`UserData`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-userdata).
    ///
    /// Update type: _Conditional_.
    /// Conditional updates can be mutable or immutable, depending on, for example, which other properties you updated.
    /// For more information, see the relevant resource type documentation.
    pub user_data: Option<::Value<String>>,
    /// Property [`Volumes`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-volumes).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub volumes: Option<::ValueList<self::instance::Volume>>,
}

impl ::serde::Serialize for InstanceProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref additional_info) = self.additional_info {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "AdditionalInfo", additional_info)?;
        }
        if let Some(ref affinity) = self.affinity {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Affinity", affinity)?;
        }
        if let Some(ref availability_zone) = self.availability_zone {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "AvailabilityZone", availability_zone)?;
        }
        if let Some(ref block_device_mappings) = self.block_device_mappings {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "BlockDeviceMappings", block_device_mappings)?;
        }
        if let Some(ref cpu_options) = self.cpu_options {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "CpuOptions", cpu_options)?;
        }
        if let Some(ref credit_specification) = self.credit_specification {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "CreditSpecification", credit_specification)?;
        }
        if let Some(ref disable_api_termination) = self.disable_api_termination {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "DisableApiTermination", disable_api_termination)?;
        }
        if let Some(ref ebs_optimized) = self.ebs_optimized {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "EbsOptimized", ebs_optimized)?;
        }
        if let Some(ref elastic_gpu_specifications) = self.elastic_gpu_specifications {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "ElasticGpuSpecifications", elastic_gpu_specifications)?;
        }
        if let Some(ref elastic_inference_accelerators) = self.elastic_inference_accelerators {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "ElasticInferenceAccelerators", elastic_inference_accelerators)?;
        }
        if let Some(ref enclave_options) = self.enclave_options {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "EnclaveOptions", enclave_options)?;
        }
        if let Some(ref hibernation_options) = self.hibernation_options {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "HibernationOptions", hibernation_options)?;
        }
        if let Some(ref host_id) = self.host_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "HostId", host_id)?;
        }
        if let Some(ref host_resource_group_arn) = self.host_resource_group_arn {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "HostResourceGroupArn", host_resource_group_arn)?;
        }
        if let Some(ref iam_instance_profile) = self.iam_instance_profile {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "IamInstanceProfile", iam_instance_profile)?;
        }
        if let Some(ref image_id) = self.image_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "ImageId", image_id)?;
        }
        if let Some(ref instance_initiated_shutdown_behavior) = self.instance_initiated_shutdown_behavior {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstanceInitiatedShutdownBehavior", instance_initiated_shutdown_behavior)?;
        }
        if let Some(ref instance_type) = self.instance_type {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstanceType", instance_type)?;
        }
        if let Some(ref ipv6_address_count) = self.ipv6_address_count {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6AddressCount", ipv6_address_count)?;
        }
        if let Some(ref ipv6_addresses) = self.ipv6_addresses {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6Addresses", ipv6_addresses)?;
        }
        if let Some(ref kernel_id) = self.kernel_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "KernelId", kernel_id)?;
        }
        if let Some(ref key_name) = self.key_name {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "KeyName", key_name)?;
        }
        if let Some(ref launch_template) = self.launch_template {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "LaunchTemplate", launch_template)?;
        }
        if let Some(ref license_specifications) = self.license_specifications {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "LicenseSpecifications", license_specifications)?;
        }
        if let Some(ref monitoring) = self.monitoring {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Monitoring", monitoring)?;
        }
        if let Some(ref network_interfaces) = self.network_interfaces {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetworkInterfaces", network_interfaces)?;
        }
        if let Some(ref placement_group_name) = self.placement_group_name {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "PlacementGroupName", placement_group_name)?;
        }
        if let Some(ref private_dns_name_options) = self.private_dns_name_options {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "PrivateDnsNameOptions", private_dns_name_options)?;
        }
        if let Some(ref private_ip_address) = self.private_ip_address {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "PrivateIpAddress", private_ip_address)?;
        }
        if let Some(ref propagate_tags_to_volume_on_creation) = self.propagate_tags_to_volume_on_creation {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "PropagateTagsToVolumeOnCreation", propagate_tags_to_volume_on_creation)?;
        }
        if let Some(ref ramdisk_id) = self.ramdisk_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "RamdiskId", ramdisk_id)?;
        }
        if let Some(ref security_group_ids) = self.security_group_ids {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SecurityGroupIds", security_group_ids)?;
        }
        if let Some(ref security_groups) = self.security_groups {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SecurityGroups", security_groups)?;
        }
        if let Some(ref source_dest_check) = self.source_dest_check {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SourceDestCheck", source_dest_check)?;
        }
        if let Some(ref ssm_associations) = self.ssm_associations {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SsmAssociations", ssm_associations)?;
        }
        if let Some(ref subnet_id) = self.subnet_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SubnetId", subnet_id)?;
        }
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        if let Some(ref tenancy) = self.tenancy {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tenancy", tenancy)?;
        }
        if let Some(ref user_data) = self.user_data {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "UserData", user_data)?;
        }
        if let Some(ref volumes) = self.volumes {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Volumes", volumes)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for InstanceProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<InstanceProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = InstanceProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type InstanceProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut additional_info: Option<::Value<String>> = None;
                let mut affinity: Option<::Value<String>> = None;
                let mut availability_zone: Option<::Value<String>> = None;
                let mut block_device_mappings: Option<::ValueList<self::instance::BlockDeviceMapping>> = None;
                let mut cpu_options: Option<::Value<self::instance::CpuOptions>> = None;
                let mut credit_specification: Option<::Value<self::instance::CreditSpecification>> = None;
                let mut disable_api_termination: Option<::Value<bool>> = None;
                let mut ebs_optimized: Option<::Value<bool>> = None;
                let mut elastic_gpu_specifications: Option<::ValueList<self::instance::ElasticGpuSpecification>> = None;
                let mut elastic_inference_accelerators: Option<::ValueList<self::instance::ElasticInferenceAccelerator>> = None;
                let mut enclave_options: Option<::Value<self::instance::EnclaveOptions>> = None;
                let mut hibernation_options: Option<::Value<self::instance::HibernationOptions>> = None;
                let mut host_id: Option<::Value<String>> = None;
                let mut host_resource_group_arn: Option<::Value<String>> = None;
                let mut iam_instance_profile: Option<::Value<String>> = None;
                let mut image_id: Option<::Value<String>> = None;
                let mut instance_initiated_shutdown_behavior: Option<::Value<String>> = None;
                let mut instance_type: Option<::Value<String>> = None;
                let mut ipv6_address_count: Option<::Value<u32>> = None;
                let mut ipv6_addresses: Option<::ValueList<self::instance::InstanceIpv6Address>> = None;
                let mut kernel_id: Option<::Value<String>> = None;
                let mut key_name: Option<::Value<String>> = None;
                let mut launch_template: Option<::Value<self::instance::LaunchTemplateSpecification>> = None;
                let mut license_specifications: Option<::ValueList<self::instance::LicenseSpecification>> = None;
                let mut monitoring: Option<::Value<bool>> = None;
                let mut network_interfaces: Option<::ValueList<self::instance::NetworkInterface>> = None;
                let mut placement_group_name: Option<::Value<String>> = None;
                let mut private_dns_name_options: Option<::Value<self::instance::PrivateDnsNameOptions>> = None;
                let mut private_ip_address: Option<::Value<String>> = None;
                let mut propagate_tags_to_volume_on_creation: Option<::Value<bool>> = None;
                let mut ramdisk_id: Option<::Value<String>> = None;
                let mut security_group_ids: Option<::ValueList<String>> = None;
                let mut security_groups: Option<::ValueList<String>> = None;
                let mut source_dest_check: Option<::Value<bool>> = None;
                let mut ssm_associations: Option<::ValueList<self::instance::SsmAssociation>> = None;
                let mut subnet_id: Option<::Value<String>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;
                let mut tenancy: Option<::Value<String>> = None;
                let mut user_data: Option<::Value<String>> = None;
                let mut volumes: Option<::ValueList<self::instance::Volume>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "AdditionalInfo" => {
                            additional_info = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Affinity" => {
                            affinity = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "AvailabilityZone" => {
                            availability_zone = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "BlockDeviceMappings" => {
                            block_device_mappings = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "CpuOptions" => {
                            cpu_options = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "CreditSpecification" => {
                            credit_specification = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "DisableApiTermination" => {
                            disable_api_termination = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "EbsOptimized" => {
                            ebs_optimized = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "ElasticGpuSpecifications" => {
                            elastic_gpu_specifications = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "ElasticInferenceAccelerators" => {
                            elastic_inference_accelerators = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "EnclaveOptions" => {
                            enclave_options = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "HibernationOptions" => {
                            hibernation_options = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "HostId" => {
                            host_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "HostResourceGroupArn" => {
                            host_resource_group_arn = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "IamInstanceProfile" => {
                            iam_instance_profile = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "ImageId" => {
                            image_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "InstanceInitiatedShutdownBehavior" => {
                            instance_initiated_shutdown_behavior = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "InstanceType" => {
                            instance_type = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Ipv6AddressCount" => {
                            ipv6_address_count = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Ipv6Addresses" => {
                            ipv6_addresses = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "KernelId" => {
                            kernel_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "KeyName" => {
                            key_name = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "LaunchTemplate" => {
                            launch_template = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "LicenseSpecifications" => {
                            license_specifications = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Monitoring" => {
                            monitoring = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "NetworkInterfaces" => {
                            network_interfaces = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "PlacementGroupName" => {
                            placement_group_name = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "PrivateDnsNameOptions" => {
                            private_dns_name_options = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "PrivateIpAddress" => {
                            private_ip_address = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "PropagateTagsToVolumeOnCreation" => {
                            propagate_tags_to_volume_on_creation = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "RamdiskId" => {
                            ramdisk_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SecurityGroupIds" => {
                            security_group_ids = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SecurityGroups" => {
                            security_groups = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SourceDestCheck" => {
                            source_dest_check = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SsmAssociations" => {
                            ssm_associations = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SubnetId" => {
                            subnet_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tenancy" => {
                            tenancy = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "UserData" => {
                            user_data = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Volumes" => {
                            volumes = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(InstanceProperties {
                    additional_info: additional_info,
                    affinity: affinity,
                    availability_zone: availability_zone,
                    block_device_mappings: block_device_mappings,
                    cpu_options: cpu_options,
                    credit_specification: credit_specification,
                    disable_api_termination: disable_api_termination,
                    ebs_optimized: ebs_optimized,
                    elastic_gpu_specifications: elastic_gpu_specifications,
                    elastic_inference_accelerators: elastic_inference_accelerators,
                    enclave_options: enclave_options,
                    hibernation_options: hibernation_options,
                    host_id: host_id,
                    host_resource_group_arn: host_resource_group_arn,
                    iam_instance_profile: iam_instance_profile,
                    image_id: image_id,
                    instance_initiated_shutdown_behavior: instance_initiated_shutdown_behavior,
                    instance_type: instance_type,
                    ipv6_address_count: ipv6_address_count,
                    ipv6_addresses: ipv6_addresses,
                    kernel_id: kernel_id,
                    key_name: key_name,
                    launch_template: launch_template,
                    license_specifications: license_specifications,
                    monitoring: monitoring,
                    network_interfaces: network_interfaces,
                    placement_group_name: placement_group_name,
                    private_dns_name_options: private_dns_name_options,
                    private_ip_address: private_ip_address,
                    propagate_tags_to_volume_on_creation: propagate_tags_to_volume_on_creation,
                    ramdisk_id: ramdisk_id,
                    security_group_ids: security_group_ids,
                    security_groups: security_groups,
                    source_dest_check: source_dest_check,
                    ssm_associations: ssm_associations,
                    subnet_id: subnet_id,
                    tags: tags,
                    tenancy: tenancy,
                    user_data: user_data,
                    volumes: volumes,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for Instance {
    type Properties = InstanceProperties;
    const TYPE: &'static str = "AWS::EC2::Instance";
    fn properties(&self) -> &InstanceProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut InstanceProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for Instance {}

impl From<InstanceProperties> for Instance {
    fn from(properties: InstanceProperties) -> Instance {
        Instance { properties }
    }
}

/// The [`AWS::EC2::InstanceConnectEndpoint`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instanceconnectendpoint.html) resource type.
#[derive(Debug, Default)]
pub struct InstanceConnectEndpoint {
    properties: InstanceConnectEndpointProperties
}

/// Properties for the `InstanceConnectEndpoint` resource.
#[derive(Debug, Default)]
pub struct InstanceConnectEndpointProperties {
    /// Property [`ClientToken`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instanceconnectendpoint.html#cfn-ec2-instanceconnectendpoint-clienttoken).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub client_token: Option<::Value<String>>,
    /// Property [`PreserveClientIp`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instanceconnectendpoint.html#cfn-ec2-instanceconnectendpoint-preserveclientip).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub preserve_client_ip: Option<::Value<bool>>,
    /// Property [`SecurityGroupIds`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instanceconnectendpoint.html#cfn-ec2-instanceconnectendpoint-securitygroupids).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub security_group_ids: Option<::ValueList<String>>,
    /// Property [`SubnetId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instanceconnectendpoint.html#cfn-ec2-instanceconnectendpoint-subnetid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub subnet_id: ::Value<String>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instanceconnectendpoint.html#cfn-ec2-instanceconnectendpoint-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
}

impl ::serde::Serialize for InstanceConnectEndpointProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref client_token) = self.client_token {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "ClientToken", client_token)?;
        }
        if let Some(ref preserve_client_ip) = self.preserve_client_ip {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "PreserveClientIp", preserve_client_ip)?;
        }
        if let Some(ref security_group_ids) = self.security_group_ids {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SecurityGroupIds", security_group_ids)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "SubnetId", &self.subnet_id)?;
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for InstanceConnectEndpointProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<InstanceConnectEndpointProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = InstanceConnectEndpointProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type InstanceConnectEndpointProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut client_token: Option<::Value<String>> = None;
                let mut preserve_client_ip: Option<::Value<bool>> = None;
                let mut security_group_ids: Option<::ValueList<String>> = None;
                let mut subnet_id: Option<::Value<String>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "ClientToken" => {
                            client_token = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "PreserveClientIp" => {
                            preserve_client_ip = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SecurityGroupIds" => {
                            security_group_ids = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SubnetId" => {
                            subnet_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(InstanceConnectEndpointProperties {
                    client_token: client_token,
                    preserve_client_ip: preserve_client_ip,
                    security_group_ids: security_group_ids,
                    subnet_id: subnet_id.ok_or(::serde::de::Error::missing_field("SubnetId"))?,
                    tags: tags,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for InstanceConnectEndpoint {
    type Properties = InstanceConnectEndpointProperties;
    const TYPE: &'static str = "AWS::EC2::InstanceConnectEndpoint";
    fn properties(&self) -> &InstanceConnectEndpointProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut InstanceConnectEndpointProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for InstanceConnectEndpoint {}

impl From<InstanceConnectEndpointProperties> for InstanceConnectEndpoint {
    fn from(properties: InstanceConnectEndpointProperties) -> InstanceConnectEndpoint {
        InstanceConnectEndpoint { properties }
    }
}

/// The [`AWS::EC2::InternetGateway`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-internetgateway.html) resource type.
#[derive(Debug, Default)]
pub struct InternetGateway {
    properties: InternetGatewayProperties
}

/// Properties for the `InternetGateway` resource.
#[derive(Debug, Default)]
pub struct InternetGatewayProperties {
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-internetgateway.html#cfn-ec2-internetgateway-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
}

impl ::serde::Serialize for InternetGatewayProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for InternetGatewayProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<InternetGatewayProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = InternetGatewayProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type InternetGatewayProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut tags: Option<::ValueList<::Tag>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(InternetGatewayProperties {
                    tags: tags,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for InternetGateway {
    type Properties = InternetGatewayProperties;
    const TYPE: &'static str = "AWS::EC2::InternetGateway";
    fn properties(&self) -> &InternetGatewayProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut InternetGatewayProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for InternetGateway {}

impl From<InternetGatewayProperties> for InternetGateway {
    fn from(properties: InternetGatewayProperties) -> InternetGateway {
        InternetGateway { properties }
    }
}

/// The [`AWS::EC2::KeyPair`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html) resource type.
#[derive(Debug, Default)]
pub struct KeyPair {
    properties: KeyPairProperties
}

/// Properties for the `KeyPair` resource.
#[derive(Debug, Default)]
pub struct KeyPairProperties {
    /// Property [`KeyFormat`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html#cfn-ec2-keypair-keyformat).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub key_format: Option<::Value<String>>,
    /// Property [`KeyName`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html#cfn-ec2-keypair-keyname).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub key_name: ::Value<String>,
    /// Property [`KeyType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html#cfn-ec2-keypair-keytype).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub key_type: Option<::Value<String>>,
    /// Property [`PublicKeyMaterial`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html#cfn-ec2-keypair-publickeymaterial).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub public_key_material: Option<::Value<String>>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-keypair.html#cfn-ec2-keypair-tags).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
}

impl ::serde::Serialize for KeyPairProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref key_format) = self.key_format {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "KeyFormat", key_format)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "KeyName", &self.key_name)?;
        if let Some(ref key_type) = self.key_type {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "KeyType", key_type)?;
        }
        if let Some(ref public_key_material) = self.public_key_material {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "PublicKeyMaterial", public_key_material)?;
        }
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for KeyPairProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<KeyPairProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = KeyPairProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type KeyPairProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut key_format: Option<::Value<String>> = None;
                let mut key_name: Option<::Value<String>> = None;
                let mut key_type: Option<::Value<String>> = None;
                let mut public_key_material: Option<::Value<String>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "KeyFormat" => {
                            key_format = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "KeyName" => {
                            key_name = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "KeyType" => {
                            key_type = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "PublicKeyMaterial" => {
                            public_key_material = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(KeyPairProperties {
                    key_format: key_format,
                    key_name: key_name.ok_or(::serde::de::Error::missing_field("KeyName"))?,
                    key_type: key_type,
                    public_key_material: public_key_material,
                    tags: tags,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for KeyPair {
    type Properties = KeyPairProperties;
    const TYPE: &'static str = "AWS::EC2::KeyPair";
    fn properties(&self) -> &KeyPairProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut KeyPairProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for KeyPair {}

impl From<KeyPairProperties> for KeyPair {
    fn from(properties: KeyPairProperties) -> KeyPair {
        KeyPair { properties }
    }
}

/// The [`AWS::EC2::LaunchTemplate`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html) resource type.
#[derive(Debug, Default)]
pub struct LaunchTemplate {
    properties: LaunchTemplateProperties
}

/// Properties for the `LaunchTemplate` resource.
#[derive(Debug, Default)]
pub struct LaunchTemplateProperties {
    /// Property [`LaunchTemplateData`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-launchtemplatedata).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub launch_template_data: ::Value<self::launch_template::LaunchTemplateData>,
    /// Property [`LaunchTemplateName`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-launchtemplatename).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub launch_template_name: Option<::Value<String>>,
    /// Property [`TagSpecifications`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-tagspecifications).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tag_specifications: Option<::ValueList<self::launch_template::LaunchTemplateTagSpecification>>,
    /// Property [`VersionDescription`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-versiondescription).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub version_description: Option<::Value<String>>,
}

impl ::serde::Serialize for LaunchTemplateProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "LaunchTemplateData", &self.launch_template_data)?;
        if let Some(ref launch_template_name) = self.launch_template_name {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "LaunchTemplateName", launch_template_name)?;
        }
        if let Some(ref tag_specifications) = self.tag_specifications {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "TagSpecifications", tag_specifications)?;
        }
        if let Some(ref version_description) = self.version_description {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "VersionDescription", version_description)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for LaunchTemplateProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<LaunchTemplateProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = LaunchTemplateProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type LaunchTemplateProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut launch_template_data: Option<::Value<self::launch_template::LaunchTemplateData>> = None;
                let mut launch_template_name: Option<::Value<String>> = None;
                let mut tag_specifications: Option<::ValueList<self::launch_template::LaunchTemplateTagSpecification>> = None;
                let mut version_description: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "LaunchTemplateData" => {
                            launch_template_data = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "LaunchTemplateName" => {
                            launch_template_name = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TagSpecifications" => {
                            tag_specifications = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "VersionDescription" => {
                            version_description = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(LaunchTemplateProperties {
                    launch_template_data: launch_template_data.ok_or(::serde::de::Error::missing_field("LaunchTemplateData"))?,
                    launch_template_name: launch_template_name,
                    tag_specifications: tag_specifications,
                    version_description: version_description,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for LaunchTemplate {
    type Properties = LaunchTemplateProperties;
    const TYPE: &'static str = "AWS::EC2::LaunchTemplate";
    fn properties(&self) -> &LaunchTemplateProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut LaunchTemplateProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for LaunchTemplate {}

impl From<LaunchTemplateProperties> for LaunchTemplate {
    fn from(properties: LaunchTemplateProperties) -> LaunchTemplate {
        LaunchTemplate { properties }
    }
}

/// The [`AWS::EC2::LocalGatewayRoute`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html) resource type.
#[derive(Debug, Default)]
pub struct LocalGatewayRoute {
    properties: LocalGatewayRouteProperties
}

/// Properties for the `LocalGatewayRoute` resource.
#[derive(Debug, Default)]
pub struct LocalGatewayRouteProperties {
    /// Property [`DestinationCidrBlock`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html#cfn-ec2-localgatewayroute-destinationcidrblock).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub destination_cidr_block: ::Value<String>,
    /// Property [`LocalGatewayRouteTableId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html#cfn-ec2-localgatewayroute-localgatewayroutetableid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub local_gateway_route_table_id: ::Value<String>,
    /// Property [`LocalGatewayVirtualInterfaceGroupId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html#cfn-ec2-localgatewayroute-localgatewayvirtualinterfacegroupid).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub local_gateway_virtual_interface_group_id: Option<::Value<String>>,
    /// Property [`NetworkInterfaceId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html#cfn-ec2-localgatewayroute-networkinterfaceid).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub network_interface_id: Option<::Value<String>>,
}

impl ::serde::Serialize for LocalGatewayRouteProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "DestinationCidrBlock", &self.destination_cidr_block)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "LocalGatewayRouteTableId", &self.local_gateway_route_table_id)?;
        if let Some(ref local_gateway_virtual_interface_group_id) = self.local_gateway_virtual_interface_group_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "LocalGatewayVirtualInterfaceGroupId", local_gateway_virtual_interface_group_id)?;
        }
        if let Some(ref network_interface_id) = self.network_interface_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetworkInterfaceId", network_interface_id)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for LocalGatewayRouteProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<LocalGatewayRouteProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = LocalGatewayRouteProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type LocalGatewayRouteProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut destination_cidr_block: Option<::Value<String>> = None;
                let mut local_gateway_route_table_id: Option<::Value<String>> = None;
                let mut local_gateway_virtual_interface_group_id: Option<::Value<String>> = None;
                let mut network_interface_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "DestinationCidrBlock" => {
                            destination_cidr_block = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "LocalGatewayRouteTableId" => {
                            local_gateway_route_table_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "LocalGatewayVirtualInterfaceGroupId" => {
                            local_gateway_virtual_interface_group_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "NetworkInterfaceId" => {
                            network_interface_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(LocalGatewayRouteProperties {
                    destination_cidr_block: destination_cidr_block.ok_or(::serde::de::Error::missing_field("DestinationCidrBlock"))?,
                    local_gateway_route_table_id: local_gateway_route_table_id.ok_or(::serde::de::Error::missing_field("LocalGatewayRouteTableId"))?,
                    local_gateway_virtual_interface_group_id: local_gateway_virtual_interface_group_id,
                    network_interface_id: network_interface_id,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for LocalGatewayRoute {
    type Properties = LocalGatewayRouteProperties;
    const TYPE: &'static str = "AWS::EC2::LocalGatewayRoute";
    fn properties(&self) -> &LocalGatewayRouteProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut LocalGatewayRouteProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for LocalGatewayRoute {}

impl From<LocalGatewayRouteProperties> for LocalGatewayRoute {
    fn from(properties: LocalGatewayRouteProperties) -> LocalGatewayRoute {
        LocalGatewayRoute { properties }
    }
}

/// The [`AWS::EC2::LocalGatewayRouteTable`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetable.html) resource type.
#[derive(Debug, Default)]
pub struct LocalGatewayRouteTable {
    properties: LocalGatewayRouteTableProperties
}

/// Properties for the `LocalGatewayRouteTable` resource.
#[derive(Debug, Default)]
pub struct LocalGatewayRouteTableProperties {
    /// Property [`LocalGatewayId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetable.html#cfn-ec2-localgatewayroutetable-localgatewayid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub local_gateway_id: ::Value<String>,
    /// Property [`Mode`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetable.html#cfn-ec2-localgatewayroutetable-mode).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub mode: Option<::Value<String>>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetable.html#cfn-ec2-localgatewayroutetable-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
}

impl ::serde::Serialize for LocalGatewayRouteTableProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "LocalGatewayId", &self.local_gateway_id)?;
        if let Some(ref mode) = self.mode {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Mode", mode)?;
        }
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for LocalGatewayRouteTableProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<LocalGatewayRouteTableProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = LocalGatewayRouteTableProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type LocalGatewayRouteTableProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut local_gateway_id: Option<::Value<String>> = None;
                let mut mode: Option<::Value<String>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "LocalGatewayId" => {
                            local_gateway_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Mode" => {
                            mode = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(LocalGatewayRouteTableProperties {
                    local_gateway_id: local_gateway_id.ok_or(::serde::de::Error::missing_field("LocalGatewayId"))?,
                    mode: mode,
                    tags: tags,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for LocalGatewayRouteTable {
    type Properties = LocalGatewayRouteTableProperties;
    const TYPE: &'static str = "AWS::EC2::LocalGatewayRouteTable";
    fn properties(&self) -> &LocalGatewayRouteTableProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut LocalGatewayRouteTableProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for LocalGatewayRouteTable {}

impl From<LocalGatewayRouteTableProperties> for LocalGatewayRouteTable {
    fn from(properties: LocalGatewayRouteTableProperties) -> LocalGatewayRouteTable {
        LocalGatewayRouteTable { properties }
    }
}

/// The [`AWS::EC2::LocalGatewayRouteTableVPCAssociation`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html) resource type.
#[derive(Debug, Default)]
pub struct LocalGatewayRouteTableVPCAssociation {
    properties: LocalGatewayRouteTableVPCAssociationProperties
}

/// Properties for the `LocalGatewayRouteTableVPCAssociation` resource.
#[derive(Debug, Default)]
pub struct LocalGatewayRouteTableVPCAssociationProperties {
    /// Property [`LocalGatewayRouteTableId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html#cfn-ec2-localgatewayroutetablevpcassociation-localgatewayroutetableid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub local_gateway_route_table_id: ::Value<String>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html#cfn-ec2-localgatewayroutetablevpcassociation-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
    /// Property [`VpcId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html#cfn-ec2-localgatewayroutetablevpcassociation-vpcid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub vpc_id: ::Value<String>,
}

impl ::serde::Serialize for LocalGatewayRouteTableVPCAssociationProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "LocalGatewayRouteTableId", &self.local_gateway_route_table_id)?;
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "VpcId", &self.vpc_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for LocalGatewayRouteTableVPCAssociationProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<LocalGatewayRouteTableVPCAssociationProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = LocalGatewayRouteTableVPCAssociationProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type LocalGatewayRouteTableVPCAssociationProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut local_gateway_route_table_id: Option<::Value<String>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;
                let mut vpc_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "LocalGatewayRouteTableId" => {
                            local_gateway_route_table_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "VpcId" => {
                            vpc_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(LocalGatewayRouteTableVPCAssociationProperties {
                    local_gateway_route_table_id: local_gateway_route_table_id.ok_or(::serde::de::Error::missing_field("LocalGatewayRouteTableId"))?,
                    tags: tags,
                    vpc_id: vpc_id.ok_or(::serde::de::Error::missing_field("VpcId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for LocalGatewayRouteTableVPCAssociation {
    type Properties = LocalGatewayRouteTableVPCAssociationProperties;
    const TYPE: &'static str = "AWS::EC2::LocalGatewayRouteTableVPCAssociation";
    fn properties(&self) -> &LocalGatewayRouteTableVPCAssociationProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut LocalGatewayRouteTableVPCAssociationProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for LocalGatewayRouteTableVPCAssociation {}

impl From<LocalGatewayRouteTableVPCAssociationProperties> for LocalGatewayRouteTableVPCAssociation {
    fn from(properties: LocalGatewayRouteTableVPCAssociationProperties) -> LocalGatewayRouteTableVPCAssociation {
        LocalGatewayRouteTableVPCAssociation { properties }
    }
}

/// The [`AWS::EC2::LocalGatewayRouteTableVirtualInterfaceGroupAssociation`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevirtualinterfacegroupassociation.html) resource type.
#[derive(Debug, Default)]
pub struct LocalGatewayRouteTableVirtualInterfaceGroupAssociation {
    properties: LocalGatewayRouteTableVirtualInterfaceGroupAssociationProperties
}

/// Properties for the `LocalGatewayRouteTableVirtualInterfaceGroupAssociation` resource.
#[derive(Debug, Default)]
pub struct LocalGatewayRouteTableVirtualInterfaceGroupAssociationProperties {
    /// Property [`LocalGatewayRouteTableId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevirtualinterfacegroupassociation.html#cfn-ec2-localgatewayroutetablevirtualinterfacegroupassociation-localgatewayroutetableid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub local_gateway_route_table_id: ::Value<String>,
    /// Property [`LocalGatewayVirtualInterfaceGroupId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevirtualinterfacegroupassociation.html#cfn-ec2-localgatewayroutetablevirtualinterfacegroupassociation-localgatewayvirtualinterfacegroupid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub local_gateway_virtual_interface_group_id: ::Value<String>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevirtualinterfacegroupassociation.html#cfn-ec2-localgatewayroutetablevirtualinterfacegroupassociation-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
}

impl ::serde::Serialize for LocalGatewayRouteTableVirtualInterfaceGroupAssociationProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "LocalGatewayRouteTableId", &self.local_gateway_route_table_id)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "LocalGatewayVirtualInterfaceGroupId", &self.local_gateway_virtual_interface_group_id)?;
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for LocalGatewayRouteTableVirtualInterfaceGroupAssociationProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<LocalGatewayRouteTableVirtualInterfaceGroupAssociationProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = LocalGatewayRouteTableVirtualInterfaceGroupAssociationProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type LocalGatewayRouteTableVirtualInterfaceGroupAssociationProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut local_gateway_route_table_id: Option<::Value<String>> = None;
                let mut local_gateway_virtual_interface_group_id: Option<::Value<String>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "LocalGatewayRouteTableId" => {
                            local_gateway_route_table_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "LocalGatewayVirtualInterfaceGroupId" => {
                            local_gateway_virtual_interface_group_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(LocalGatewayRouteTableVirtualInterfaceGroupAssociationProperties {
                    local_gateway_route_table_id: local_gateway_route_table_id.ok_or(::serde::de::Error::missing_field("LocalGatewayRouteTableId"))?,
                    local_gateway_virtual_interface_group_id: local_gateway_virtual_interface_group_id.ok_or(::serde::de::Error::missing_field("LocalGatewayVirtualInterfaceGroupId"))?,
                    tags: tags,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for LocalGatewayRouteTableVirtualInterfaceGroupAssociation {
    type Properties = LocalGatewayRouteTableVirtualInterfaceGroupAssociationProperties;
    const TYPE: &'static str = "AWS::EC2::LocalGatewayRouteTableVirtualInterfaceGroupAssociation";
    fn properties(&self) -> &LocalGatewayRouteTableVirtualInterfaceGroupAssociationProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut LocalGatewayRouteTableVirtualInterfaceGroupAssociationProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for LocalGatewayRouteTableVirtualInterfaceGroupAssociation {}

impl From<LocalGatewayRouteTableVirtualInterfaceGroupAssociationProperties> for LocalGatewayRouteTableVirtualInterfaceGroupAssociation {
    fn from(properties: LocalGatewayRouteTableVirtualInterfaceGroupAssociationProperties) -> LocalGatewayRouteTableVirtualInterfaceGroupAssociation {
        LocalGatewayRouteTableVirtualInterfaceGroupAssociation { properties }
    }
}

/// The [`AWS::EC2::NatGateway`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html) resource type.
#[derive(Debug, Default)]
pub struct NatGateway {
    properties: NatGatewayProperties
}

/// Properties for the `NatGateway` resource.
#[derive(Debug, Default)]
pub struct NatGatewayProperties {
    /// Property [`AllocationId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-allocationid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub allocation_id: Option<::Value<String>>,
    /// Property [`ConnectivityType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-connectivitytype).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub connectivity_type: Option<::Value<String>>,
    /// Property [`MaxDrainDurationSeconds`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-maxdraindurationseconds).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub max_drain_duration_seconds: Option<::Value<u32>>,
    /// Property [`PrivateIpAddress`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-privateipaddress).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub private_ip_address: Option<::Value<String>>,
    /// Property [`SecondaryAllocationIds`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-secondaryallocationids).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub secondary_allocation_ids: Option<::ValueList<String>>,
    /// Property [`SecondaryPrivateIpAddressCount`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-secondaryprivateipaddresscount).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub secondary_private_ip_address_count: Option<::Value<u32>>,
    /// Property [`SecondaryPrivateIpAddresses`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-secondaryprivateipaddresses).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub secondary_private_ip_addresses: Option<::ValueList<String>>,
    /// Property [`SubnetId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-subnetid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub subnet_id: ::Value<String>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
}

impl ::serde::Serialize for NatGatewayProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref allocation_id) = self.allocation_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "AllocationId", allocation_id)?;
        }
        if let Some(ref connectivity_type) = self.connectivity_type {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "ConnectivityType", connectivity_type)?;
        }
        if let Some(ref max_drain_duration_seconds) = self.max_drain_duration_seconds {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "MaxDrainDurationSeconds", max_drain_duration_seconds)?;
        }
        if let Some(ref private_ip_address) = self.private_ip_address {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "PrivateIpAddress", private_ip_address)?;
        }
        if let Some(ref secondary_allocation_ids) = self.secondary_allocation_ids {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SecondaryAllocationIds", secondary_allocation_ids)?;
        }
        if let Some(ref secondary_private_ip_address_count) = self.secondary_private_ip_address_count {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SecondaryPrivateIpAddressCount", secondary_private_ip_address_count)?;
        }
        if let Some(ref secondary_private_ip_addresses) = self.secondary_private_ip_addresses {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SecondaryPrivateIpAddresses", secondary_private_ip_addresses)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "SubnetId", &self.subnet_id)?;
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for NatGatewayProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<NatGatewayProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = NatGatewayProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type NatGatewayProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut allocation_id: Option<::Value<String>> = None;
                let mut connectivity_type: Option<::Value<String>> = None;
                let mut max_drain_duration_seconds: Option<::Value<u32>> = None;
                let mut private_ip_address: Option<::Value<String>> = None;
                let mut secondary_allocation_ids: Option<::ValueList<String>> = None;
                let mut secondary_private_ip_address_count: Option<::Value<u32>> = None;
                let mut secondary_private_ip_addresses: Option<::ValueList<String>> = None;
                let mut subnet_id: Option<::Value<String>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "AllocationId" => {
                            allocation_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "ConnectivityType" => {
                            connectivity_type = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "MaxDrainDurationSeconds" => {
                            max_drain_duration_seconds = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "PrivateIpAddress" => {
                            private_ip_address = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SecondaryAllocationIds" => {
                            secondary_allocation_ids = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SecondaryPrivateIpAddressCount" => {
                            secondary_private_ip_address_count = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SecondaryPrivateIpAddresses" => {
                            secondary_private_ip_addresses = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SubnetId" => {
                            subnet_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(NatGatewayProperties {
                    allocation_id: allocation_id,
                    connectivity_type: connectivity_type,
                    max_drain_duration_seconds: max_drain_duration_seconds,
                    private_ip_address: private_ip_address,
                    secondary_allocation_ids: secondary_allocation_ids,
                    secondary_private_ip_address_count: secondary_private_ip_address_count,
                    secondary_private_ip_addresses: secondary_private_ip_addresses,
                    subnet_id: subnet_id.ok_or(::serde::de::Error::missing_field("SubnetId"))?,
                    tags: tags,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for NatGateway {
    type Properties = NatGatewayProperties;
    const TYPE: &'static str = "AWS::EC2::NatGateway";
    fn properties(&self) -> &NatGatewayProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut NatGatewayProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for NatGateway {}

impl From<NatGatewayProperties> for NatGateway {
    fn from(properties: NatGatewayProperties) -> NatGateway {
        NatGateway { properties }
    }
}

/// The [`AWS::EC2::NetworkAcl`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkacl.html) resource type.
#[derive(Debug, Default)]
pub struct NetworkAcl {
    properties: NetworkAclProperties
}

/// Properties for the `NetworkAcl` resource.
#[derive(Debug, Default)]
pub struct NetworkAclProperties {
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkacl.html#cfn-ec2-networkacl-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
    /// Property [`VpcId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkacl.html#cfn-ec2-networkacl-vpcid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub vpc_id: ::Value<String>,
}

impl ::serde::Serialize for NetworkAclProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "VpcId", &self.vpc_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for NetworkAclProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<NetworkAclProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = NetworkAclProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type NetworkAclProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut tags: Option<::ValueList<::Tag>> = None;
                let mut vpc_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "VpcId" => {
                            vpc_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(NetworkAclProperties {
                    tags: tags,
                    vpc_id: vpc_id.ok_or(::serde::de::Error::missing_field("VpcId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for NetworkAcl {
    type Properties = NetworkAclProperties;
    const TYPE: &'static str = "AWS::EC2::NetworkAcl";
    fn properties(&self) -> &NetworkAclProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut NetworkAclProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for NetworkAcl {}

impl From<NetworkAclProperties> for NetworkAcl {
    fn from(properties: NetworkAclProperties) -> NetworkAcl {
        NetworkAcl { properties }
    }
}

/// The [`AWS::EC2::NetworkAclEntry`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html) resource type.
#[derive(Debug, Default)]
pub struct NetworkAclEntry {
    properties: NetworkAclEntryProperties
}

/// Properties for the `NetworkAclEntry` resource.
#[derive(Debug, Default)]
pub struct NetworkAclEntryProperties {
    /// Property [`CidrBlock`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-cidrblock).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub cidr_block: Option<::Value<String>>,
    /// Property [`Egress`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-egress).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub egress: Option<::Value<bool>>,
    /// Property [`Icmp`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-icmp).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub icmp: Option<::Value<self::network_acl_entry::Icmp>>,
    /// Property [`Ipv6CidrBlock`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-ipv6cidrblock).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub ipv6_cidr_block: Option<::Value<String>>,
    /// Property [`NetworkAclId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-networkaclid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub network_acl_id: ::Value<String>,
    /// Property [`PortRange`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-portrange).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub port_range: Option<::Value<self::network_acl_entry::PortRange>>,
    /// Property [`Protocol`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-protocol).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub protocol: ::Value<u32>,
    /// Property [`RuleAction`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-ruleaction).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub rule_action: ::Value<String>,
    /// Property [`RuleNumber`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-rulenumber).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub rule_number: ::Value<u32>,
}

impl ::serde::Serialize for NetworkAclEntryProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref cidr_block) = self.cidr_block {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "CidrBlock", cidr_block)?;
        }
        if let Some(ref egress) = self.egress {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Egress", egress)?;
        }
        if let Some(ref icmp) = self.icmp {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Icmp", icmp)?;
        }
        if let Some(ref ipv6_cidr_block) = self.ipv6_cidr_block {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6CidrBlock", ipv6_cidr_block)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetworkAclId", &self.network_acl_id)?;
        if let Some(ref port_range) = self.port_range {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "PortRange", port_range)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "Protocol", &self.protocol)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "RuleAction", &self.rule_action)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "RuleNumber", &self.rule_number)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for NetworkAclEntryProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<NetworkAclEntryProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = NetworkAclEntryProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type NetworkAclEntryProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut cidr_block: Option<::Value<String>> = None;
                let mut egress: Option<::Value<bool>> = None;
                let mut icmp: Option<::Value<self::network_acl_entry::Icmp>> = None;
                let mut ipv6_cidr_block: Option<::Value<String>> = None;
                let mut network_acl_id: Option<::Value<String>> = None;
                let mut port_range: Option<::Value<self::network_acl_entry::PortRange>> = None;
                let mut protocol: Option<::Value<u32>> = None;
                let mut rule_action: Option<::Value<String>> = None;
                let mut rule_number: Option<::Value<u32>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "CidrBlock" => {
                            cidr_block = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Egress" => {
                            egress = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Icmp" => {
                            icmp = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Ipv6CidrBlock" => {
                            ipv6_cidr_block = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "NetworkAclId" => {
                            network_acl_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "PortRange" => {
                            port_range = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Protocol" => {
                            protocol = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "RuleAction" => {
                            rule_action = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "RuleNumber" => {
                            rule_number = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(NetworkAclEntryProperties {
                    cidr_block: cidr_block,
                    egress: egress,
                    icmp: icmp,
                    ipv6_cidr_block: ipv6_cidr_block,
                    network_acl_id: network_acl_id.ok_or(::serde::de::Error::missing_field("NetworkAclId"))?,
                    port_range: port_range,
                    protocol: protocol.ok_or(::serde::de::Error::missing_field("Protocol"))?,
                    rule_action: rule_action.ok_or(::serde::de::Error::missing_field("RuleAction"))?,
                    rule_number: rule_number.ok_or(::serde::de::Error::missing_field("RuleNumber"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for NetworkAclEntry {
    type Properties = NetworkAclEntryProperties;
    const TYPE: &'static str = "AWS::EC2::NetworkAclEntry";
    fn properties(&self) -> &NetworkAclEntryProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut NetworkAclEntryProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for NetworkAclEntry {}

impl From<NetworkAclEntryProperties> for NetworkAclEntry {
    fn from(properties: NetworkAclEntryProperties) -> NetworkAclEntry {
        NetworkAclEntry { properties }
    }
}

/// The [`AWS::EC2::NetworkInsightsAccessScope`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html) resource type.
#[derive(Debug, Default)]
pub struct NetworkInsightsAccessScope {
    properties: NetworkInsightsAccessScopeProperties
}

/// Properties for the `NetworkInsightsAccessScope` resource.
#[derive(Debug, Default)]
pub struct NetworkInsightsAccessScopeProperties {
    /// Property [`ExcludePaths`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html#cfn-ec2-networkinsightsaccessscope-excludepaths).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub exclude_paths: Option<::ValueList<self::network_insights_access_scope::AccessScopePathRequest>>,
    /// Property [`MatchPaths`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html#cfn-ec2-networkinsightsaccessscope-matchpaths).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub match_paths: Option<::ValueList<self::network_insights_access_scope::AccessScopePathRequest>>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html#cfn-ec2-networkinsightsaccessscope-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
}

impl ::serde::Serialize for NetworkInsightsAccessScopeProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref exclude_paths) = self.exclude_paths {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "ExcludePaths", exclude_paths)?;
        }
        if let Some(ref match_paths) = self.match_paths {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "MatchPaths", match_paths)?;
        }
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for NetworkInsightsAccessScopeProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<NetworkInsightsAccessScopeProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = NetworkInsightsAccessScopeProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type NetworkInsightsAccessScopeProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut exclude_paths: Option<::ValueList<self::network_insights_access_scope::AccessScopePathRequest>> = None;
                let mut match_paths: Option<::ValueList<self::network_insights_access_scope::AccessScopePathRequest>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "ExcludePaths" => {
                            exclude_paths = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "MatchPaths" => {
                            match_paths = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(NetworkInsightsAccessScopeProperties {
                    exclude_paths: exclude_paths,
                    match_paths: match_paths,
                    tags: tags,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for NetworkInsightsAccessScope {
    type Properties = NetworkInsightsAccessScopeProperties;
    const TYPE: &'static str = "AWS::EC2::NetworkInsightsAccessScope";
    fn properties(&self) -> &NetworkInsightsAccessScopeProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut NetworkInsightsAccessScopeProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for NetworkInsightsAccessScope {}

impl From<NetworkInsightsAccessScopeProperties> for NetworkInsightsAccessScope {
    fn from(properties: NetworkInsightsAccessScopeProperties) -> NetworkInsightsAccessScope {
        NetworkInsightsAccessScope { properties }
    }
}

/// The [`AWS::EC2::NetworkInsightsAccessScopeAnalysis`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscopeanalysis.html) resource type.
#[derive(Debug, Default)]
pub struct NetworkInsightsAccessScopeAnalysis {
    properties: NetworkInsightsAccessScopeAnalysisProperties
}

/// Properties for the `NetworkInsightsAccessScopeAnalysis` resource.
#[derive(Debug, Default)]
pub struct NetworkInsightsAccessScopeAnalysisProperties {
    /// Property [`NetworkInsightsAccessScopeId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscopeanalysis.html#cfn-ec2-networkinsightsaccessscopeanalysis-networkinsightsaccessscopeid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub network_insights_access_scope_id: ::Value<String>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscopeanalysis.html#cfn-ec2-networkinsightsaccessscopeanalysis-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
}

impl ::serde::Serialize for NetworkInsightsAccessScopeAnalysisProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetworkInsightsAccessScopeId", &self.network_insights_access_scope_id)?;
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for NetworkInsightsAccessScopeAnalysisProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<NetworkInsightsAccessScopeAnalysisProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = NetworkInsightsAccessScopeAnalysisProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type NetworkInsightsAccessScopeAnalysisProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut network_insights_access_scope_id: Option<::Value<String>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "NetworkInsightsAccessScopeId" => {
                            network_insights_access_scope_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(NetworkInsightsAccessScopeAnalysisProperties {
                    network_insights_access_scope_id: network_insights_access_scope_id.ok_or(::serde::de::Error::missing_field("NetworkInsightsAccessScopeId"))?,
                    tags: tags,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for NetworkInsightsAccessScopeAnalysis {
    type Properties = NetworkInsightsAccessScopeAnalysisProperties;
    const TYPE: &'static str = "AWS::EC2::NetworkInsightsAccessScopeAnalysis";
    fn properties(&self) -> &NetworkInsightsAccessScopeAnalysisProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut NetworkInsightsAccessScopeAnalysisProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for NetworkInsightsAccessScopeAnalysis {}

impl From<NetworkInsightsAccessScopeAnalysisProperties> for NetworkInsightsAccessScopeAnalysis {
    fn from(properties: NetworkInsightsAccessScopeAnalysisProperties) -> NetworkInsightsAccessScopeAnalysis {
        NetworkInsightsAccessScopeAnalysis { properties }
    }
}

/// The [`AWS::EC2::NetworkInsightsAnalysis`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html) resource type.
#[derive(Debug, Default)]
pub struct NetworkInsightsAnalysis {
    properties: NetworkInsightsAnalysisProperties
}

/// Properties for the `NetworkInsightsAnalysis` resource.
#[derive(Debug, Default)]
pub struct NetworkInsightsAnalysisProperties {
    /// Property [`AdditionalAccounts`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html#cfn-ec2-networkinsightsanalysis-additionalaccounts).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub additional_accounts: Option<::ValueList<String>>,
    /// Property [`FilterInArns`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html#cfn-ec2-networkinsightsanalysis-filterinarns).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub filter_in_arns: Option<::ValueList<String>>,
    /// Property [`NetworkInsightsPathId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html#cfn-ec2-networkinsightsanalysis-networkinsightspathid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub network_insights_path_id: ::Value<String>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html#cfn-ec2-networkinsightsanalysis-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
}

impl ::serde::Serialize for NetworkInsightsAnalysisProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref additional_accounts) = self.additional_accounts {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "AdditionalAccounts", additional_accounts)?;
        }
        if let Some(ref filter_in_arns) = self.filter_in_arns {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "FilterInArns", filter_in_arns)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetworkInsightsPathId", &self.network_insights_path_id)?;
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for NetworkInsightsAnalysisProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<NetworkInsightsAnalysisProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = NetworkInsightsAnalysisProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type NetworkInsightsAnalysisProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut additional_accounts: Option<::ValueList<String>> = None;
                let mut filter_in_arns: Option<::ValueList<String>> = None;
                let mut network_insights_path_id: Option<::Value<String>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "AdditionalAccounts" => {
                            additional_accounts = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "FilterInArns" => {
                            filter_in_arns = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "NetworkInsightsPathId" => {
                            network_insights_path_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(NetworkInsightsAnalysisProperties {
                    additional_accounts: additional_accounts,
                    filter_in_arns: filter_in_arns,
                    network_insights_path_id: network_insights_path_id.ok_or(::serde::de::Error::missing_field("NetworkInsightsPathId"))?,
                    tags: tags,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for NetworkInsightsAnalysis {
    type Properties = NetworkInsightsAnalysisProperties;
    const TYPE: &'static str = "AWS::EC2::NetworkInsightsAnalysis";
    fn properties(&self) -> &NetworkInsightsAnalysisProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut NetworkInsightsAnalysisProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for NetworkInsightsAnalysis {}

impl From<NetworkInsightsAnalysisProperties> for NetworkInsightsAnalysis {
    fn from(properties: NetworkInsightsAnalysisProperties) -> NetworkInsightsAnalysis {
        NetworkInsightsAnalysis { properties }
    }
}

/// The [`AWS::EC2::NetworkInsightsPath`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html) resource type.
#[derive(Debug, Default)]
pub struct NetworkInsightsPath {
    properties: NetworkInsightsPathProperties
}

/// Properties for the `NetworkInsightsPath` resource.
#[derive(Debug, Default)]
pub struct NetworkInsightsPathProperties {
    /// Property [`Destination`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-destination).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub destination: Option<::Value<String>>,
    /// Property [`DestinationIp`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-destinationip).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub destination_ip: Option<::Value<String>>,
    /// Property [`DestinationPort`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-destinationport).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub destination_port: Option<::Value<u32>>,
    /// Property [`FilterAtDestination`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-filteratdestination).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub filter_at_destination: Option<::Value<self::network_insights_path::PathFilter>>,
    /// Property [`FilterAtSource`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-filteratsource).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub filter_at_source: Option<::Value<self::network_insights_path::PathFilter>>,
    /// Property [`Protocol`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-protocol).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub protocol: ::Value<String>,
    /// Property [`Source`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-source).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub source: ::Value<String>,
    /// Property [`SourceIp`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-sourceip).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub source_ip: Option<::Value<String>>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
}

impl ::serde::Serialize for NetworkInsightsPathProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref destination) = self.destination {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Destination", destination)?;
        }
        if let Some(ref destination_ip) = self.destination_ip {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "DestinationIp", destination_ip)?;
        }
        if let Some(ref destination_port) = self.destination_port {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "DestinationPort", destination_port)?;
        }
        if let Some(ref filter_at_destination) = self.filter_at_destination {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "FilterAtDestination", filter_at_destination)?;
        }
        if let Some(ref filter_at_source) = self.filter_at_source {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "FilterAtSource", filter_at_source)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "Protocol", &self.protocol)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "Source", &self.source)?;
        if let Some(ref source_ip) = self.source_ip {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SourceIp", source_ip)?;
        }
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for NetworkInsightsPathProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<NetworkInsightsPathProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = NetworkInsightsPathProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type NetworkInsightsPathProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut destination: Option<::Value<String>> = None;
                let mut destination_ip: Option<::Value<String>> = None;
                let mut destination_port: Option<::Value<u32>> = None;
                let mut filter_at_destination: Option<::Value<self::network_insights_path::PathFilter>> = None;
                let mut filter_at_source: Option<::Value<self::network_insights_path::PathFilter>> = None;
                let mut protocol: Option<::Value<String>> = None;
                let mut source: Option<::Value<String>> = None;
                let mut source_ip: Option<::Value<String>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "Destination" => {
                            destination = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "DestinationIp" => {
                            destination_ip = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "DestinationPort" => {
                            destination_port = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "FilterAtDestination" => {
                            filter_at_destination = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "FilterAtSource" => {
                            filter_at_source = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Protocol" => {
                            protocol = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Source" => {
                            source = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SourceIp" => {
                            source_ip = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(NetworkInsightsPathProperties {
                    destination: destination,
                    destination_ip: destination_ip,
                    destination_port: destination_port,
                    filter_at_destination: filter_at_destination,
                    filter_at_source: filter_at_source,
                    protocol: protocol.ok_or(::serde::de::Error::missing_field("Protocol"))?,
                    source: source.ok_or(::serde::de::Error::missing_field("Source"))?,
                    source_ip: source_ip,
                    tags: tags,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for NetworkInsightsPath {
    type Properties = NetworkInsightsPathProperties;
    const TYPE: &'static str = "AWS::EC2::NetworkInsightsPath";
    fn properties(&self) -> &NetworkInsightsPathProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut NetworkInsightsPathProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for NetworkInsightsPath {}

impl From<NetworkInsightsPathProperties> for NetworkInsightsPath {
    fn from(properties: NetworkInsightsPathProperties) -> NetworkInsightsPath {
        NetworkInsightsPath { properties }
    }
}

/// The [`AWS::EC2::NetworkInterface`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html) resource type.
#[derive(Debug, Default)]
pub struct NetworkInterface {
    properties: NetworkInterfaceProperties
}

/// Properties for the `NetworkInterface` resource.
#[derive(Debug, Default)]
pub struct NetworkInterfaceProperties {
    /// Property [`ConnectionTrackingSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-connectiontrackingspecification).
    ///
    /// Update type: _Conditional_.
    /// Conditional updates can be mutable or immutable, depending on, for example, which other properties you updated.
    /// For more information, see the relevant resource type documentation.
    pub connection_tracking_specification: Option<::Value<self::network_interface::ConnectionTrackingSpecification>>,
    /// Property [`Description`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-description).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub description: Option<::Value<String>>,
    /// Property [`GroupSet`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-groupset).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub group_set: Option<::ValueList<String>>,
    /// Property [`InterfaceType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-interfacetype).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub interface_type: Option<::Value<String>>,
    /// Property [`Ipv4PrefixCount`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-ipv4prefixcount).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub ipv4_prefix_count: Option<::Value<u32>>,
    /// Property [`Ipv4Prefixes`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-ipv4prefixes).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub ipv4_prefixes: Option<::ValueList<self::network_interface::Ipv4PrefixSpecification>>,
    /// Property [`Ipv6AddressCount`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-ipv6addresscount).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub ipv6_address_count: Option<::Value<u32>>,
    /// Property [`Ipv6Addresses`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-ipv6addresses).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub ipv6_addresses: Option<::ValueList<self::network_interface::InstanceIpv6Address>>,
    /// Property [`Ipv6PrefixCount`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-ipv6prefixcount).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub ipv6_prefix_count: Option<::Value<u32>>,
    /// Property [`Ipv6Prefixes`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-ipv6prefixes).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub ipv6_prefixes: Option<::ValueList<self::network_interface::Ipv6PrefixSpecification>>,
    /// Property [`PrivateIpAddress`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-privateipaddress).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub private_ip_address: Option<::Value<String>>,
    /// Property [`PrivateIpAddresses`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-privateipaddresses).
    ///
    /// Update type: _Conditional_.
    /// Conditional updates can be mutable or immutable, depending on, for example, which other properties you updated.
    /// For more information, see the relevant resource type documentation.
    pub private_ip_addresses: Option<::ValueList<self::network_interface::PrivateIpAddressSpecification>>,
    /// Property [`SecondaryPrivateIpAddressCount`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-secondaryprivateipaddresscount).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub secondary_private_ip_address_count: Option<::Value<u32>>,
    /// Property [`SourceDestCheck`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-sourcedestcheck).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub source_dest_check: Option<::Value<bool>>,
    /// Property [`SubnetId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-subnetid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub subnet_id: ::Value<String>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
}

impl ::serde::Serialize for NetworkInterfaceProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref connection_tracking_specification) = self.connection_tracking_specification {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "ConnectionTrackingSpecification", connection_tracking_specification)?;
        }
        if let Some(ref description) = self.description {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Description", description)?;
        }
        if let Some(ref group_set) = self.group_set {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "GroupSet", group_set)?;
        }
        if let Some(ref interface_type) = self.interface_type {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "InterfaceType", interface_type)?;
        }
        if let Some(ref ipv4_prefix_count) = self.ipv4_prefix_count {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv4PrefixCount", ipv4_prefix_count)?;
        }
        if let Some(ref ipv4_prefixes) = self.ipv4_prefixes {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv4Prefixes", ipv4_prefixes)?;
        }
        if let Some(ref ipv6_address_count) = self.ipv6_address_count {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6AddressCount", ipv6_address_count)?;
        }
        if let Some(ref ipv6_addresses) = self.ipv6_addresses {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6Addresses", ipv6_addresses)?;
        }
        if let Some(ref ipv6_prefix_count) = self.ipv6_prefix_count {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6PrefixCount", ipv6_prefix_count)?;
        }
        if let Some(ref ipv6_prefixes) = self.ipv6_prefixes {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6Prefixes", ipv6_prefixes)?;
        }
        if let Some(ref private_ip_address) = self.private_ip_address {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "PrivateIpAddress", private_ip_address)?;
        }
        if let Some(ref private_ip_addresses) = self.private_ip_addresses {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "PrivateIpAddresses", private_ip_addresses)?;
        }
        if let Some(ref secondary_private_ip_address_count) = self.secondary_private_ip_address_count {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SecondaryPrivateIpAddressCount", secondary_private_ip_address_count)?;
        }
        if let Some(ref source_dest_check) = self.source_dest_check {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SourceDestCheck", source_dest_check)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "SubnetId", &self.subnet_id)?;
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for NetworkInterfaceProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<NetworkInterfaceProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = NetworkInterfaceProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type NetworkInterfaceProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut connection_tracking_specification: Option<::Value<self::network_interface::ConnectionTrackingSpecification>> = None;
                let mut description: Option<::Value<String>> = None;
                let mut group_set: Option<::ValueList<String>> = None;
                let mut interface_type: Option<::Value<String>> = None;
                let mut ipv4_prefix_count: Option<::Value<u32>> = None;
                let mut ipv4_prefixes: Option<::ValueList<self::network_interface::Ipv4PrefixSpecification>> = None;
                let mut ipv6_address_count: Option<::Value<u32>> = None;
                let mut ipv6_addresses: Option<::ValueList<self::network_interface::InstanceIpv6Address>> = None;
                let mut ipv6_prefix_count: Option<::Value<u32>> = None;
                let mut ipv6_prefixes: Option<::ValueList<self::network_interface::Ipv6PrefixSpecification>> = None;
                let mut private_ip_address: Option<::Value<String>> = None;
                let mut private_ip_addresses: Option<::ValueList<self::network_interface::PrivateIpAddressSpecification>> = None;
                let mut secondary_private_ip_address_count: Option<::Value<u32>> = None;
                let mut source_dest_check: Option<::Value<bool>> = None;
                let mut subnet_id: Option<::Value<String>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "ConnectionTrackingSpecification" => {
                            connection_tracking_specification = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Description" => {
                            description = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "GroupSet" => {
                            group_set = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "InterfaceType" => {
                            interface_type = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Ipv4PrefixCount" => {
                            ipv4_prefix_count = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Ipv4Prefixes" => {
                            ipv4_prefixes = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Ipv6AddressCount" => {
                            ipv6_address_count = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Ipv6Addresses" => {
                            ipv6_addresses = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Ipv6PrefixCount" => {
                            ipv6_prefix_count = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Ipv6Prefixes" => {
                            ipv6_prefixes = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "PrivateIpAddress" => {
                            private_ip_address = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "PrivateIpAddresses" => {
                            private_ip_addresses = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SecondaryPrivateIpAddressCount" => {
                            secondary_private_ip_address_count = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SourceDestCheck" => {
                            source_dest_check = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SubnetId" => {
                            subnet_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(NetworkInterfaceProperties {
                    connection_tracking_specification: connection_tracking_specification,
                    description: description,
                    group_set: group_set,
                    interface_type: interface_type,
                    ipv4_prefix_count: ipv4_prefix_count,
                    ipv4_prefixes: ipv4_prefixes,
                    ipv6_address_count: ipv6_address_count,
                    ipv6_addresses: ipv6_addresses,
                    ipv6_prefix_count: ipv6_prefix_count,
                    ipv6_prefixes: ipv6_prefixes,
                    private_ip_address: private_ip_address,
                    private_ip_addresses: private_ip_addresses,
                    secondary_private_ip_address_count: secondary_private_ip_address_count,
                    source_dest_check: source_dest_check,
                    subnet_id: subnet_id.ok_or(::serde::de::Error::missing_field("SubnetId"))?,
                    tags: tags,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for NetworkInterface {
    type Properties = NetworkInterfaceProperties;
    const TYPE: &'static str = "AWS::EC2::NetworkInterface";
    fn properties(&self) -> &NetworkInterfaceProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut NetworkInterfaceProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for NetworkInterface {}

impl From<NetworkInterfaceProperties> for NetworkInterface {
    fn from(properties: NetworkInterfaceProperties) -> NetworkInterface {
        NetworkInterface { properties }
    }
}

/// The [`AWS::EC2::NetworkInterfaceAttachment`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html) resource type.
#[derive(Debug, Default)]
pub struct NetworkInterfaceAttachment {
    properties: NetworkInterfaceAttachmentProperties
}

/// Properties for the `NetworkInterfaceAttachment` resource.
#[derive(Debug, Default)]
pub struct NetworkInterfaceAttachmentProperties {
    /// Property [`DeleteOnTermination`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html#cfn-ec2-networkinterfaceattachment-deleteontermination).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub delete_on_termination: Option<::Value<bool>>,
    /// Property [`DeviceIndex`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html#cfn-ec2-networkinterfaceattachment-deviceindex).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub device_index: ::Value<String>,
    /// Property [`InstanceId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html#cfn-ec2-networkinterfaceattachment-instanceid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub instance_id: ::Value<String>,
    /// Property [`NetworkInterfaceId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfaceattachment.html#cfn-ec2-networkinterfaceattachment-networkinterfaceid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub network_interface_id: ::Value<String>,
}

impl ::serde::Serialize for NetworkInterfaceAttachmentProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref delete_on_termination) = self.delete_on_termination {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "DeleteOnTermination", delete_on_termination)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "DeviceIndex", &self.device_index)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstanceId", &self.instance_id)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetworkInterfaceId", &self.network_interface_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for NetworkInterfaceAttachmentProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<NetworkInterfaceAttachmentProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = NetworkInterfaceAttachmentProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type NetworkInterfaceAttachmentProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut delete_on_termination: Option<::Value<bool>> = None;
                let mut device_index: Option<::Value<String>> = None;
                let mut instance_id: Option<::Value<String>> = None;
                let mut network_interface_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "DeleteOnTermination" => {
                            delete_on_termination = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "DeviceIndex" => {
                            device_index = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "InstanceId" => {
                            instance_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "NetworkInterfaceId" => {
                            network_interface_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(NetworkInterfaceAttachmentProperties {
                    delete_on_termination: delete_on_termination,
                    device_index: device_index.ok_or(::serde::de::Error::missing_field("DeviceIndex"))?,
                    instance_id: instance_id.ok_or(::serde::de::Error::missing_field("InstanceId"))?,
                    network_interface_id: network_interface_id.ok_or(::serde::de::Error::missing_field("NetworkInterfaceId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for NetworkInterfaceAttachment {
    type Properties = NetworkInterfaceAttachmentProperties;
    const TYPE: &'static str = "AWS::EC2::NetworkInterfaceAttachment";
    fn properties(&self) -> &NetworkInterfaceAttachmentProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut NetworkInterfaceAttachmentProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for NetworkInterfaceAttachment {}

impl From<NetworkInterfaceAttachmentProperties> for NetworkInterfaceAttachment {
    fn from(properties: NetworkInterfaceAttachmentProperties) -> NetworkInterfaceAttachment {
        NetworkInterfaceAttachment { properties }
    }
}

/// The [`AWS::EC2::NetworkInterfacePermission`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html) resource type.
#[derive(Debug, Default)]
pub struct NetworkInterfacePermission {
    properties: NetworkInterfacePermissionProperties
}

/// Properties for the `NetworkInterfacePermission` resource.
#[derive(Debug, Default)]
pub struct NetworkInterfacePermissionProperties {
    /// Property [`AwsAccountId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html#cfn-ec2-networkinterfacepermission-awsaccountid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub aws_account_id: ::Value<String>,
    /// Property [`NetworkInterfaceId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html#cfn-ec2-networkinterfacepermission-networkinterfaceid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub network_interface_id: ::Value<String>,
    /// Property [`Permission`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html#cfn-ec2-networkinterfacepermission-permission).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub permission: ::Value<String>,
}

impl ::serde::Serialize for NetworkInterfacePermissionProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "AwsAccountId", &self.aws_account_id)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetworkInterfaceId", &self.network_interface_id)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "Permission", &self.permission)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for NetworkInterfacePermissionProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<NetworkInterfacePermissionProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = NetworkInterfacePermissionProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type NetworkInterfacePermissionProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut aws_account_id: Option<::Value<String>> = None;
                let mut network_interface_id: Option<::Value<String>> = None;
                let mut permission: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "AwsAccountId" => {
                            aws_account_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "NetworkInterfaceId" => {
                            network_interface_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Permission" => {
                            permission = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(NetworkInterfacePermissionProperties {
                    aws_account_id: aws_account_id.ok_or(::serde::de::Error::missing_field("AwsAccountId"))?,
                    network_interface_id: network_interface_id.ok_or(::serde::de::Error::missing_field("NetworkInterfaceId"))?,
                    permission: permission.ok_or(::serde::de::Error::missing_field("Permission"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for NetworkInterfacePermission {
    type Properties = NetworkInterfacePermissionProperties;
    const TYPE: &'static str = "AWS::EC2::NetworkInterfacePermission";
    fn properties(&self) -> &NetworkInterfacePermissionProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut NetworkInterfacePermissionProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for NetworkInterfacePermission {}

impl From<NetworkInterfacePermissionProperties> for NetworkInterfacePermission {
    fn from(properties: NetworkInterfacePermissionProperties) -> NetworkInterfacePermission {
        NetworkInterfacePermission { properties }
    }
}

/// The [`AWS::EC2::NetworkPerformanceMetricSubscription`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkperformancemetricsubscription.html) resource type.
#[derive(Debug, Default)]
pub struct NetworkPerformanceMetricSubscription {
    properties: NetworkPerformanceMetricSubscriptionProperties
}

/// Properties for the `NetworkPerformanceMetricSubscription` resource.
#[derive(Debug, Default)]
pub struct NetworkPerformanceMetricSubscriptionProperties {
    /// Property [`Destination`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkperformancemetricsubscription.html#cfn-ec2-networkperformancemetricsubscription-destination).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub destination: ::Value<String>,
    /// Property [`Metric`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkperformancemetricsubscription.html#cfn-ec2-networkperformancemetricsubscription-metric).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub metric: ::Value<String>,
    /// Property [`Source`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkperformancemetricsubscription.html#cfn-ec2-networkperformancemetricsubscription-source).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub source: ::Value<String>,
    /// Property [`Statistic`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkperformancemetricsubscription.html#cfn-ec2-networkperformancemetricsubscription-statistic).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub statistic: ::Value<String>,
}

impl ::serde::Serialize for NetworkPerformanceMetricSubscriptionProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "Destination", &self.destination)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "Metric", &self.metric)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "Source", &self.source)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "Statistic", &self.statistic)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for NetworkPerformanceMetricSubscriptionProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<NetworkPerformanceMetricSubscriptionProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = NetworkPerformanceMetricSubscriptionProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type NetworkPerformanceMetricSubscriptionProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut destination: Option<::Value<String>> = None;
                let mut metric: Option<::Value<String>> = None;
                let mut source: Option<::Value<String>> = None;
                let mut statistic: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "Destination" => {
                            destination = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Metric" => {
                            metric = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Source" => {
                            source = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Statistic" => {
                            statistic = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(NetworkPerformanceMetricSubscriptionProperties {
                    destination: destination.ok_or(::serde::de::Error::missing_field("Destination"))?,
                    metric: metric.ok_or(::serde::de::Error::missing_field("Metric"))?,
                    source: source.ok_or(::serde::de::Error::missing_field("Source"))?,
                    statistic: statistic.ok_or(::serde::de::Error::missing_field("Statistic"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for NetworkPerformanceMetricSubscription {
    type Properties = NetworkPerformanceMetricSubscriptionProperties;
    const TYPE: &'static str = "AWS::EC2::NetworkPerformanceMetricSubscription";
    fn properties(&self) -> &NetworkPerformanceMetricSubscriptionProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut NetworkPerformanceMetricSubscriptionProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for NetworkPerformanceMetricSubscription {}

impl From<NetworkPerformanceMetricSubscriptionProperties> for NetworkPerformanceMetricSubscription {
    fn from(properties: NetworkPerformanceMetricSubscriptionProperties) -> NetworkPerformanceMetricSubscription {
        NetworkPerformanceMetricSubscription { properties }
    }
}

/// The [`AWS::EC2::PlacementGroup`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html) resource type.
#[derive(Debug, Default)]
pub struct PlacementGroup {
    properties: PlacementGroupProperties
}

/// Properties for the `PlacementGroup` resource.
#[derive(Debug, Default)]
pub struct PlacementGroupProperties {
    /// Property [`PartitionCount`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html#cfn-ec2-placementgroup-partitioncount).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub partition_count: Option<::Value<u32>>,
    /// Property [`SpreadLevel`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html#cfn-ec2-placementgroup-spreadlevel).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub spread_level: Option<::Value<String>>,
    /// Property [`Strategy`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html#cfn-ec2-placementgroup-strategy).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub strategy: Option<::Value<String>>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html#cfn-ec2-placementgroup-tags).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
}

impl ::serde::Serialize for PlacementGroupProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref partition_count) = self.partition_count {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "PartitionCount", partition_count)?;
        }
        if let Some(ref spread_level) = self.spread_level {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SpreadLevel", spread_level)?;
        }
        if let Some(ref strategy) = self.strategy {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Strategy", strategy)?;
        }
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for PlacementGroupProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<PlacementGroupProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = PlacementGroupProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type PlacementGroupProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut partition_count: Option<::Value<u32>> = None;
                let mut spread_level: Option<::Value<String>> = None;
                let mut strategy: Option<::Value<String>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "PartitionCount" => {
                            partition_count = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SpreadLevel" => {
                            spread_level = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Strategy" => {
                            strategy = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(PlacementGroupProperties {
                    partition_count: partition_count,
                    spread_level: spread_level,
                    strategy: strategy,
                    tags: tags,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for PlacementGroup {
    type Properties = PlacementGroupProperties;
    const TYPE: &'static str = "AWS::EC2::PlacementGroup";
    fn properties(&self) -> &PlacementGroupProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut PlacementGroupProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for PlacementGroup {}

impl From<PlacementGroupProperties> for PlacementGroup {
    fn from(properties: PlacementGroupProperties) -> PlacementGroup {
        PlacementGroup { properties }
    }
}

/// The [`AWS::EC2::PrefixList`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html) resource type.
#[derive(Debug, Default)]
pub struct PrefixList {
    properties: PrefixListProperties
}

/// Properties for the `PrefixList` resource.
#[derive(Debug, Default)]
pub struct PrefixListProperties {
    /// Property [`AddressFamily`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-addressfamily).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub address_family: ::Value<String>,
    /// Property [`Entries`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-entries).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub entries: Option<::ValueList<self::prefix_list::Entry>>,
    /// Property [`MaxEntries`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-maxentries).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub max_entries: ::Value<u32>,
    /// Property [`PrefixListName`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-prefixlistname).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub prefix_list_name: ::Value<String>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
}

impl ::serde::Serialize for PrefixListProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "AddressFamily", &self.address_family)?;
        if let Some(ref entries) = self.entries {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Entries", entries)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "MaxEntries", &self.max_entries)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "PrefixListName", &self.prefix_list_name)?;
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for PrefixListProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<PrefixListProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = PrefixListProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type PrefixListProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut address_family: Option<::Value<String>> = None;
                let mut entries: Option<::ValueList<self::prefix_list::Entry>> = None;
                let mut max_entries: Option<::Value<u32>> = None;
                let mut prefix_list_name: Option<::Value<String>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "AddressFamily" => {
                            address_family = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Entries" => {
                            entries = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "MaxEntries" => {
                            max_entries = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "PrefixListName" => {
                            prefix_list_name = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(PrefixListProperties {
                    address_family: address_family.ok_or(::serde::de::Error::missing_field("AddressFamily"))?,
                    entries: entries,
                    max_entries: max_entries.ok_or(::serde::de::Error::missing_field("MaxEntries"))?,
                    prefix_list_name: prefix_list_name.ok_or(::serde::de::Error::missing_field("PrefixListName"))?,
                    tags: tags,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for PrefixList {
    type Properties = PrefixListProperties;
    const TYPE: &'static str = "AWS::EC2::PrefixList";
    fn properties(&self) -> &PrefixListProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut PrefixListProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for PrefixList {}

impl From<PrefixListProperties> for PrefixList {
    fn from(properties: PrefixListProperties) -> PrefixList {
        PrefixList { properties }
    }
}

/// The [`AWS::EC2::Route`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html) resource type.
#[derive(Debug, Default)]
pub struct Route {
    properties: RouteProperties
}

/// Properties for the `Route` resource.
#[derive(Debug, Default)]
pub struct RouteProperties {
    /// Property [`CarrierGatewayId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-carriergatewayid).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub carrier_gateway_id: Option<::Value<String>>,
    /// Property [`CoreNetworkArn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-corenetworkarn).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub core_network_arn: Option<::Value<String>>,
    /// Property [`DestinationCidrBlock`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-destinationcidrblock).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub destination_cidr_block: Option<::Value<String>>,
    /// Property [`DestinationIpv6CidrBlock`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-destinationipv6cidrblock).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub destination_ipv6_cidr_block: Option<::Value<String>>,
    /// Property [`DestinationPrefixListId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-destinationprefixlistid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub destination_prefix_list_id: Option<::Value<String>>,
    /// Property [`EgressOnlyInternetGatewayId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-egressonlyinternetgatewayid).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub egress_only_internet_gateway_id: Option<::Value<String>>,
    /// Property [`GatewayId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-gatewayid).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub gateway_id: Option<::Value<String>>,
    /// Property [`InstanceId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-instanceid).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub instance_id: Option<::Value<String>>,
    /// Property [`LocalGatewayId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-localgatewayid).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub local_gateway_id: Option<::Value<String>>,
    /// Property [`NatGatewayId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-natgatewayid).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub nat_gateway_id: Option<::Value<String>>,
    /// Property [`NetworkInterfaceId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-networkinterfaceid).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub network_interface_id: Option<::Value<String>>,
    /// Property [`RouteTableId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-routetableid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub route_table_id: ::Value<String>,
    /// Property [`TransitGatewayId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-transitgatewayid).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub transit_gateway_id: Option<::Value<String>>,
    /// Property [`VpcEndpointId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-vpcendpointid).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub vpc_endpoint_id: Option<::Value<String>>,
    /// Property [`VpcPeeringConnectionId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-vpcpeeringconnectionid).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub vpc_peering_connection_id: Option<::Value<String>>,
}

impl ::serde::Serialize for RouteProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref carrier_gateway_id) = self.carrier_gateway_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "CarrierGatewayId", carrier_gateway_id)?;
        }
        if let Some(ref core_network_arn) = self.core_network_arn {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "CoreNetworkArn", core_network_arn)?;
        }
        if let Some(ref destination_cidr_block) = self.destination_cidr_block {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "DestinationCidrBlock", destination_cidr_block)?;
        }
        if let Some(ref destination_ipv6_cidr_block) = self.destination_ipv6_cidr_block {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "DestinationIpv6CidrBlock", destination_ipv6_cidr_block)?;
        }
        if let Some(ref destination_prefix_list_id) = self.destination_prefix_list_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "DestinationPrefixListId", destination_prefix_list_id)?;
        }
        if let Some(ref egress_only_internet_gateway_id) = self.egress_only_internet_gateway_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "EgressOnlyInternetGatewayId", egress_only_internet_gateway_id)?;
        }
        if let Some(ref gateway_id) = self.gateway_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "GatewayId", gateway_id)?;
        }
        if let Some(ref instance_id) = self.instance_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstanceId", instance_id)?;
        }
        if let Some(ref local_gateway_id) = self.local_gateway_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "LocalGatewayId", local_gateway_id)?;
        }
        if let Some(ref nat_gateway_id) = self.nat_gateway_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "NatGatewayId", nat_gateway_id)?;
        }
        if let Some(ref network_interface_id) = self.network_interface_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetworkInterfaceId", network_interface_id)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "RouteTableId", &self.route_table_id)?;
        if let Some(ref transit_gateway_id) = self.transit_gateway_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "TransitGatewayId", transit_gateway_id)?;
        }
        if let Some(ref vpc_endpoint_id) = self.vpc_endpoint_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "VpcEndpointId", vpc_endpoint_id)?;
        }
        if let Some(ref vpc_peering_connection_id) = self.vpc_peering_connection_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "VpcPeeringConnectionId", vpc_peering_connection_id)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for RouteProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<RouteProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = RouteProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type RouteProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut carrier_gateway_id: Option<::Value<String>> = None;
                let mut core_network_arn: Option<::Value<String>> = None;
                let mut destination_cidr_block: Option<::Value<String>> = None;
                let mut destination_ipv6_cidr_block: Option<::Value<String>> = None;
                let mut destination_prefix_list_id: Option<::Value<String>> = None;
                let mut egress_only_internet_gateway_id: Option<::Value<String>> = None;
                let mut gateway_id: Option<::Value<String>> = None;
                let mut instance_id: Option<::Value<String>> = None;
                let mut local_gateway_id: Option<::Value<String>> = None;
                let mut nat_gateway_id: Option<::Value<String>> = None;
                let mut network_interface_id: Option<::Value<String>> = None;
                let mut route_table_id: Option<::Value<String>> = None;
                let mut transit_gateway_id: Option<::Value<String>> = None;
                let mut vpc_endpoint_id: Option<::Value<String>> = None;
                let mut vpc_peering_connection_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "CarrierGatewayId" => {
                            carrier_gateway_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "CoreNetworkArn" => {
                            core_network_arn = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "DestinationCidrBlock" => {
                            destination_cidr_block = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "DestinationIpv6CidrBlock" => {
                            destination_ipv6_cidr_block = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "DestinationPrefixListId" => {
                            destination_prefix_list_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "EgressOnlyInternetGatewayId" => {
                            egress_only_internet_gateway_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "GatewayId" => {
                            gateway_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "InstanceId" => {
                            instance_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "LocalGatewayId" => {
                            local_gateway_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "NatGatewayId" => {
                            nat_gateway_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "NetworkInterfaceId" => {
                            network_interface_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "RouteTableId" => {
                            route_table_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TransitGatewayId" => {
                            transit_gateway_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "VpcEndpointId" => {
                            vpc_endpoint_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "VpcPeeringConnectionId" => {
                            vpc_peering_connection_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(RouteProperties {
                    carrier_gateway_id: carrier_gateway_id,
                    core_network_arn: core_network_arn,
                    destination_cidr_block: destination_cidr_block,
                    destination_ipv6_cidr_block: destination_ipv6_cidr_block,
                    destination_prefix_list_id: destination_prefix_list_id,
                    egress_only_internet_gateway_id: egress_only_internet_gateway_id,
                    gateway_id: gateway_id,
                    instance_id: instance_id,
                    local_gateway_id: local_gateway_id,
                    nat_gateway_id: nat_gateway_id,
                    network_interface_id: network_interface_id,
                    route_table_id: route_table_id.ok_or(::serde::de::Error::missing_field("RouteTableId"))?,
                    transit_gateway_id: transit_gateway_id,
                    vpc_endpoint_id: vpc_endpoint_id,
                    vpc_peering_connection_id: vpc_peering_connection_id,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for Route {
    type Properties = RouteProperties;
    const TYPE: &'static str = "AWS::EC2::Route";
    fn properties(&self) -> &RouteProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut RouteProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for Route {}

impl From<RouteProperties> for Route {
    fn from(properties: RouteProperties) -> Route {
        Route { properties }
    }
}

/// The [`AWS::EC2::RouteTable`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routetable.html) resource type.
#[derive(Debug, Default)]
pub struct RouteTable {
    properties: RouteTableProperties
}

/// Properties for the `RouteTable` resource.
#[derive(Debug, Default)]
pub struct RouteTableProperties {
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routetable.html#cfn-ec2-routetable-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
    /// Property [`VpcId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routetable.html#cfn-ec2-routetable-vpcid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub vpc_id: ::Value<String>,
}

impl ::serde::Serialize for RouteTableProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "VpcId", &self.vpc_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for RouteTableProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<RouteTableProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = RouteTableProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type RouteTableProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut tags: Option<::ValueList<::Tag>> = None;
                let mut vpc_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "VpcId" => {
                            vpc_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(RouteTableProperties {
                    tags: tags,
                    vpc_id: vpc_id.ok_or(::serde::de::Error::missing_field("VpcId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for RouteTable {
    type Properties = RouteTableProperties;
    const TYPE: &'static str = "AWS::EC2::RouteTable";
    fn properties(&self) -> &RouteTableProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut RouteTableProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for RouteTable {}

impl From<RouteTableProperties> for RouteTable {
    fn from(properties: RouteTableProperties) -> RouteTable {
        RouteTable { properties }
    }
}

/// The [`AWS::EC2::SecurityGroup`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html) resource type.
#[derive(Debug, Default)]
pub struct SecurityGroup {
    properties: SecurityGroupProperties
}

/// Properties for the `SecurityGroup` resource.
#[derive(Debug, Default)]
pub struct SecurityGroupProperties {
    /// Property [`GroupDescription`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html#cfn-ec2-securitygroup-groupdescription).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub group_description: ::Value<String>,
    /// Property [`GroupName`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html#cfn-ec2-securitygroup-groupname).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub group_name: Option<::Value<String>>,
    /// Property [`SecurityGroupEgress`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html#cfn-ec2-securitygroup-securitygroupegress).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub security_group_egress: Option<::ValueList<self::security_group::Egress>>,
    /// Property [`SecurityGroupIngress`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html#cfn-ec2-securitygroup-securitygroupingress).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub security_group_ingress: Option<::ValueList<self::security_group::Ingress>>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html#cfn-ec2-securitygroup-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
    /// Property [`VpcId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html#cfn-ec2-securitygroup-vpcid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub vpc_id: Option<::Value<String>>,
}

impl ::serde::Serialize for SecurityGroupProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "GroupDescription", &self.group_description)?;
        if let Some(ref group_name) = self.group_name {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "GroupName", group_name)?;
        }
        if let Some(ref security_group_egress) = self.security_group_egress {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SecurityGroupEgress", security_group_egress)?;
        }
        if let Some(ref security_group_ingress) = self.security_group_ingress {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SecurityGroupIngress", security_group_ingress)?;
        }
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        if let Some(ref vpc_id) = self.vpc_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "VpcId", vpc_id)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for SecurityGroupProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<SecurityGroupProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = SecurityGroupProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type SecurityGroupProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut group_description: Option<::Value<String>> = None;
                let mut group_name: Option<::Value<String>> = None;
                let mut security_group_egress: Option<::ValueList<self::security_group::Egress>> = None;
                let mut security_group_ingress: Option<::ValueList<self::security_group::Ingress>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;
                let mut vpc_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "GroupDescription" => {
                            group_description = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "GroupName" => {
                            group_name = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SecurityGroupEgress" => {
                            security_group_egress = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SecurityGroupIngress" => {
                            security_group_ingress = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "VpcId" => {
                            vpc_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(SecurityGroupProperties {
                    group_description: group_description.ok_or(::serde::de::Error::missing_field("GroupDescription"))?,
                    group_name: group_name,
                    security_group_egress: security_group_egress,
                    security_group_ingress: security_group_ingress,
                    tags: tags,
                    vpc_id: vpc_id,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for SecurityGroup {
    type Properties = SecurityGroupProperties;
    const TYPE: &'static str = "AWS::EC2::SecurityGroup";
    fn properties(&self) -> &SecurityGroupProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut SecurityGroupProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for SecurityGroup {}

impl From<SecurityGroupProperties> for SecurityGroup {
    fn from(properties: SecurityGroupProperties) -> SecurityGroup {
        SecurityGroup { properties }
    }
}

/// The [`AWS::EC2::SecurityGroupEgress`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html) resource type.
#[derive(Debug, Default)]
pub struct SecurityGroupEgress {
    properties: SecurityGroupEgressProperties
}

/// Properties for the `SecurityGroupEgress` resource.
#[derive(Debug, Default)]
pub struct SecurityGroupEgressProperties {
    /// Property [`CidrIp`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-cidrip).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub cidr_ip: Option<::Value<String>>,
    /// Property [`CidrIpv6`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-cidripv6).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub cidr_ipv6: Option<::Value<String>>,
    /// Property [`Description`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-description).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub description: Option<::Value<String>>,
    /// Property [`DestinationPrefixListId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-destinationprefixlistid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub destination_prefix_list_id: Option<::Value<String>>,
    /// Property [`DestinationSecurityGroupId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-destinationsecuritygroupid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub destination_security_group_id: Option<::Value<String>>,
    /// Property [`FromPort`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-fromport).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub from_port: Option<::Value<u32>>,
    /// Property [`GroupId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-groupid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub group_id: ::Value<String>,
    /// Property [`IpProtocol`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-ipprotocol).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub ip_protocol: ::Value<String>,
    /// Property [`ToPort`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-securitygroupegress.html#cfn-ec2-securitygroupegress-toport).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub to_port: Option<::Value<u32>>,
}

impl ::serde::Serialize for SecurityGroupEgressProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref cidr_ip) = self.cidr_ip {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "CidrIp", cidr_ip)?;
        }
        if let Some(ref cidr_ipv6) = self.cidr_ipv6 {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "CidrIpv6", cidr_ipv6)?;
        }
        if let Some(ref description) = self.description {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Description", description)?;
        }
        if let Some(ref destination_prefix_list_id) = self.destination_prefix_list_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "DestinationPrefixListId", destination_prefix_list_id)?;
        }
        if let Some(ref destination_security_group_id) = self.destination_security_group_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "DestinationSecurityGroupId", destination_security_group_id)?;
        }
        if let Some(ref from_port) = self.from_port {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "FromPort", from_port)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "GroupId", &self.group_id)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "IpProtocol", &self.ip_protocol)?;
        if let Some(ref to_port) = self.to_port {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "ToPort", to_port)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for SecurityGroupEgressProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<SecurityGroupEgressProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = SecurityGroupEgressProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type SecurityGroupEgressProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut cidr_ip: Option<::Value<String>> = None;
                let mut cidr_ipv6: Option<::Value<String>> = None;
                let mut description: Option<::Value<String>> = None;
                let mut destination_prefix_list_id: Option<::Value<String>> = None;
                let mut destination_security_group_id: Option<::Value<String>> = None;
                let mut from_port: Option<::Value<u32>> = None;
                let mut group_id: Option<::Value<String>> = None;
                let mut ip_protocol: Option<::Value<String>> = None;
                let mut to_port: Option<::Value<u32>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "CidrIp" => {
                            cidr_ip = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "CidrIpv6" => {
                            cidr_ipv6 = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Description" => {
                            description = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "DestinationPrefixListId" => {
                            destination_prefix_list_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "DestinationSecurityGroupId" => {
                            destination_security_group_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "FromPort" => {
                            from_port = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "GroupId" => {
                            group_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "IpProtocol" => {
                            ip_protocol = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "ToPort" => {
                            to_port = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(SecurityGroupEgressProperties {
                    cidr_ip: cidr_ip,
                    cidr_ipv6: cidr_ipv6,
                    description: description,
                    destination_prefix_list_id: destination_prefix_list_id,
                    destination_security_group_id: destination_security_group_id,
                    from_port: from_port,
                    group_id: group_id.ok_or(::serde::de::Error::missing_field("GroupId"))?,
                    ip_protocol: ip_protocol.ok_or(::serde::de::Error::missing_field("IpProtocol"))?,
                    to_port: to_port,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for SecurityGroupEgress {
    type Properties = SecurityGroupEgressProperties;
    const TYPE: &'static str = "AWS::EC2::SecurityGroupEgress";
    fn properties(&self) -> &SecurityGroupEgressProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut SecurityGroupEgressProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for SecurityGroupEgress {}

impl From<SecurityGroupEgressProperties> for SecurityGroupEgress {
    fn from(properties: SecurityGroupEgressProperties) -> SecurityGroupEgress {
        SecurityGroupEgress { properties }
    }
}

/// The [`AWS::EC2::SecurityGroupIngress`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html) resource type.
#[derive(Debug, Default)]
pub struct SecurityGroupIngress {
    properties: SecurityGroupIngressProperties
}

/// Properties for the `SecurityGroupIngress` resource.
#[derive(Debug, Default)]
pub struct SecurityGroupIngressProperties {
    /// Property [`CidrIp`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-security-group-ingress-cidrip).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub cidr_ip: Option<::Value<String>>,
    /// Property [`CidrIpv6`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-security-group-ingress-cidripv6).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub cidr_ipv6: Option<::Value<String>>,
    /// Property [`Description`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-security-group-ingress-description).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub description: Option<::Value<String>>,
    /// Property [`FromPort`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-security-group-ingress-fromport).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub from_port: Option<::Value<u32>>,
    /// Property [`GroupId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-security-group-ingress-groupid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub group_id: Option<::Value<String>>,
    /// Property [`GroupName`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-security-group-ingress-groupname).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub group_name: Option<::Value<String>>,
    /// Property [`IpProtocol`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-security-group-ingress-ipprotocol).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub ip_protocol: ::Value<String>,
    /// Property [`SourcePrefixListId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-securitygroupingress-sourceprefixlistid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub source_prefix_list_id: Option<::Value<String>>,
    /// Property [`SourceSecurityGroupId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-security-group-ingress-sourcesecuritygroupid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub source_security_group_id: Option<::Value<String>>,
    /// Property [`SourceSecurityGroupName`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-security-group-ingress-sourcesecuritygroupname).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub source_security_group_name: Option<::Value<String>>,
    /// Property [`SourceSecurityGroupOwnerId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-security-group-ingress-sourcesecuritygroupownerid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub source_security_group_owner_id: Option<::Value<String>>,
    /// Property [`ToPort`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-security-group-ingress-toport).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub to_port: Option<::Value<u32>>,
}

impl ::serde::Serialize for SecurityGroupIngressProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref cidr_ip) = self.cidr_ip {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "CidrIp", cidr_ip)?;
        }
        if let Some(ref cidr_ipv6) = self.cidr_ipv6 {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "CidrIpv6", cidr_ipv6)?;
        }
        if let Some(ref description) = self.description {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Description", description)?;
        }
        if let Some(ref from_port) = self.from_port {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "FromPort", from_port)?;
        }
        if let Some(ref group_id) = self.group_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "GroupId", group_id)?;
        }
        if let Some(ref group_name) = self.group_name {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "GroupName", group_name)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "IpProtocol", &self.ip_protocol)?;
        if let Some(ref source_prefix_list_id) = self.source_prefix_list_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SourcePrefixListId", source_prefix_list_id)?;
        }
        if let Some(ref source_security_group_id) = self.source_security_group_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SourceSecurityGroupId", source_security_group_id)?;
        }
        if let Some(ref source_security_group_name) = self.source_security_group_name {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SourceSecurityGroupName", source_security_group_name)?;
        }
        if let Some(ref source_security_group_owner_id) = self.source_security_group_owner_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SourceSecurityGroupOwnerId", source_security_group_owner_id)?;
        }
        if let Some(ref to_port) = self.to_port {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "ToPort", to_port)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for SecurityGroupIngressProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<SecurityGroupIngressProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = SecurityGroupIngressProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type SecurityGroupIngressProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut cidr_ip: Option<::Value<String>> = None;
                let mut cidr_ipv6: Option<::Value<String>> = None;
                let mut description: Option<::Value<String>> = None;
                let mut from_port: Option<::Value<u32>> = None;
                let mut group_id: Option<::Value<String>> = None;
                let mut group_name: Option<::Value<String>> = None;
                let mut ip_protocol: Option<::Value<String>> = None;
                let mut source_prefix_list_id: Option<::Value<String>> = None;
                let mut source_security_group_id: Option<::Value<String>> = None;
                let mut source_security_group_name: Option<::Value<String>> = None;
                let mut source_security_group_owner_id: Option<::Value<String>> = None;
                let mut to_port: Option<::Value<u32>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "CidrIp" => {
                            cidr_ip = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "CidrIpv6" => {
                            cidr_ipv6 = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Description" => {
                            description = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "FromPort" => {
                            from_port = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "GroupId" => {
                            group_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "GroupName" => {
                            group_name = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "IpProtocol" => {
                            ip_protocol = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SourcePrefixListId" => {
                            source_prefix_list_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SourceSecurityGroupId" => {
                            source_security_group_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SourceSecurityGroupName" => {
                            source_security_group_name = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SourceSecurityGroupOwnerId" => {
                            source_security_group_owner_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "ToPort" => {
                            to_port = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(SecurityGroupIngressProperties {
                    cidr_ip: cidr_ip,
                    cidr_ipv6: cidr_ipv6,
                    description: description,
                    from_port: from_port,
                    group_id: group_id,
                    group_name: group_name,
                    ip_protocol: ip_protocol.ok_or(::serde::de::Error::missing_field("IpProtocol"))?,
                    source_prefix_list_id: source_prefix_list_id,
                    source_security_group_id: source_security_group_id,
                    source_security_group_name: source_security_group_name,
                    source_security_group_owner_id: source_security_group_owner_id,
                    to_port: to_port,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for SecurityGroupIngress {
    type Properties = SecurityGroupIngressProperties;
    const TYPE: &'static str = "AWS::EC2::SecurityGroupIngress";
    fn properties(&self) -> &SecurityGroupIngressProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut SecurityGroupIngressProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for SecurityGroupIngress {}

impl From<SecurityGroupIngressProperties> for SecurityGroupIngress {
    fn from(properties: SecurityGroupIngressProperties) -> SecurityGroupIngress {
        SecurityGroupIngress { properties }
    }
}

/// The [`AWS::EC2::SnapshotBlockPublicAccess`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-snapshotblockpublicaccess.html) resource type.
#[derive(Debug, Default)]
pub struct SnapshotBlockPublicAccess {
    properties: SnapshotBlockPublicAccessProperties
}

/// Properties for the `SnapshotBlockPublicAccess` resource.
#[derive(Debug, Default)]
pub struct SnapshotBlockPublicAccessProperties {
    /// Property [`State`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-snapshotblockpublicaccess.html#cfn-ec2-snapshotblockpublicaccess-state).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub state: ::Value<String>,
}

impl ::serde::Serialize for SnapshotBlockPublicAccessProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "State", &self.state)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for SnapshotBlockPublicAccessProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<SnapshotBlockPublicAccessProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = SnapshotBlockPublicAccessProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type SnapshotBlockPublicAccessProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut state: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "State" => {
                            state = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(SnapshotBlockPublicAccessProperties {
                    state: state.ok_or(::serde::de::Error::missing_field("State"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for SnapshotBlockPublicAccess {
    type Properties = SnapshotBlockPublicAccessProperties;
    const TYPE: &'static str = "AWS::EC2::SnapshotBlockPublicAccess";
    fn properties(&self) -> &SnapshotBlockPublicAccessProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut SnapshotBlockPublicAccessProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for SnapshotBlockPublicAccess {}

impl From<SnapshotBlockPublicAccessProperties> for SnapshotBlockPublicAccess {
    fn from(properties: SnapshotBlockPublicAccessProperties) -> SnapshotBlockPublicAccess {
        SnapshotBlockPublicAccess { properties }
    }
}

/// The [`AWS::EC2::SpotFleet`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-spotfleet.html) resource type.
#[derive(Debug, Default)]
pub struct SpotFleet {
    properties: SpotFleetProperties
}

/// Properties for the `SpotFleet` resource.
#[derive(Debug, Default)]
pub struct SpotFleetProperties {
    /// Property [`SpotFleetRequestConfigData`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-spotfleet.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub spot_fleet_request_config_data: ::Value<self::spot_fleet::SpotFleetRequestConfigData>,
}

impl ::serde::Serialize for SpotFleetProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "SpotFleetRequestConfigData", &self.spot_fleet_request_config_data)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for SpotFleetProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<SpotFleetProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = SpotFleetProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type SpotFleetProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut spot_fleet_request_config_data: Option<::Value<self::spot_fleet::SpotFleetRequestConfigData>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "SpotFleetRequestConfigData" => {
                            spot_fleet_request_config_data = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(SpotFleetProperties {
                    spot_fleet_request_config_data: spot_fleet_request_config_data.ok_or(::serde::de::Error::missing_field("SpotFleetRequestConfigData"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for SpotFleet {
    type Properties = SpotFleetProperties;
    const TYPE: &'static str = "AWS::EC2::SpotFleet";
    fn properties(&self) -> &SpotFleetProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut SpotFleetProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for SpotFleet {}

impl From<SpotFleetProperties> for SpotFleet {
    fn from(properties: SpotFleetProperties) -> SpotFleet {
        SpotFleet { properties }
    }
}

/// The [`AWS::EC2::Subnet`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html) resource type.
#[derive(Debug, Default)]
pub struct Subnet {
    properties: SubnetProperties
}

/// Properties for the `Subnet` resource.
#[derive(Debug, Default)]
pub struct SubnetProperties {
    /// Property [`AssignIpv6AddressOnCreation`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-assignipv6addressoncreation).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub assign_ipv6_address_on_creation: Option<::Value<bool>>,
    /// Property [`AvailabilityZone`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-availabilityzone).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub availability_zone: Option<::Value<String>>,
    /// Property [`AvailabilityZoneId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-availabilityzoneid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub availability_zone_id: Option<::Value<String>>,
    /// Property [`CidrBlock`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-cidrblock).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub cidr_block: Option<::Value<String>>,
    /// Property [`EnableDns64`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-enabledns64).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub enable_dns64: Option<::Value<bool>>,
    /// Property [`Ipv4IpamPoolId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-ipv4ipampoolid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub ipv4_ipam_pool_id: Option<::Value<String>>,
    /// Property [`Ipv4NetmaskLength`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-ipv4netmasklength).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub ipv4_netmask_length: Option<::Value<u32>>,
    /// Property [`Ipv6CidrBlock`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-ipv6cidrblock).
    ///
    /// Update type: _Conditional_.
    /// Conditional updates can be mutable or immutable, depending on, for example, which other properties you updated.
    /// For more information, see the relevant resource type documentation.
    pub ipv6_cidr_block: Option<::Value<String>>,
    /// Property [`Ipv6CidrBlocks`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-ipv6cidrblocks).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub ipv6_cidr_blocks: Option<::ValueList<String>>,
    /// Property [`Ipv6IpamPoolId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-ipv6ipampoolid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub ipv6_ipam_pool_id: Option<::Value<String>>,
    /// Property [`Ipv6Native`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-ipv6native).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub ipv6_native: Option<::Value<bool>>,
    /// Property [`Ipv6NetmaskLength`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-ipv6netmasklength).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub ipv6_netmask_length: Option<::Value<u32>>,
    /// Property [`MapPublicIpOnLaunch`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-mappubliciponlaunch).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub map_public_ip_on_launch: Option<::Value<bool>>,
    /// Property [`OutpostArn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-outpostarn).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub outpost_arn: Option<::Value<String>>,
    /// Property [`PrivateDnsNameOptionsOnLaunch`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-privatednsnameoptionsonlaunch).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub private_dns_name_options_on_launch: Option<::Value<self::subnet::PrivateDnsNameOptionsOnLaunch>>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
    /// Property [`VpcId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-vpcid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub vpc_id: ::Value<String>,
}

impl ::serde::Serialize for SubnetProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref assign_ipv6_address_on_creation) = self.assign_ipv6_address_on_creation {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "AssignIpv6AddressOnCreation", assign_ipv6_address_on_creation)?;
        }
        if let Some(ref availability_zone) = self.availability_zone {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "AvailabilityZone", availability_zone)?;
        }
        if let Some(ref availability_zone_id) = self.availability_zone_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "AvailabilityZoneId", availability_zone_id)?;
        }
        if let Some(ref cidr_block) = self.cidr_block {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "CidrBlock", cidr_block)?;
        }
        if let Some(ref enable_dns64) = self.enable_dns64 {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "EnableDns64", enable_dns64)?;
        }
        if let Some(ref ipv4_ipam_pool_id) = self.ipv4_ipam_pool_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv4IpamPoolId", ipv4_ipam_pool_id)?;
        }
        if let Some(ref ipv4_netmask_length) = self.ipv4_netmask_length {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv4NetmaskLength", ipv4_netmask_length)?;
        }
        if let Some(ref ipv6_cidr_block) = self.ipv6_cidr_block {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6CidrBlock", ipv6_cidr_block)?;
        }
        if let Some(ref ipv6_cidr_blocks) = self.ipv6_cidr_blocks {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6CidrBlocks", ipv6_cidr_blocks)?;
        }
        if let Some(ref ipv6_ipam_pool_id) = self.ipv6_ipam_pool_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6IpamPoolId", ipv6_ipam_pool_id)?;
        }
        if let Some(ref ipv6_native) = self.ipv6_native {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6Native", ipv6_native)?;
        }
        if let Some(ref ipv6_netmask_length) = self.ipv6_netmask_length {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6NetmaskLength", ipv6_netmask_length)?;
        }
        if let Some(ref map_public_ip_on_launch) = self.map_public_ip_on_launch {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "MapPublicIpOnLaunch", map_public_ip_on_launch)?;
        }
        if let Some(ref outpost_arn) = self.outpost_arn {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "OutpostArn", outpost_arn)?;
        }
        if let Some(ref private_dns_name_options_on_launch) = self.private_dns_name_options_on_launch {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "PrivateDnsNameOptionsOnLaunch", private_dns_name_options_on_launch)?;
        }
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "VpcId", &self.vpc_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for SubnetProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<SubnetProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = SubnetProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type SubnetProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut assign_ipv6_address_on_creation: Option<::Value<bool>> = None;
                let mut availability_zone: Option<::Value<String>> = None;
                let mut availability_zone_id: Option<::Value<String>> = None;
                let mut cidr_block: Option<::Value<String>> = None;
                let mut enable_dns64: Option<::Value<bool>> = None;
                let mut ipv4_ipam_pool_id: Option<::Value<String>> = None;
                let mut ipv4_netmask_length: Option<::Value<u32>> = None;
                let mut ipv6_cidr_block: Option<::Value<String>> = None;
                let mut ipv6_cidr_blocks: Option<::ValueList<String>> = None;
                let mut ipv6_ipam_pool_id: Option<::Value<String>> = None;
                let mut ipv6_native: Option<::Value<bool>> = None;
                let mut ipv6_netmask_length: Option<::Value<u32>> = None;
                let mut map_public_ip_on_launch: Option<::Value<bool>> = None;
                let mut outpost_arn: Option<::Value<String>> = None;
                let mut private_dns_name_options_on_launch: Option<::Value<self::subnet::PrivateDnsNameOptionsOnLaunch>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;
                let mut vpc_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "AssignIpv6AddressOnCreation" => {
                            assign_ipv6_address_on_creation = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "AvailabilityZone" => {
                            availability_zone = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "AvailabilityZoneId" => {
                            availability_zone_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "CidrBlock" => {
                            cidr_block = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "EnableDns64" => {
                            enable_dns64 = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Ipv4IpamPoolId" => {
                            ipv4_ipam_pool_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Ipv4NetmaskLength" => {
                            ipv4_netmask_length = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Ipv6CidrBlock" => {
                            ipv6_cidr_block = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Ipv6CidrBlocks" => {
                            ipv6_cidr_blocks = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Ipv6IpamPoolId" => {
                            ipv6_ipam_pool_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Ipv6Native" => {
                            ipv6_native = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Ipv6NetmaskLength" => {
                            ipv6_netmask_length = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "MapPublicIpOnLaunch" => {
                            map_public_ip_on_launch = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "OutpostArn" => {
                            outpost_arn = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "PrivateDnsNameOptionsOnLaunch" => {
                            private_dns_name_options_on_launch = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "VpcId" => {
                            vpc_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(SubnetProperties {
                    assign_ipv6_address_on_creation: assign_ipv6_address_on_creation,
                    availability_zone: availability_zone,
                    availability_zone_id: availability_zone_id,
                    cidr_block: cidr_block,
                    enable_dns64: enable_dns64,
                    ipv4_ipam_pool_id: ipv4_ipam_pool_id,
                    ipv4_netmask_length: ipv4_netmask_length,
                    ipv6_cidr_block: ipv6_cidr_block,
                    ipv6_cidr_blocks: ipv6_cidr_blocks,
                    ipv6_ipam_pool_id: ipv6_ipam_pool_id,
                    ipv6_native: ipv6_native,
                    ipv6_netmask_length: ipv6_netmask_length,
                    map_public_ip_on_launch: map_public_ip_on_launch,
                    outpost_arn: outpost_arn,
                    private_dns_name_options_on_launch: private_dns_name_options_on_launch,
                    tags: tags,
                    vpc_id: vpc_id.ok_or(::serde::de::Error::missing_field("VpcId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for Subnet {
    type Properties = SubnetProperties;
    const TYPE: &'static str = "AWS::EC2::Subnet";
    fn properties(&self) -> &SubnetProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut SubnetProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for Subnet {}

impl From<SubnetProperties> for Subnet {
    fn from(properties: SubnetProperties) -> Subnet {
        Subnet { properties }
    }
}

/// The [`AWS::EC2::SubnetCidrBlock`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetcidrblock.html) resource type.
#[derive(Debug, Default)]
pub struct SubnetCidrBlock {
    properties: SubnetCidrBlockProperties
}

/// Properties for the `SubnetCidrBlock` resource.
#[derive(Debug, Default)]
pub struct SubnetCidrBlockProperties {
    /// Property [`Ipv6CidrBlock`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetcidrblock.html#cfn-ec2-subnetcidrblock-ipv6cidrblock).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub ipv6_cidr_block: Option<::Value<String>>,
    /// Property [`Ipv6IpamPoolId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetcidrblock.html#cfn-ec2-subnetcidrblock-ipv6ipampoolid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub ipv6_ipam_pool_id: Option<::Value<String>>,
    /// Property [`Ipv6NetmaskLength`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetcidrblock.html#cfn-ec2-subnetcidrblock-ipv6netmasklength).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub ipv6_netmask_length: Option<::Value<u32>>,
    /// Property [`SubnetId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetcidrblock.html#cfn-ec2-subnetcidrblock-subnetid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub subnet_id: ::Value<String>,
}

impl ::serde::Serialize for SubnetCidrBlockProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref ipv6_cidr_block) = self.ipv6_cidr_block {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6CidrBlock", ipv6_cidr_block)?;
        }
        if let Some(ref ipv6_ipam_pool_id) = self.ipv6_ipam_pool_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6IpamPoolId", ipv6_ipam_pool_id)?;
        }
        if let Some(ref ipv6_netmask_length) = self.ipv6_netmask_length {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6NetmaskLength", ipv6_netmask_length)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "SubnetId", &self.subnet_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for SubnetCidrBlockProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<SubnetCidrBlockProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = SubnetCidrBlockProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type SubnetCidrBlockProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut ipv6_cidr_block: Option<::Value<String>> = None;
                let mut ipv6_ipam_pool_id: Option<::Value<String>> = None;
                let mut ipv6_netmask_length: Option<::Value<u32>> = None;
                let mut subnet_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "Ipv6CidrBlock" => {
                            ipv6_cidr_block = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Ipv6IpamPoolId" => {
                            ipv6_ipam_pool_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Ipv6NetmaskLength" => {
                            ipv6_netmask_length = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SubnetId" => {
                            subnet_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(SubnetCidrBlockProperties {
                    ipv6_cidr_block: ipv6_cidr_block,
                    ipv6_ipam_pool_id: ipv6_ipam_pool_id,
                    ipv6_netmask_length: ipv6_netmask_length,
                    subnet_id: subnet_id.ok_or(::serde::de::Error::missing_field("SubnetId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for SubnetCidrBlock {
    type Properties = SubnetCidrBlockProperties;
    const TYPE: &'static str = "AWS::EC2::SubnetCidrBlock";
    fn properties(&self) -> &SubnetCidrBlockProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut SubnetCidrBlockProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for SubnetCidrBlock {}

impl From<SubnetCidrBlockProperties> for SubnetCidrBlock {
    fn from(properties: SubnetCidrBlockProperties) -> SubnetCidrBlock {
        SubnetCidrBlock { properties }
    }
}

/// The [`AWS::EC2::SubnetNetworkAclAssociation`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetnetworkaclassociation.html) resource type.
#[derive(Debug, Default)]
pub struct SubnetNetworkAclAssociation {
    properties: SubnetNetworkAclAssociationProperties
}

/// Properties for the `SubnetNetworkAclAssociation` resource.
#[derive(Debug, Default)]
pub struct SubnetNetworkAclAssociationProperties {
    /// Property [`NetworkAclId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetnetworkaclassociation.html#cfn-ec2-subnetnetworkaclassociation-networkaclid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub network_acl_id: ::Value<String>,
    /// Property [`SubnetId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetnetworkaclassociation.html#cfn-ec2-subnetnetworkaclassociation-subnetid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub subnet_id: ::Value<String>,
}

impl ::serde::Serialize for SubnetNetworkAclAssociationProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetworkAclId", &self.network_acl_id)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "SubnetId", &self.subnet_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for SubnetNetworkAclAssociationProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<SubnetNetworkAclAssociationProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = SubnetNetworkAclAssociationProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type SubnetNetworkAclAssociationProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut network_acl_id: Option<::Value<String>> = None;
                let mut subnet_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "NetworkAclId" => {
                            network_acl_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SubnetId" => {
                            subnet_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(SubnetNetworkAclAssociationProperties {
                    network_acl_id: network_acl_id.ok_or(::serde::de::Error::missing_field("NetworkAclId"))?,
                    subnet_id: subnet_id.ok_or(::serde::de::Error::missing_field("SubnetId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for SubnetNetworkAclAssociation {
    type Properties = SubnetNetworkAclAssociationProperties;
    const TYPE: &'static str = "AWS::EC2::SubnetNetworkAclAssociation";
    fn properties(&self) -> &SubnetNetworkAclAssociationProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut SubnetNetworkAclAssociationProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for SubnetNetworkAclAssociation {}

impl From<SubnetNetworkAclAssociationProperties> for SubnetNetworkAclAssociation {
    fn from(properties: SubnetNetworkAclAssociationProperties) -> SubnetNetworkAclAssociation {
        SubnetNetworkAclAssociation { properties }
    }
}

/// The [`AWS::EC2::SubnetRouteTableAssociation`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetroutetableassociation.html) resource type.
#[derive(Debug, Default)]
pub struct SubnetRouteTableAssociation {
    properties: SubnetRouteTableAssociationProperties
}

/// Properties for the `SubnetRouteTableAssociation` resource.
#[derive(Debug, Default)]
pub struct SubnetRouteTableAssociationProperties {
    /// Property [`RouteTableId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetroutetableassociation.html#cfn-ec2-subnetroutetableassociation-routetableid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub route_table_id: ::Value<String>,
    /// Property [`SubnetId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetroutetableassociation.html#cfn-ec2-subnetroutetableassociation-subnetid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub subnet_id: ::Value<String>,
}

impl ::serde::Serialize for SubnetRouteTableAssociationProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "RouteTableId", &self.route_table_id)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "SubnetId", &self.subnet_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for SubnetRouteTableAssociationProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<SubnetRouteTableAssociationProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = SubnetRouteTableAssociationProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type SubnetRouteTableAssociationProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut route_table_id: Option<::Value<String>> = None;
                let mut subnet_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "RouteTableId" => {
                            route_table_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SubnetId" => {
                            subnet_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(SubnetRouteTableAssociationProperties {
                    route_table_id: route_table_id.ok_or(::serde::de::Error::missing_field("RouteTableId"))?,
                    subnet_id: subnet_id.ok_or(::serde::de::Error::missing_field("SubnetId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for SubnetRouteTableAssociation {
    type Properties = SubnetRouteTableAssociationProperties;
    const TYPE: &'static str = "AWS::EC2::SubnetRouteTableAssociation";
    fn properties(&self) -> &SubnetRouteTableAssociationProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut SubnetRouteTableAssociationProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for SubnetRouteTableAssociation {}

impl From<SubnetRouteTableAssociationProperties> for SubnetRouteTableAssociation {
    fn from(properties: SubnetRouteTableAssociationProperties) -> SubnetRouteTableAssociation {
        SubnetRouteTableAssociation { properties }
    }
}

/// The [`AWS::EC2::TrafficMirrorFilter`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html) resource type.
#[derive(Debug, Default)]
pub struct TrafficMirrorFilter {
    properties: TrafficMirrorFilterProperties
}

/// Properties for the `TrafficMirrorFilter` resource.
#[derive(Debug, Default)]
pub struct TrafficMirrorFilterProperties {
    /// Property [`Description`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html#cfn-ec2-trafficmirrorfilter-description).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub description: Option<::Value<String>>,
    /// Property [`NetworkServices`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html#cfn-ec2-trafficmirrorfilter-networkservices).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub network_services: Option<::ValueList<String>>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html#cfn-ec2-trafficmirrorfilter-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
}

impl ::serde::Serialize for TrafficMirrorFilterProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref description) = self.description {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Description", description)?;
        }
        if let Some(ref network_services) = self.network_services {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetworkServices", network_services)?;
        }
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for TrafficMirrorFilterProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<TrafficMirrorFilterProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = TrafficMirrorFilterProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type TrafficMirrorFilterProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut description: Option<::Value<String>> = None;
                let mut network_services: Option<::ValueList<String>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "Description" => {
                            description = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "NetworkServices" => {
                            network_services = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(TrafficMirrorFilterProperties {
                    description: description,
                    network_services: network_services,
                    tags: tags,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for TrafficMirrorFilter {
    type Properties = TrafficMirrorFilterProperties;
    const TYPE: &'static str = "AWS::EC2::TrafficMirrorFilter";
    fn properties(&self) -> &TrafficMirrorFilterProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut TrafficMirrorFilterProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for TrafficMirrorFilter {}

impl From<TrafficMirrorFilterProperties> for TrafficMirrorFilter {
    fn from(properties: TrafficMirrorFilterProperties) -> TrafficMirrorFilter {
        TrafficMirrorFilter { properties }
    }
}

/// The [`AWS::EC2::TrafficMirrorFilterRule`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html) resource type.
#[derive(Debug, Default)]
pub struct TrafficMirrorFilterRule {
    properties: TrafficMirrorFilterRuleProperties
}

/// Properties for the `TrafficMirrorFilterRule` resource.
#[derive(Debug, Default)]
pub struct TrafficMirrorFilterRuleProperties {
    /// Property [`Description`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-description).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub description: Option<::Value<String>>,
    /// Property [`DestinationCidrBlock`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-destinationcidrblock).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub destination_cidr_block: ::Value<String>,
    /// Property [`DestinationPortRange`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-destinationportrange).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub destination_port_range: Option<::Value<self::traffic_mirror_filter_rule::TrafficMirrorPortRange>>,
    /// Property [`Protocol`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-protocol).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub protocol: Option<::Value<u32>>,
    /// Property [`RuleAction`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-ruleaction).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub rule_action: ::Value<String>,
    /// Property [`RuleNumber`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-rulenumber).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub rule_number: ::Value<u32>,
    /// Property [`SourceCidrBlock`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-sourcecidrblock).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub source_cidr_block: ::Value<String>,
    /// Property [`SourcePortRange`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-sourceportrange).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub source_port_range: Option<::Value<self::traffic_mirror_filter_rule::TrafficMirrorPortRange>>,
    /// Property [`TrafficDirection`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-trafficdirection).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub traffic_direction: ::Value<String>,
    /// Property [`TrafficMirrorFilterId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-trafficmirrorfilterid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub traffic_mirror_filter_id: ::Value<String>,
}

impl ::serde::Serialize for TrafficMirrorFilterRuleProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref description) = self.description {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Description", description)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "DestinationCidrBlock", &self.destination_cidr_block)?;
        if let Some(ref destination_port_range) = self.destination_port_range {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "DestinationPortRange", destination_port_range)?;
        }
        if let Some(ref protocol) = self.protocol {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Protocol", protocol)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "RuleAction", &self.rule_action)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "RuleNumber", &self.rule_number)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "SourceCidrBlock", &self.source_cidr_block)?;
        if let Some(ref source_port_range) = self.source_port_range {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SourcePortRange", source_port_range)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "TrafficDirection", &self.traffic_direction)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "TrafficMirrorFilterId", &self.traffic_mirror_filter_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for TrafficMirrorFilterRuleProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<TrafficMirrorFilterRuleProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = TrafficMirrorFilterRuleProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type TrafficMirrorFilterRuleProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut description: Option<::Value<String>> = None;
                let mut destination_cidr_block: Option<::Value<String>> = None;
                let mut destination_port_range: Option<::Value<self::traffic_mirror_filter_rule::TrafficMirrorPortRange>> = None;
                let mut protocol: Option<::Value<u32>> = None;
                let mut rule_action: Option<::Value<String>> = None;
                let mut rule_number: Option<::Value<u32>> = None;
                let mut source_cidr_block: Option<::Value<String>> = None;
                let mut source_port_range: Option<::Value<self::traffic_mirror_filter_rule::TrafficMirrorPortRange>> = None;
                let mut traffic_direction: Option<::Value<String>> = None;
                let mut traffic_mirror_filter_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "Description" => {
                            description = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "DestinationCidrBlock" => {
                            destination_cidr_block = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "DestinationPortRange" => {
                            destination_port_range = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Protocol" => {
                            protocol = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "RuleAction" => {
                            rule_action = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "RuleNumber" => {
                            rule_number = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SourceCidrBlock" => {
                            source_cidr_block = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SourcePortRange" => {
                            source_port_range = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TrafficDirection" => {
                            traffic_direction = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TrafficMirrorFilterId" => {
                            traffic_mirror_filter_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(TrafficMirrorFilterRuleProperties {
                    description: description,
                    destination_cidr_block: destination_cidr_block.ok_or(::serde::de::Error::missing_field("DestinationCidrBlock"))?,
                    destination_port_range: destination_port_range,
                    protocol: protocol,
                    rule_action: rule_action.ok_or(::serde::de::Error::missing_field("RuleAction"))?,
                    rule_number: rule_number.ok_or(::serde::de::Error::missing_field("RuleNumber"))?,
                    source_cidr_block: source_cidr_block.ok_or(::serde::de::Error::missing_field("SourceCidrBlock"))?,
                    source_port_range: source_port_range,
                    traffic_direction: traffic_direction.ok_or(::serde::de::Error::missing_field("TrafficDirection"))?,
                    traffic_mirror_filter_id: traffic_mirror_filter_id.ok_or(::serde::de::Error::missing_field("TrafficMirrorFilterId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for TrafficMirrorFilterRule {
    type Properties = TrafficMirrorFilterRuleProperties;
    const TYPE: &'static str = "AWS::EC2::TrafficMirrorFilterRule";
    fn properties(&self) -> &TrafficMirrorFilterRuleProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut TrafficMirrorFilterRuleProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for TrafficMirrorFilterRule {}

impl From<TrafficMirrorFilterRuleProperties> for TrafficMirrorFilterRule {
    fn from(properties: TrafficMirrorFilterRuleProperties) -> TrafficMirrorFilterRule {
        TrafficMirrorFilterRule { properties }
    }
}

/// The [`AWS::EC2::TrafficMirrorSession`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html) resource type.
#[derive(Debug, Default)]
pub struct TrafficMirrorSession {
    properties: TrafficMirrorSessionProperties
}

/// Properties for the `TrafficMirrorSession` resource.
#[derive(Debug, Default)]
pub struct TrafficMirrorSessionProperties {
    /// Property [`Description`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-description).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub description: Option<::Value<String>>,
    /// Property [`NetworkInterfaceId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-networkinterfaceid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub network_interface_id: ::Value<String>,
    /// Property [`PacketLength`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-packetlength).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub packet_length: Option<::Value<u32>>,
    /// Property [`SessionNumber`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-sessionnumber).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub session_number: ::Value<u32>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
    /// Property [`TrafficMirrorFilterId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-trafficmirrorfilterid).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub traffic_mirror_filter_id: ::Value<String>,
    /// Property [`TrafficMirrorTargetId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-trafficmirrortargetid).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub traffic_mirror_target_id: ::Value<String>,
    /// Property [`VirtualNetworkId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-virtualnetworkid).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub virtual_network_id: Option<::Value<u32>>,
}

impl ::serde::Serialize for TrafficMirrorSessionProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref description) = self.description {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Description", description)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetworkInterfaceId", &self.network_interface_id)?;
        if let Some(ref packet_length) = self.packet_length {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "PacketLength", packet_length)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "SessionNumber", &self.session_number)?;
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "TrafficMirrorFilterId", &self.traffic_mirror_filter_id)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "TrafficMirrorTargetId", &self.traffic_mirror_target_id)?;
        if let Some(ref virtual_network_id) = self.virtual_network_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "VirtualNetworkId", virtual_network_id)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for TrafficMirrorSessionProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<TrafficMirrorSessionProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = TrafficMirrorSessionProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type TrafficMirrorSessionProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut description: Option<::Value<String>> = None;
                let mut network_interface_id: Option<::Value<String>> = None;
                let mut packet_length: Option<::Value<u32>> = None;
                let mut session_number: Option<::Value<u32>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;
                let mut traffic_mirror_filter_id: Option<::Value<String>> = None;
                let mut traffic_mirror_target_id: Option<::Value<String>> = None;
                let mut virtual_network_id: Option<::Value<u32>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "Description" => {
                            description = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "NetworkInterfaceId" => {
                            network_interface_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "PacketLength" => {
                            packet_length = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SessionNumber" => {
                            session_number = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TrafficMirrorFilterId" => {
                            traffic_mirror_filter_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TrafficMirrorTargetId" => {
                            traffic_mirror_target_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "VirtualNetworkId" => {
                            virtual_network_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(TrafficMirrorSessionProperties {
                    description: description,
                    network_interface_id: network_interface_id.ok_or(::serde::de::Error::missing_field("NetworkInterfaceId"))?,
                    packet_length: packet_length,
                    session_number: session_number.ok_or(::serde::de::Error::missing_field("SessionNumber"))?,
                    tags: tags,
                    traffic_mirror_filter_id: traffic_mirror_filter_id.ok_or(::serde::de::Error::missing_field("TrafficMirrorFilterId"))?,
                    traffic_mirror_target_id: traffic_mirror_target_id.ok_or(::serde::de::Error::missing_field("TrafficMirrorTargetId"))?,
                    virtual_network_id: virtual_network_id,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for TrafficMirrorSession {
    type Properties = TrafficMirrorSessionProperties;
    const TYPE: &'static str = "AWS::EC2::TrafficMirrorSession";
    fn properties(&self) -> &TrafficMirrorSessionProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut TrafficMirrorSessionProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for TrafficMirrorSession {}

impl From<TrafficMirrorSessionProperties> for TrafficMirrorSession {
    fn from(properties: TrafficMirrorSessionProperties) -> TrafficMirrorSession {
        TrafficMirrorSession { properties }
    }
}

/// The [`AWS::EC2::TrafficMirrorTarget`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html) resource type.
#[derive(Debug, Default)]
pub struct TrafficMirrorTarget {
    properties: TrafficMirrorTargetProperties
}

/// Properties for the `TrafficMirrorTarget` resource.
#[derive(Debug, Default)]
pub struct TrafficMirrorTargetProperties {
    /// Property [`Description`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-description).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub description: Option<::Value<String>>,
    /// Property [`GatewayLoadBalancerEndpointId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-gatewayloadbalancerendpointid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub gateway_load_balancer_endpoint_id: Option<::Value<String>>,
    /// Property [`NetworkInterfaceId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-networkinterfaceid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub network_interface_id: Option<::Value<String>>,
    /// Property [`NetworkLoadBalancerArn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-networkloadbalancerarn).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub network_load_balancer_arn: Option<::Value<String>>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
}

impl ::serde::Serialize for TrafficMirrorTargetProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref description) = self.description {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Description", description)?;
        }
        if let Some(ref gateway_load_balancer_endpoint_id) = self.gateway_load_balancer_endpoint_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "GatewayLoadBalancerEndpointId", gateway_load_balancer_endpoint_id)?;
        }
        if let Some(ref network_interface_id) = self.network_interface_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetworkInterfaceId", network_interface_id)?;
        }
        if let Some(ref network_load_balancer_arn) = self.network_load_balancer_arn {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetworkLoadBalancerArn", network_load_balancer_arn)?;
        }
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for TrafficMirrorTargetProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<TrafficMirrorTargetProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = TrafficMirrorTargetProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type TrafficMirrorTargetProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut description: Option<::Value<String>> = None;
                let mut gateway_load_balancer_endpoint_id: Option<::Value<String>> = None;
                let mut network_interface_id: Option<::Value<String>> = None;
                let mut network_load_balancer_arn: Option<::Value<String>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "Description" => {
                            description = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "GatewayLoadBalancerEndpointId" => {
                            gateway_load_balancer_endpoint_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "NetworkInterfaceId" => {
                            network_interface_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "NetworkLoadBalancerArn" => {
                            network_load_balancer_arn = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(TrafficMirrorTargetProperties {
                    description: description,
                    gateway_load_balancer_endpoint_id: gateway_load_balancer_endpoint_id,
                    network_interface_id: network_interface_id,
                    network_load_balancer_arn: network_load_balancer_arn,
                    tags: tags,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for TrafficMirrorTarget {
    type Properties = TrafficMirrorTargetProperties;
    const TYPE: &'static str = "AWS::EC2::TrafficMirrorTarget";
    fn properties(&self) -> &TrafficMirrorTargetProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut TrafficMirrorTargetProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for TrafficMirrorTarget {}

impl From<TrafficMirrorTargetProperties> for TrafficMirrorTarget {
    fn from(properties: TrafficMirrorTargetProperties) -> TrafficMirrorTarget {
        TrafficMirrorTarget { properties }
    }
}

/// The [`AWS::EC2::TransitGateway`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html) resource type.
#[derive(Debug, Default)]
pub struct TransitGateway {
    properties: TransitGatewayProperties
}

/// Properties for the `TransitGateway` resource.
#[derive(Debug, Default)]
pub struct TransitGatewayProperties {
    /// Property [`AmazonSideAsn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-amazonsideasn).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub amazon_side_asn: Option<::Value<u32>>,
    /// Property [`AssociationDefaultRouteTableId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-associationdefaultroutetableid).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub association_default_route_table_id: Option<::Value<String>>,
    /// Property [`AutoAcceptSharedAttachments`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-autoacceptsharedattachments).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub auto_accept_shared_attachments: Option<::Value<String>>,
    /// Property [`DefaultRouteTableAssociation`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-defaultroutetableassociation).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub default_route_table_association: Option<::Value<String>>,
    /// Property [`DefaultRouteTablePropagation`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-defaultroutetablepropagation).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub default_route_table_propagation: Option<::Value<String>>,
    /// Property [`Description`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-description).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub description: Option<::Value<String>>,
    /// Property [`DnsSupport`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-dnssupport).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub dns_support: Option<::Value<String>>,
    /// Property [`MulticastSupport`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-multicastsupport).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub multicast_support: Option<::Value<String>>,
    /// Property [`PropagationDefaultRouteTableId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-propagationdefaultroutetableid).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub propagation_default_route_table_id: Option<::Value<String>>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
    /// Property [`TransitGatewayCidrBlocks`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-transitgatewaycidrblocks).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub transit_gateway_cidr_blocks: Option<::ValueList<String>>,
    /// Property [`VpnEcmpSupport`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-vpnecmpsupport).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub vpn_ecmp_support: Option<::Value<String>>,
}

impl ::serde::Serialize for TransitGatewayProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref amazon_side_asn) = self.amazon_side_asn {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "AmazonSideAsn", amazon_side_asn)?;
        }
        if let Some(ref association_default_route_table_id) = self.association_default_route_table_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "AssociationDefaultRouteTableId", association_default_route_table_id)?;
        }
        if let Some(ref auto_accept_shared_attachments) = self.auto_accept_shared_attachments {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "AutoAcceptSharedAttachments", auto_accept_shared_attachments)?;
        }
        if let Some(ref default_route_table_association) = self.default_route_table_association {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "DefaultRouteTableAssociation", default_route_table_association)?;
        }
        if let Some(ref default_route_table_propagation) = self.default_route_table_propagation {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "DefaultRouteTablePropagation", default_route_table_propagation)?;
        }
        if let Some(ref description) = self.description {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Description", description)?;
        }
        if let Some(ref dns_support) = self.dns_support {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "DnsSupport", dns_support)?;
        }
        if let Some(ref multicast_support) = self.multicast_support {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "MulticastSupport", multicast_support)?;
        }
        if let Some(ref propagation_default_route_table_id) = self.propagation_default_route_table_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "PropagationDefaultRouteTableId", propagation_default_route_table_id)?;
        }
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        if let Some(ref transit_gateway_cidr_blocks) = self.transit_gateway_cidr_blocks {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "TransitGatewayCidrBlocks", transit_gateway_cidr_blocks)?;
        }
        if let Some(ref vpn_ecmp_support) = self.vpn_ecmp_support {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "VpnEcmpSupport", vpn_ecmp_support)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for TransitGatewayProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<TransitGatewayProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = TransitGatewayProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type TransitGatewayProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut amazon_side_asn: Option<::Value<u32>> = None;
                let mut association_default_route_table_id: Option<::Value<String>> = None;
                let mut auto_accept_shared_attachments: Option<::Value<String>> = None;
                let mut default_route_table_association: Option<::Value<String>> = None;
                let mut default_route_table_propagation: Option<::Value<String>> = None;
                let mut description: Option<::Value<String>> = None;
                let mut dns_support: Option<::Value<String>> = None;
                let mut multicast_support: Option<::Value<String>> = None;
                let mut propagation_default_route_table_id: Option<::Value<String>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;
                let mut transit_gateway_cidr_blocks: Option<::ValueList<String>> = None;
                let mut vpn_ecmp_support: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "AmazonSideAsn" => {
                            amazon_side_asn = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "AssociationDefaultRouteTableId" => {
                            association_default_route_table_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "AutoAcceptSharedAttachments" => {
                            auto_accept_shared_attachments = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "DefaultRouteTableAssociation" => {
                            default_route_table_association = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "DefaultRouteTablePropagation" => {
                            default_route_table_propagation = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Description" => {
                            description = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "DnsSupport" => {
                            dns_support = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "MulticastSupport" => {
                            multicast_support = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "PropagationDefaultRouteTableId" => {
                            propagation_default_route_table_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TransitGatewayCidrBlocks" => {
                            transit_gateway_cidr_blocks = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "VpnEcmpSupport" => {
                            vpn_ecmp_support = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(TransitGatewayProperties {
                    amazon_side_asn: amazon_side_asn,
                    association_default_route_table_id: association_default_route_table_id,
                    auto_accept_shared_attachments: auto_accept_shared_attachments,
                    default_route_table_association: default_route_table_association,
                    default_route_table_propagation: default_route_table_propagation,
                    description: description,
                    dns_support: dns_support,
                    multicast_support: multicast_support,
                    propagation_default_route_table_id: propagation_default_route_table_id,
                    tags: tags,
                    transit_gateway_cidr_blocks: transit_gateway_cidr_blocks,
                    vpn_ecmp_support: vpn_ecmp_support,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for TransitGateway {
    type Properties = TransitGatewayProperties;
    const TYPE: &'static str = "AWS::EC2::TransitGateway";
    fn properties(&self) -> &TransitGatewayProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut TransitGatewayProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for TransitGateway {}

impl From<TransitGatewayProperties> for TransitGateway {
    fn from(properties: TransitGatewayProperties) -> TransitGateway {
        TransitGateway { properties }
    }
}

/// The [`AWS::EC2::TransitGatewayAttachment`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html) resource type.
#[derive(Debug, Default)]
pub struct TransitGatewayAttachment {
    properties: TransitGatewayAttachmentProperties
}

/// Properties for the `TransitGatewayAttachment` resource.
#[derive(Debug, Default)]
pub struct TransitGatewayAttachmentProperties {
    /// Property [`Options`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-options).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub options: Option<::Value<self::transit_gateway_attachment::Options>>,
    /// Property [`SubnetIds`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-subnetids).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub subnet_ids: ::ValueList<String>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
    /// Property [`TransitGatewayId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-transitgatewayid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub transit_gateway_id: ::Value<String>,
    /// Property [`VpcId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-vpcid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub vpc_id: ::Value<String>,
}

impl ::serde::Serialize for TransitGatewayAttachmentProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref options) = self.options {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Options", options)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "SubnetIds", &self.subnet_ids)?;
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "TransitGatewayId", &self.transit_gateway_id)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "VpcId", &self.vpc_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for TransitGatewayAttachmentProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<TransitGatewayAttachmentProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = TransitGatewayAttachmentProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type TransitGatewayAttachmentProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut options: Option<::Value<self::transit_gateway_attachment::Options>> = None;
                let mut subnet_ids: Option<::ValueList<String>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;
                let mut transit_gateway_id: Option<::Value<String>> = None;
                let mut vpc_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "Options" => {
                            options = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SubnetIds" => {
                            subnet_ids = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TransitGatewayId" => {
                            transit_gateway_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "VpcId" => {
                            vpc_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(TransitGatewayAttachmentProperties {
                    options: options,
                    subnet_ids: subnet_ids.ok_or(::serde::de::Error::missing_field("SubnetIds"))?,
                    tags: tags,
                    transit_gateway_id: transit_gateway_id.ok_or(::serde::de::Error::missing_field("TransitGatewayId"))?,
                    vpc_id: vpc_id.ok_or(::serde::de::Error::missing_field("VpcId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for TransitGatewayAttachment {
    type Properties = TransitGatewayAttachmentProperties;
    const TYPE: &'static str = "AWS::EC2::TransitGatewayAttachment";
    fn properties(&self) -> &TransitGatewayAttachmentProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut TransitGatewayAttachmentProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for TransitGatewayAttachment {}

impl From<TransitGatewayAttachmentProperties> for TransitGatewayAttachment {
    fn from(properties: TransitGatewayAttachmentProperties) -> TransitGatewayAttachment {
        TransitGatewayAttachment { properties }
    }
}

/// The [`AWS::EC2::TransitGatewayConnect`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html) resource type.
#[derive(Debug, Default)]
pub struct TransitGatewayConnect {
    properties: TransitGatewayConnectProperties
}

/// Properties for the `TransitGatewayConnect` resource.
#[derive(Debug, Default)]
pub struct TransitGatewayConnectProperties {
    /// Property [`Options`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html#cfn-ec2-transitgatewayconnect-options).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub options: ::Value<self::transit_gateway_connect::TransitGatewayConnectOptions>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html#cfn-ec2-transitgatewayconnect-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
    /// Property [`TransportTransitGatewayAttachmentId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html#cfn-ec2-transitgatewayconnect-transporttransitgatewayattachmentid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub transport_transit_gateway_attachment_id: ::Value<String>,
}

impl ::serde::Serialize for TransitGatewayConnectProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "Options", &self.options)?;
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "TransportTransitGatewayAttachmentId", &self.transport_transit_gateway_attachment_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for TransitGatewayConnectProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<TransitGatewayConnectProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = TransitGatewayConnectProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type TransitGatewayConnectProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut options: Option<::Value<self::transit_gateway_connect::TransitGatewayConnectOptions>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;
                let mut transport_transit_gateway_attachment_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "Options" => {
                            options = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TransportTransitGatewayAttachmentId" => {
                            transport_transit_gateway_attachment_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(TransitGatewayConnectProperties {
                    options: options.ok_or(::serde::de::Error::missing_field("Options"))?,
                    tags: tags,
                    transport_transit_gateway_attachment_id: transport_transit_gateway_attachment_id.ok_or(::serde::de::Error::missing_field("TransportTransitGatewayAttachmentId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for TransitGatewayConnect {
    type Properties = TransitGatewayConnectProperties;
    const TYPE: &'static str = "AWS::EC2::TransitGatewayConnect";
    fn properties(&self) -> &TransitGatewayConnectProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut TransitGatewayConnectProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for TransitGatewayConnect {}

impl From<TransitGatewayConnectProperties> for TransitGatewayConnect {
    fn from(properties: TransitGatewayConnectProperties) -> TransitGatewayConnect {
        TransitGatewayConnect { properties }
    }
}

/// The [`AWS::EC2::TransitGatewayMulticastDomain`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html) resource type.
#[derive(Debug, Default)]
pub struct TransitGatewayMulticastDomain {
    properties: TransitGatewayMulticastDomainProperties
}

/// Properties for the `TransitGatewayMulticastDomain` resource.
#[derive(Debug, Default)]
pub struct TransitGatewayMulticastDomainProperties {
    /// Property [`Options`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html#cfn-ec2-transitgatewaymulticastdomain-options).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub options: Option<::Value<self::transit_gateway_multicast_domain::Options>>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html#cfn-ec2-transitgatewaymulticastdomain-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
    /// Property [`TransitGatewayId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html#cfn-ec2-transitgatewaymulticastdomain-transitgatewayid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub transit_gateway_id: ::Value<String>,
}

impl ::serde::Serialize for TransitGatewayMulticastDomainProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref options) = self.options {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Options", options)?;
        }
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "TransitGatewayId", &self.transit_gateway_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for TransitGatewayMulticastDomainProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<TransitGatewayMulticastDomainProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = TransitGatewayMulticastDomainProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type TransitGatewayMulticastDomainProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut options: Option<::Value<self::transit_gateway_multicast_domain::Options>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;
                let mut transit_gateway_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "Options" => {
                            options = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TransitGatewayId" => {
                            transit_gateway_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(TransitGatewayMulticastDomainProperties {
                    options: options,
                    tags: tags,
                    transit_gateway_id: transit_gateway_id.ok_or(::serde::de::Error::missing_field("TransitGatewayId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for TransitGatewayMulticastDomain {
    type Properties = TransitGatewayMulticastDomainProperties;
    const TYPE: &'static str = "AWS::EC2::TransitGatewayMulticastDomain";
    fn properties(&self) -> &TransitGatewayMulticastDomainProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut TransitGatewayMulticastDomainProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for TransitGatewayMulticastDomain {}

impl From<TransitGatewayMulticastDomainProperties> for TransitGatewayMulticastDomain {
    fn from(properties: TransitGatewayMulticastDomainProperties) -> TransitGatewayMulticastDomain {
        TransitGatewayMulticastDomain { properties }
    }
}

/// The [`AWS::EC2::TransitGatewayMulticastDomainAssociation`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html) resource type.
#[derive(Debug, Default)]
pub struct TransitGatewayMulticastDomainAssociation {
    properties: TransitGatewayMulticastDomainAssociationProperties
}

/// Properties for the `TransitGatewayMulticastDomainAssociation` resource.
#[derive(Debug, Default)]
pub struct TransitGatewayMulticastDomainAssociationProperties {
    /// Property [`SubnetId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html#cfn-ec2-transitgatewaymulticastdomainassociation-subnetid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub subnet_id: ::Value<String>,
    /// Property [`TransitGatewayAttachmentId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html#cfn-ec2-transitgatewaymulticastdomainassociation-transitgatewayattachmentid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub transit_gateway_attachment_id: ::Value<String>,
    /// Property [`TransitGatewayMulticastDomainId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html#cfn-ec2-transitgatewaymulticastdomainassociation-transitgatewaymulticastdomainid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub transit_gateway_multicast_domain_id: ::Value<String>,
}

impl ::serde::Serialize for TransitGatewayMulticastDomainAssociationProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "SubnetId", &self.subnet_id)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "TransitGatewayAttachmentId", &self.transit_gateway_attachment_id)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "TransitGatewayMulticastDomainId", &self.transit_gateway_multicast_domain_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for TransitGatewayMulticastDomainAssociationProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<TransitGatewayMulticastDomainAssociationProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = TransitGatewayMulticastDomainAssociationProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type TransitGatewayMulticastDomainAssociationProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut subnet_id: Option<::Value<String>> = None;
                let mut transit_gateway_attachment_id: Option<::Value<String>> = None;
                let mut transit_gateway_multicast_domain_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "SubnetId" => {
                            subnet_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TransitGatewayAttachmentId" => {
                            transit_gateway_attachment_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TransitGatewayMulticastDomainId" => {
                            transit_gateway_multicast_domain_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(TransitGatewayMulticastDomainAssociationProperties {
                    subnet_id: subnet_id.ok_or(::serde::de::Error::missing_field("SubnetId"))?,
                    transit_gateway_attachment_id: transit_gateway_attachment_id.ok_or(::serde::de::Error::missing_field("TransitGatewayAttachmentId"))?,
                    transit_gateway_multicast_domain_id: transit_gateway_multicast_domain_id.ok_or(::serde::de::Error::missing_field("TransitGatewayMulticastDomainId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for TransitGatewayMulticastDomainAssociation {
    type Properties = TransitGatewayMulticastDomainAssociationProperties;
    const TYPE: &'static str = "AWS::EC2::TransitGatewayMulticastDomainAssociation";
    fn properties(&self) -> &TransitGatewayMulticastDomainAssociationProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut TransitGatewayMulticastDomainAssociationProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for TransitGatewayMulticastDomainAssociation {}

impl From<TransitGatewayMulticastDomainAssociationProperties> for TransitGatewayMulticastDomainAssociation {
    fn from(properties: TransitGatewayMulticastDomainAssociationProperties) -> TransitGatewayMulticastDomainAssociation {
        TransitGatewayMulticastDomainAssociation { properties }
    }
}

/// The [`AWS::EC2::TransitGatewayMulticastGroupMember`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html) resource type.
#[derive(Debug, Default)]
pub struct TransitGatewayMulticastGroupMember {
    properties: TransitGatewayMulticastGroupMemberProperties
}

/// Properties for the `TransitGatewayMulticastGroupMember` resource.
#[derive(Debug, Default)]
pub struct TransitGatewayMulticastGroupMemberProperties {
    /// Property [`GroupIpAddress`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html#cfn-ec2-transitgatewaymulticastgroupmember-groupipaddress).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub group_ip_address: ::Value<String>,
    /// Property [`NetworkInterfaceId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html#cfn-ec2-transitgatewaymulticastgroupmember-networkinterfaceid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub network_interface_id: ::Value<String>,
    /// Property [`TransitGatewayMulticastDomainId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html#cfn-ec2-transitgatewaymulticastgroupmember-transitgatewaymulticastdomainid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub transit_gateway_multicast_domain_id: ::Value<String>,
}

impl ::serde::Serialize for TransitGatewayMulticastGroupMemberProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "GroupIpAddress", &self.group_ip_address)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetworkInterfaceId", &self.network_interface_id)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "TransitGatewayMulticastDomainId", &self.transit_gateway_multicast_domain_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for TransitGatewayMulticastGroupMemberProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<TransitGatewayMulticastGroupMemberProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = TransitGatewayMulticastGroupMemberProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type TransitGatewayMulticastGroupMemberProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut group_ip_address: Option<::Value<String>> = None;
                let mut network_interface_id: Option<::Value<String>> = None;
                let mut transit_gateway_multicast_domain_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "GroupIpAddress" => {
                            group_ip_address = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "NetworkInterfaceId" => {
                            network_interface_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TransitGatewayMulticastDomainId" => {
                            transit_gateway_multicast_domain_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(TransitGatewayMulticastGroupMemberProperties {
                    group_ip_address: group_ip_address.ok_or(::serde::de::Error::missing_field("GroupIpAddress"))?,
                    network_interface_id: network_interface_id.ok_or(::serde::de::Error::missing_field("NetworkInterfaceId"))?,
                    transit_gateway_multicast_domain_id: transit_gateway_multicast_domain_id.ok_or(::serde::de::Error::missing_field("TransitGatewayMulticastDomainId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for TransitGatewayMulticastGroupMember {
    type Properties = TransitGatewayMulticastGroupMemberProperties;
    const TYPE: &'static str = "AWS::EC2::TransitGatewayMulticastGroupMember";
    fn properties(&self) -> &TransitGatewayMulticastGroupMemberProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut TransitGatewayMulticastGroupMemberProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for TransitGatewayMulticastGroupMember {}

impl From<TransitGatewayMulticastGroupMemberProperties> for TransitGatewayMulticastGroupMember {
    fn from(properties: TransitGatewayMulticastGroupMemberProperties) -> TransitGatewayMulticastGroupMember {
        TransitGatewayMulticastGroupMember { properties }
    }
}

/// The [`AWS::EC2::TransitGatewayMulticastGroupSource`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html) resource type.
#[derive(Debug, Default)]
pub struct TransitGatewayMulticastGroupSource {
    properties: TransitGatewayMulticastGroupSourceProperties
}

/// Properties for the `TransitGatewayMulticastGroupSource` resource.
#[derive(Debug, Default)]
pub struct TransitGatewayMulticastGroupSourceProperties {
    /// Property [`GroupIpAddress`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html#cfn-ec2-transitgatewaymulticastgroupsource-groupipaddress).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub group_ip_address: ::Value<String>,
    /// Property [`NetworkInterfaceId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html#cfn-ec2-transitgatewaymulticastgroupsource-networkinterfaceid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub network_interface_id: ::Value<String>,
    /// Property [`TransitGatewayMulticastDomainId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html#cfn-ec2-transitgatewaymulticastgroupsource-transitgatewaymulticastdomainid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub transit_gateway_multicast_domain_id: ::Value<String>,
}

impl ::serde::Serialize for TransitGatewayMulticastGroupSourceProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "GroupIpAddress", &self.group_ip_address)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetworkInterfaceId", &self.network_interface_id)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "TransitGatewayMulticastDomainId", &self.transit_gateway_multicast_domain_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for TransitGatewayMulticastGroupSourceProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<TransitGatewayMulticastGroupSourceProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = TransitGatewayMulticastGroupSourceProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type TransitGatewayMulticastGroupSourceProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut group_ip_address: Option<::Value<String>> = None;
                let mut network_interface_id: Option<::Value<String>> = None;
                let mut transit_gateway_multicast_domain_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "GroupIpAddress" => {
                            group_ip_address = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "NetworkInterfaceId" => {
                            network_interface_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TransitGatewayMulticastDomainId" => {
                            transit_gateway_multicast_domain_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(TransitGatewayMulticastGroupSourceProperties {
                    group_ip_address: group_ip_address.ok_or(::serde::de::Error::missing_field("GroupIpAddress"))?,
                    network_interface_id: network_interface_id.ok_or(::serde::de::Error::missing_field("NetworkInterfaceId"))?,
                    transit_gateway_multicast_domain_id: transit_gateway_multicast_domain_id.ok_or(::serde::de::Error::missing_field("TransitGatewayMulticastDomainId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for TransitGatewayMulticastGroupSource {
    type Properties = TransitGatewayMulticastGroupSourceProperties;
    const TYPE: &'static str = "AWS::EC2::TransitGatewayMulticastGroupSource";
    fn properties(&self) -> &TransitGatewayMulticastGroupSourceProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut TransitGatewayMulticastGroupSourceProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for TransitGatewayMulticastGroupSource {}

impl From<TransitGatewayMulticastGroupSourceProperties> for TransitGatewayMulticastGroupSource {
    fn from(properties: TransitGatewayMulticastGroupSourceProperties) -> TransitGatewayMulticastGroupSource {
        TransitGatewayMulticastGroupSource { properties }
    }
}

/// The [`AWS::EC2::TransitGatewayPeeringAttachment`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html) resource type.
#[derive(Debug, Default)]
pub struct TransitGatewayPeeringAttachment {
    properties: TransitGatewayPeeringAttachmentProperties
}

/// Properties for the `TransitGatewayPeeringAttachment` resource.
#[derive(Debug, Default)]
pub struct TransitGatewayPeeringAttachmentProperties {
    /// Property [`PeerAccountId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peeraccountid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub peer_account_id: ::Value<String>,
    /// Property [`PeerRegion`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peerregion).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub peer_region: ::Value<String>,
    /// Property [`PeerTransitGatewayId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peertransitgatewayid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub peer_transit_gateway_id: ::Value<String>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
    /// Property [`TransitGatewayId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-transitgatewayid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub transit_gateway_id: ::Value<String>,
}

impl ::serde::Serialize for TransitGatewayPeeringAttachmentProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "PeerAccountId", &self.peer_account_id)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "PeerRegion", &self.peer_region)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "PeerTransitGatewayId", &self.peer_transit_gateway_id)?;
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "TransitGatewayId", &self.transit_gateway_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for TransitGatewayPeeringAttachmentProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<TransitGatewayPeeringAttachmentProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = TransitGatewayPeeringAttachmentProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type TransitGatewayPeeringAttachmentProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut peer_account_id: Option<::Value<String>> = None;
                let mut peer_region: Option<::Value<String>> = None;
                let mut peer_transit_gateway_id: Option<::Value<String>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;
                let mut transit_gateway_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "PeerAccountId" => {
                            peer_account_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "PeerRegion" => {
                            peer_region = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "PeerTransitGatewayId" => {
                            peer_transit_gateway_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TransitGatewayId" => {
                            transit_gateway_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(TransitGatewayPeeringAttachmentProperties {
                    peer_account_id: peer_account_id.ok_or(::serde::de::Error::missing_field("PeerAccountId"))?,
                    peer_region: peer_region.ok_or(::serde::de::Error::missing_field("PeerRegion"))?,
                    peer_transit_gateway_id: peer_transit_gateway_id.ok_or(::serde::de::Error::missing_field("PeerTransitGatewayId"))?,
                    tags: tags,
                    transit_gateway_id: transit_gateway_id.ok_or(::serde::de::Error::missing_field("TransitGatewayId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for TransitGatewayPeeringAttachment {
    type Properties = TransitGatewayPeeringAttachmentProperties;
    const TYPE: &'static str = "AWS::EC2::TransitGatewayPeeringAttachment";
    fn properties(&self) -> &TransitGatewayPeeringAttachmentProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut TransitGatewayPeeringAttachmentProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for TransitGatewayPeeringAttachment {}

impl From<TransitGatewayPeeringAttachmentProperties> for TransitGatewayPeeringAttachment {
    fn from(properties: TransitGatewayPeeringAttachmentProperties) -> TransitGatewayPeeringAttachment {
        TransitGatewayPeeringAttachment { properties }
    }
}

/// The [`AWS::EC2::TransitGatewayRoute`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html) resource type.
#[derive(Debug, Default)]
pub struct TransitGatewayRoute {
    properties: TransitGatewayRouteProperties
}

/// Properties for the `TransitGatewayRoute` resource.
#[derive(Debug, Default)]
pub struct TransitGatewayRouteProperties {
    /// Property [`Blackhole`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html#cfn-ec2-transitgatewayroute-blackhole).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub blackhole: Option<::Value<bool>>,
    /// Property [`DestinationCidrBlock`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html#cfn-ec2-transitgatewayroute-destinationcidrblock).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub destination_cidr_block: Option<::Value<String>>,
    /// Property [`TransitGatewayAttachmentId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html#cfn-ec2-transitgatewayroute-transitgatewayattachmentid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub transit_gateway_attachment_id: Option<::Value<String>>,
    /// Property [`TransitGatewayRouteTableId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html#cfn-ec2-transitgatewayroute-transitgatewayroutetableid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub transit_gateway_route_table_id: ::Value<String>,
}

impl ::serde::Serialize for TransitGatewayRouteProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref blackhole) = self.blackhole {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Blackhole", blackhole)?;
        }
        if let Some(ref destination_cidr_block) = self.destination_cidr_block {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "DestinationCidrBlock", destination_cidr_block)?;
        }
        if let Some(ref transit_gateway_attachment_id) = self.transit_gateway_attachment_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "TransitGatewayAttachmentId", transit_gateway_attachment_id)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "TransitGatewayRouteTableId", &self.transit_gateway_route_table_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for TransitGatewayRouteProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<TransitGatewayRouteProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = TransitGatewayRouteProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type TransitGatewayRouteProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut blackhole: Option<::Value<bool>> = None;
                let mut destination_cidr_block: Option<::Value<String>> = None;
                let mut transit_gateway_attachment_id: Option<::Value<String>> = None;
                let mut transit_gateway_route_table_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "Blackhole" => {
                            blackhole = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "DestinationCidrBlock" => {
                            destination_cidr_block = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TransitGatewayAttachmentId" => {
                            transit_gateway_attachment_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TransitGatewayRouteTableId" => {
                            transit_gateway_route_table_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(TransitGatewayRouteProperties {
                    blackhole: blackhole,
                    destination_cidr_block: destination_cidr_block,
                    transit_gateway_attachment_id: transit_gateway_attachment_id,
                    transit_gateway_route_table_id: transit_gateway_route_table_id.ok_or(::serde::de::Error::missing_field("TransitGatewayRouteTableId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for TransitGatewayRoute {
    type Properties = TransitGatewayRouteProperties;
    const TYPE: &'static str = "AWS::EC2::TransitGatewayRoute";
    fn properties(&self) -> &TransitGatewayRouteProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut TransitGatewayRouteProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for TransitGatewayRoute {}

impl From<TransitGatewayRouteProperties> for TransitGatewayRoute {
    fn from(properties: TransitGatewayRouteProperties) -> TransitGatewayRoute {
        TransitGatewayRoute { properties }
    }
}

/// The [`AWS::EC2::TransitGatewayRouteTable`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html) resource type.
#[derive(Debug, Default)]
pub struct TransitGatewayRouteTable {
    properties: TransitGatewayRouteTableProperties
}

/// Properties for the `TransitGatewayRouteTable` resource.
#[derive(Debug, Default)]
pub struct TransitGatewayRouteTableProperties {
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html#cfn-ec2-transitgatewayroutetable-tags).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
    /// Property [`TransitGatewayId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html#cfn-ec2-transitgatewayroutetable-transitgatewayid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub transit_gateway_id: ::Value<String>,
}

impl ::serde::Serialize for TransitGatewayRouteTableProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "TransitGatewayId", &self.transit_gateway_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for TransitGatewayRouteTableProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<TransitGatewayRouteTableProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = TransitGatewayRouteTableProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type TransitGatewayRouteTableProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut tags: Option<::ValueList<::Tag>> = None;
                let mut transit_gateway_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TransitGatewayId" => {
                            transit_gateway_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(TransitGatewayRouteTableProperties {
                    tags: tags,
                    transit_gateway_id: transit_gateway_id.ok_or(::serde::de::Error::missing_field("TransitGatewayId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for TransitGatewayRouteTable {
    type Properties = TransitGatewayRouteTableProperties;
    const TYPE: &'static str = "AWS::EC2::TransitGatewayRouteTable";
    fn properties(&self) -> &TransitGatewayRouteTableProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut TransitGatewayRouteTableProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for TransitGatewayRouteTable {}

impl From<TransitGatewayRouteTableProperties> for TransitGatewayRouteTable {
    fn from(properties: TransitGatewayRouteTableProperties) -> TransitGatewayRouteTable {
        TransitGatewayRouteTable { properties }
    }
}

/// The [`AWS::EC2::TransitGatewayRouteTableAssociation`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetableassociation.html) resource type.
#[derive(Debug, Default)]
pub struct TransitGatewayRouteTableAssociation {
    properties: TransitGatewayRouteTableAssociationProperties
}

/// Properties for the `TransitGatewayRouteTableAssociation` resource.
#[derive(Debug, Default)]
pub struct TransitGatewayRouteTableAssociationProperties {
    /// Property [`TransitGatewayAttachmentId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetableassociation.html#cfn-ec2-transitgatewayroutetableassociation-transitgatewayattachmentid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub transit_gateway_attachment_id: ::Value<String>,
    /// Property [`TransitGatewayRouteTableId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetableassociation.html#cfn-ec2-transitgatewayroutetableassociation-transitgatewayroutetableid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub transit_gateway_route_table_id: ::Value<String>,
}

impl ::serde::Serialize for TransitGatewayRouteTableAssociationProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "TransitGatewayAttachmentId", &self.transit_gateway_attachment_id)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "TransitGatewayRouteTableId", &self.transit_gateway_route_table_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for TransitGatewayRouteTableAssociationProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<TransitGatewayRouteTableAssociationProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = TransitGatewayRouteTableAssociationProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type TransitGatewayRouteTableAssociationProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut transit_gateway_attachment_id: Option<::Value<String>> = None;
                let mut transit_gateway_route_table_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "TransitGatewayAttachmentId" => {
                            transit_gateway_attachment_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TransitGatewayRouteTableId" => {
                            transit_gateway_route_table_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(TransitGatewayRouteTableAssociationProperties {
                    transit_gateway_attachment_id: transit_gateway_attachment_id.ok_or(::serde::de::Error::missing_field("TransitGatewayAttachmentId"))?,
                    transit_gateway_route_table_id: transit_gateway_route_table_id.ok_or(::serde::de::Error::missing_field("TransitGatewayRouteTableId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for TransitGatewayRouteTableAssociation {
    type Properties = TransitGatewayRouteTableAssociationProperties;
    const TYPE: &'static str = "AWS::EC2::TransitGatewayRouteTableAssociation";
    fn properties(&self) -> &TransitGatewayRouteTableAssociationProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut TransitGatewayRouteTableAssociationProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for TransitGatewayRouteTableAssociation {}

impl From<TransitGatewayRouteTableAssociationProperties> for TransitGatewayRouteTableAssociation {
    fn from(properties: TransitGatewayRouteTableAssociationProperties) -> TransitGatewayRouteTableAssociation {
        TransitGatewayRouteTableAssociation { properties }
    }
}

/// The [`AWS::EC2::TransitGatewayRouteTablePropagation`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetablepropagation.html) resource type.
#[derive(Debug, Default)]
pub struct TransitGatewayRouteTablePropagation {
    properties: TransitGatewayRouteTablePropagationProperties
}

/// Properties for the `TransitGatewayRouteTablePropagation` resource.
#[derive(Debug, Default)]
pub struct TransitGatewayRouteTablePropagationProperties {
    /// Property [`TransitGatewayAttachmentId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetablepropagation.html#cfn-ec2-transitgatewayroutetablepropagation-transitgatewayattachmentid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub transit_gateway_attachment_id: ::Value<String>,
    /// Property [`TransitGatewayRouteTableId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetablepropagation.html#cfn-ec2-transitgatewayroutetablepropagation-transitgatewayroutetableid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub transit_gateway_route_table_id: ::Value<String>,
}

impl ::serde::Serialize for TransitGatewayRouteTablePropagationProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "TransitGatewayAttachmentId", &self.transit_gateway_attachment_id)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "TransitGatewayRouteTableId", &self.transit_gateway_route_table_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for TransitGatewayRouteTablePropagationProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<TransitGatewayRouteTablePropagationProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = TransitGatewayRouteTablePropagationProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type TransitGatewayRouteTablePropagationProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut transit_gateway_attachment_id: Option<::Value<String>> = None;
                let mut transit_gateway_route_table_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "TransitGatewayAttachmentId" => {
                            transit_gateway_attachment_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TransitGatewayRouteTableId" => {
                            transit_gateway_route_table_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(TransitGatewayRouteTablePropagationProperties {
                    transit_gateway_attachment_id: transit_gateway_attachment_id.ok_or(::serde::de::Error::missing_field("TransitGatewayAttachmentId"))?,
                    transit_gateway_route_table_id: transit_gateway_route_table_id.ok_or(::serde::de::Error::missing_field("TransitGatewayRouteTableId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for TransitGatewayRouteTablePropagation {
    type Properties = TransitGatewayRouteTablePropagationProperties;
    const TYPE: &'static str = "AWS::EC2::TransitGatewayRouteTablePropagation";
    fn properties(&self) -> &TransitGatewayRouteTablePropagationProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut TransitGatewayRouteTablePropagationProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for TransitGatewayRouteTablePropagation {}

impl From<TransitGatewayRouteTablePropagationProperties> for TransitGatewayRouteTablePropagation {
    fn from(properties: TransitGatewayRouteTablePropagationProperties) -> TransitGatewayRouteTablePropagation {
        TransitGatewayRouteTablePropagation { properties }
    }
}

/// The [`AWS::EC2::TransitGatewayVpcAttachment`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html) resource type.
#[derive(Debug, Default)]
pub struct TransitGatewayVpcAttachment {
    properties: TransitGatewayVpcAttachmentProperties
}

/// Properties for the `TransitGatewayVpcAttachment` resource.
#[derive(Debug, Default)]
pub struct TransitGatewayVpcAttachmentProperties {
    /// Property [`AddSubnetIds`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-addsubnetids).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub add_subnet_ids: Option<::ValueList<String>>,
    /// Property [`Options`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-options).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub options: Option<::Value<self::transit_gateway_vpc_attachment::Options>>,
    /// Property [`RemoveSubnetIds`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-removesubnetids).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub remove_subnet_ids: Option<::ValueList<String>>,
    /// Property [`SubnetIds`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-subnetids).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub subnet_ids: ::ValueList<String>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
    /// Property [`TransitGatewayId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-transitgatewayid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub transit_gateway_id: ::Value<String>,
    /// Property [`VpcId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-vpcid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub vpc_id: ::Value<String>,
}

impl ::serde::Serialize for TransitGatewayVpcAttachmentProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref add_subnet_ids) = self.add_subnet_ids {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "AddSubnetIds", add_subnet_ids)?;
        }
        if let Some(ref options) = self.options {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Options", options)?;
        }
        if let Some(ref remove_subnet_ids) = self.remove_subnet_ids {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "RemoveSubnetIds", remove_subnet_ids)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "SubnetIds", &self.subnet_ids)?;
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "TransitGatewayId", &self.transit_gateway_id)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "VpcId", &self.vpc_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for TransitGatewayVpcAttachmentProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<TransitGatewayVpcAttachmentProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = TransitGatewayVpcAttachmentProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type TransitGatewayVpcAttachmentProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut add_subnet_ids: Option<::ValueList<String>> = None;
                let mut options: Option<::Value<self::transit_gateway_vpc_attachment::Options>> = None;
                let mut remove_subnet_ids: Option<::ValueList<String>> = None;
                let mut subnet_ids: Option<::ValueList<String>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;
                let mut transit_gateway_id: Option<::Value<String>> = None;
                let mut vpc_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "AddSubnetIds" => {
                            add_subnet_ids = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Options" => {
                            options = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "RemoveSubnetIds" => {
                            remove_subnet_ids = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SubnetIds" => {
                            subnet_ids = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TransitGatewayId" => {
                            transit_gateway_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "VpcId" => {
                            vpc_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(TransitGatewayVpcAttachmentProperties {
                    add_subnet_ids: add_subnet_ids,
                    options: options,
                    remove_subnet_ids: remove_subnet_ids,
                    subnet_ids: subnet_ids.ok_or(::serde::de::Error::missing_field("SubnetIds"))?,
                    tags: tags,
                    transit_gateway_id: transit_gateway_id.ok_or(::serde::de::Error::missing_field("TransitGatewayId"))?,
                    vpc_id: vpc_id.ok_or(::serde::de::Error::missing_field("VpcId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for TransitGatewayVpcAttachment {
    type Properties = TransitGatewayVpcAttachmentProperties;
    const TYPE: &'static str = "AWS::EC2::TransitGatewayVpcAttachment";
    fn properties(&self) -> &TransitGatewayVpcAttachmentProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut TransitGatewayVpcAttachmentProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for TransitGatewayVpcAttachment {}

impl From<TransitGatewayVpcAttachmentProperties> for TransitGatewayVpcAttachment {
    fn from(properties: TransitGatewayVpcAttachmentProperties) -> TransitGatewayVpcAttachment {
        TransitGatewayVpcAttachment { properties }
    }
}

/// The [`AWS::EC2::VPC`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html) resource type.
#[derive(Debug, Default)]
pub struct VPC {
    properties: VPCProperties
}

/// Properties for the `VPC` resource.
#[derive(Debug, Default)]
pub struct VPCProperties {
    /// Property [`CidrBlock`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-cidrblock).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub cidr_block: Option<::Value<String>>,
    /// Property [`EnableDnsHostnames`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-enablednshostnames).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub enable_dns_hostnames: Option<::Value<bool>>,
    /// Property [`EnableDnsSupport`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-enablednssupport).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub enable_dns_support: Option<::Value<bool>>,
    /// Property [`InstanceTenancy`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-instancetenancy).
    ///
    /// Update type: _Conditional_.
    /// Conditional updates can be mutable or immutable, depending on, for example, which other properties you updated.
    /// For more information, see the relevant resource type documentation.
    pub instance_tenancy: Option<::Value<String>>,
    /// Property [`Ipv4IpamPoolId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-ipv4ipampoolid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub ipv4_ipam_pool_id: Option<::Value<String>>,
    /// Property [`Ipv4NetmaskLength`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-ipv4netmasklength).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub ipv4_netmask_length: Option<::Value<u32>>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
}

impl ::serde::Serialize for VPCProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref cidr_block) = self.cidr_block {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "CidrBlock", cidr_block)?;
        }
        if let Some(ref enable_dns_hostnames) = self.enable_dns_hostnames {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "EnableDnsHostnames", enable_dns_hostnames)?;
        }
        if let Some(ref enable_dns_support) = self.enable_dns_support {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "EnableDnsSupport", enable_dns_support)?;
        }
        if let Some(ref instance_tenancy) = self.instance_tenancy {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstanceTenancy", instance_tenancy)?;
        }
        if let Some(ref ipv4_ipam_pool_id) = self.ipv4_ipam_pool_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv4IpamPoolId", ipv4_ipam_pool_id)?;
        }
        if let Some(ref ipv4_netmask_length) = self.ipv4_netmask_length {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv4NetmaskLength", ipv4_netmask_length)?;
        }
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for VPCProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<VPCProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = VPCProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type VPCProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut cidr_block: Option<::Value<String>> = None;
                let mut enable_dns_hostnames: Option<::Value<bool>> = None;
                let mut enable_dns_support: Option<::Value<bool>> = None;
                let mut instance_tenancy: Option<::Value<String>> = None;
                let mut ipv4_ipam_pool_id: Option<::Value<String>> = None;
                let mut ipv4_netmask_length: Option<::Value<u32>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "CidrBlock" => {
                            cidr_block = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "EnableDnsHostnames" => {
                            enable_dns_hostnames = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "EnableDnsSupport" => {
                            enable_dns_support = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "InstanceTenancy" => {
                            instance_tenancy = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Ipv4IpamPoolId" => {
                            ipv4_ipam_pool_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Ipv4NetmaskLength" => {
                            ipv4_netmask_length = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(VPCProperties {
                    cidr_block: cidr_block,
                    enable_dns_hostnames: enable_dns_hostnames,
                    enable_dns_support: enable_dns_support,
                    instance_tenancy: instance_tenancy,
                    ipv4_ipam_pool_id: ipv4_ipam_pool_id,
                    ipv4_netmask_length: ipv4_netmask_length,
                    tags: tags,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for VPC {
    type Properties = VPCProperties;
    const TYPE: &'static str = "AWS::EC2::VPC";
    fn properties(&self) -> &VPCProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut VPCProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for VPC {}

impl From<VPCProperties> for VPC {
    fn from(properties: VPCProperties) -> VPC {
        VPC { properties }
    }
}

/// The [`AWS::EC2::VPCCidrBlock`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html) resource type.
#[derive(Debug, Default)]
pub struct VPCCidrBlock {
    properties: VPCCidrBlockProperties
}

/// Properties for the `VPCCidrBlock` resource.
#[derive(Debug, Default)]
pub struct VPCCidrBlockProperties {
    /// Property [`AmazonProvidedIpv6CidrBlock`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-amazonprovidedipv6cidrblock).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub amazon_provided_ipv6_cidr_block: Option<::Value<bool>>,
    /// Property [`CidrBlock`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-cidrblock).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub cidr_block: Option<::Value<String>>,
    /// Property [`Ipv4IpamPoolId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv4ipampoolid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub ipv4_ipam_pool_id: Option<::Value<String>>,
    /// Property [`Ipv4NetmaskLength`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv4netmasklength).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub ipv4_netmask_length: Option<::Value<u32>>,
    /// Property [`Ipv6CidrBlock`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv6cidrblock).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub ipv6_cidr_block: Option<::Value<String>>,
    /// Property [`Ipv6IpamPoolId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv6ipampoolid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub ipv6_ipam_pool_id: Option<::Value<String>>,
    /// Property [`Ipv6NetmaskLength`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv6netmasklength).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub ipv6_netmask_length: Option<::Value<u32>>,
    /// Property [`Ipv6Pool`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv6pool).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub ipv6_pool: Option<::Value<String>>,
    /// Property [`VpcId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-vpcid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub vpc_id: ::Value<String>,
}

impl ::serde::Serialize for VPCCidrBlockProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref amazon_provided_ipv6_cidr_block) = self.amazon_provided_ipv6_cidr_block {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "AmazonProvidedIpv6CidrBlock", amazon_provided_ipv6_cidr_block)?;
        }
        if let Some(ref cidr_block) = self.cidr_block {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "CidrBlock", cidr_block)?;
        }
        if let Some(ref ipv4_ipam_pool_id) = self.ipv4_ipam_pool_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv4IpamPoolId", ipv4_ipam_pool_id)?;
        }
        if let Some(ref ipv4_netmask_length) = self.ipv4_netmask_length {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv4NetmaskLength", ipv4_netmask_length)?;
        }
        if let Some(ref ipv6_cidr_block) = self.ipv6_cidr_block {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6CidrBlock", ipv6_cidr_block)?;
        }
        if let Some(ref ipv6_ipam_pool_id) = self.ipv6_ipam_pool_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6IpamPoolId", ipv6_ipam_pool_id)?;
        }
        if let Some(ref ipv6_netmask_length) = self.ipv6_netmask_length {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6NetmaskLength", ipv6_netmask_length)?;
        }
        if let Some(ref ipv6_pool) = self.ipv6_pool {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6Pool", ipv6_pool)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "VpcId", &self.vpc_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for VPCCidrBlockProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<VPCCidrBlockProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = VPCCidrBlockProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type VPCCidrBlockProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut amazon_provided_ipv6_cidr_block: Option<::Value<bool>> = None;
                let mut cidr_block: Option<::Value<String>> = None;
                let mut ipv4_ipam_pool_id: Option<::Value<String>> = None;
                let mut ipv4_netmask_length: Option<::Value<u32>> = None;
                let mut ipv6_cidr_block: Option<::Value<String>> = None;
                let mut ipv6_ipam_pool_id: Option<::Value<String>> = None;
                let mut ipv6_netmask_length: Option<::Value<u32>> = None;
                let mut ipv6_pool: Option<::Value<String>> = None;
                let mut vpc_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "AmazonProvidedIpv6CidrBlock" => {
                            amazon_provided_ipv6_cidr_block = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "CidrBlock" => {
                            cidr_block = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Ipv4IpamPoolId" => {
                            ipv4_ipam_pool_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Ipv4NetmaskLength" => {
                            ipv4_netmask_length = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Ipv6CidrBlock" => {
                            ipv6_cidr_block = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Ipv6IpamPoolId" => {
                            ipv6_ipam_pool_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Ipv6NetmaskLength" => {
                            ipv6_netmask_length = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Ipv6Pool" => {
                            ipv6_pool = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "VpcId" => {
                            vpc_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(VPCCidrBlockProperties {
                    amazon_provided_ipv6_cidr_block: amazon_provided_ipv6_cidr_block,
                    cidr_block: cidr_block,
                    ipv4_ipam_pool_id: ipv4_ipam_pool_id,
                    ipv4_netmask_length: ipv4_netmask_length,
                    ipv6_cidr_block: ipv6_cidr_block,
                    ipv6_ipam_pool_id: ipv6_ipam_pool_id,
                    ipv6_netmask_length: ipv6_netmask_length,
                    ipv6_pool: ipv6_pool,
                    vpc_id: vpc_id.ok_or(::serde::de::Error::missing_field("VpcId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for VPCCidrBlock {
    type Properties = VPCCidrBlockProperties;
    const TYPE: &'static str = "AWS::EC2::VPCCidrBlock";
    fn properties(&self) -> &VPCCidrBlockProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut VPCCidrBlockProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for VPCCidrBlock {}

impl From<VPCCidrBlockProperties> for VPCCidrBlock {
    fn from(properties: VPCCidrBlockProperties) -> VPCCidrBlock {
        VPCCidrBlock { properties }
    }
}

/// The [`AWS::EC2::VPCDHCPOptionsAssociation`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcdhcpoptionsassociation.html) resource type.
#[derive(Debug, Default)]
pub struct VPCDHCPOptionsAssociation {
    properties: VPCDHCPOptionsAssociationProperties
}

/// Properties for the `VPCDHCPOptionsAssociation` resource.
#[derive(Debug, Default)]
pub struct VPCDHCPOptionsAssociationProperties {
    /// Property [`DhcpOptionsId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcdhcpoptionsassociation.html#cfn-ec2-vpcdhcpoptionsassociation-dhcpoptionsid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub dhcp_options_id: ::Value<String>,
    /// Property [`VpcId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcdhcpoptionsassociation.html#cfn-ec2-vpcdhcpoptionsassociation-vpcid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub vpc_id: ::Value<String>,
}

impl ::serde::Serialize for VPCDHCPOptionsAssociationProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "DhcpOptionsId", &self.dhcp_options_id)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "VpcId", &self.vpc_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for VPCDHCPOptionsAssociationProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<VPCDHCPOptionsAssociationProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = VPCDHCPOptionsAssociationProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type VPCDHCPOptionsAssociationProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut dhcp_options_id: Option<::Value<String>> = None;
                let mut vpc_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "DhcpOptionsId" => {
                            dhcp_options_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "VpcId" => {
                            vpc_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(VPCDHCPOptionsAssociationProperties {
                    dhcp_options_id: dhcp_options_id.ok_or(::serde::de::Error::missing_field("DhcpOptionsId"))?,
                    vpc_id: vpc_id.ok_or(::serde::de::Error::missing_field("VpcId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for VPCDHCPOptionsAssociation {
    type Properties = VPCDHCPOptionsAssociationProperties;
    const TYPE: &'static str = "AWS::EC2::VPCDHCPOptionsAssociation";
    fn properties(&self) -> &VPCDHCPOptionsAssociationProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut VPCDHCPOptionsAssociationProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for VPCDHCPOptionsAssociation {}

impl From<VPCDHCPOptionsAssociationProperties> for VPCDHCPOptionsAssociation {
    fn from(properties: VPCDHCPOptionsAssociationProperties) -> VPCDHCPOptionsAssociation {
        VPCDHCPOptionsAssociation { properties }
    }
}

/// The [`AWS::EC2::VPCEndpoint`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html) resource type.
#[derive(Debug, Default)]
pub struct VPCEndpoint {
    properties: VPCEndpointProperties
}

/// Properties for the `VPCEndpoint` resource.
#[derive(Debug, Default)]
pub struct VPCEndpointProperties {
    /// Property [`PolicyDocument`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-policydocument).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub policy_document: Option<::Value<::json::Value>>,
    /// Property [`PrivateDnsEnabled`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-privatednsenabled).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub private_dns_enabled: Option<::Value<bool>>,
    /// Property [`RouteTableIds`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-routetableids).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub route_table_ids: Option<::ValueList<String>>,
    /// Property [`SecurityGroupIds`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-securitygroupids).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub security_group_ids: Option<::ValueList<String>>,
    /// Property [`ServiceName`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-servicename).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub service_name: ::Value<String>,
    /// Property [`SubnetIds`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-subnetids).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub subnet_ids: Option<::ValueList<String>>,
    /// Property [`VpcEndpointType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-vpcendpointtype).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub vpc_endpoint_type: Option<::Value<String>>,
    /// Property [`VpcId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-vpcid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub vpc_id: ::Value<String>,
}

impl ::serde::Serialize for VPCEndpointProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref policy_document) = self.policy_document {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "PolicyDocument", policy_document)?;
        }
        if let Some(ref private_dns_enabled) = self.private_dns_enabled {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "PrivateDnsEnabled", private_dns_enabled)?;
        }
        if let Some(ref route_table_ids) = self.route_table_ids {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "RouteTableIds", route_table_ids)?;
        }
        if let Some(ref security_group_ids) = self.security_group_ids {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SecurityGroupIds", security_group_ids)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "ServiceName", &self.service_name)?;
        if let Some(ref subnet_ids) = self.subnet_ids {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SubnetIds", subnet_ids)?;
        }
        if let Some(ref vpc_endpoint_type) = self.vpc_endpoint_type {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "VpcEndpointType", vpc_endpoint_type)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "VpcId", &self.vpc_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for VPCEndpointProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<VPCEndpointProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = VPCEndpointProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type VPCEndpointProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut policy_document: Option<::Value<::json::Value>> = None;
                let mut private_dns_enabled: Option<::Value<bool>> = None;
                let mut route_table_ids: Option<::ValueList<String>> = None;
                let mut security_group_ids: Option<::ValueList<String>> = None;
                let mut service_name: Option<::Value<String>> = None;
                let mut subnet_ids: Option<::ValueList<String>> = None;
                let mut vpc_endpoint_type: Option<::Value<String>> = None;
                let mut vpc_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "PolicyDocument" => {
                            policy_document = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "PrivateDnsEnabled" => {
                            private_dns_enabled = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "RouteTableIds" => {
                            route_table_ids = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SecurityGroupIds" => {
                            security_group_ids = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "ServiceName" => {
                            service_name = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SubnetIds" => {
                            subnet_ids = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "VpcEndpointType" => {
                            vpc_endpoint_type = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "VpcId" => {
                            vpc_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(VPCEndpointProperties {
                    policy_document: policy_document,
                    private_dns_enabled: private_dns_enabled,
                    route_table_ids: route_table_ids,
                    security_group_ids: security_group_ids,
                    service_name: service_name.ok_or(::serde::de::Error::missing_field("ServiceName"))?,
                    subnet_ids: subnet_ids,
                    vpc_endpoint_type: vpc_endpoint_type,
                    vpc_id: vpc_id.ok_or(::serde::de::Error::missing_field("VpcId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for VPCEndpoint {
    type Properties = VPCEndpointProperties;
    const TYPE: &'static str = "AWS::EC2::VPCEndpoint";
    fn properties(&self) -> &VPCEndpointProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut VPCEndpointProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for VPCEndpoint {}

impl From<VPCEndpointProperties> for VPCEndpoint {
    fn from(properties: VPCEndpointProperties) -> VPCEndpoint {
        VPCEndpoint { properties }
    }
}

/// The [`AWS::EC2::VPCEndpointConnectionNotification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html) resource type.
#[derive(Debug, Default)]
pub struct VPCEndpointConnectionNotification {
    properties: VPCEndpointConnectionNotificationProperties
}

/// Properties for the `VPCEndpointConnectionNotification` resource.
#[derive(Debug, Default)]
pub struct VPCEndpointConnectionNotificationProperties {
    /// Property [`ConnectionEvents`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html#cfn-ec2-vpcendpointconnectionnotification-connectionevents).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub connection_events: ::ValueList<String>,
    /// Property [`ConnectionNotificationArn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html#cfn-ec2-vpcendpointconnectionnotification-connectionnotificationarn).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub connection_notification_arn: ::Value<String>,
    /// Property [`ServiceId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html#cfn-ec2-vpcendpointconnectionnotification-serviceid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub service_id: Option<::Value<String>>,
    /// Property [`VPCEndpointId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html#cfn-ec2-vpcendpointconnectionnotification-vpcendpointid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub vpc_endpoint_id: Option<::Value<String>>,
}

impl ::serde::Serialize for VPCEndpointConnectionNotificationProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "ConnectionEvents", &self.connection_events)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "ConnectionNotificationArn", &self.connection_notification_arn)?;
        if let Some(ref service_id) = self.service_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "ServiceId", service_id)?;
        }
        if let Some(ref vpc_endpoint_id) = self.vpc_endpoint_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "VPCEndpointId", vpc_endpoint_id)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for VPCEndpointConnectionNotificationProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<VPCEndpointConnectionNotificationProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = VPCEndpointConnectionNotificationProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type VPCEndpointConnectionNotificationProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut connection_events: Option<::ValueList<String>> = None;
                let mut connection_notification_arn: Option<::Value<String>> = None;
                let mut service_id: Option<::Value<String>> = None;
                let mut vpc_endpoint_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "ConnectionEvents" => {
                            connection_events = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "ConnectionNotificationArn" => {
                            connection_notification_arn = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "ServiceId" => {
                            service_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "VPCEndpointId" => {
                            vpc_endpoint_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(VPCEndpointConnectionNotificationProperties {
                    connection_events: connection_events.ok_or(::serde::de::Error::missing_field("ConnectionEvents"))?,
                    connection_notification_arn: connection_notification_arn.ok_or(::serde::de::Error::missing_field("ConnectionNotificationArn"))?,
                    service_id: service_id,
                    vpc_endpoint_id: vpc_endpoint_id,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for VPCEndpointConnectionNotification {
    type Properties = VPCEndpointConnectionNotificationProperties;
    const TYPE: &'static str = "AWS::EC2::VPCEndpointConnectionNotification";
    fn properties(&self) -> &VPCEndpointConnectionNotificationProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut VPCEndpointConnectionNotificationProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for VPCEndpointConnectionNotification {}

impl From<VPCEndpointConnectionNotificationProperties> for VPCEndpointConnectionNotification {
    fn from(properties: VPCEndpointConnectionNotificationProperties) -> VPCEndpointConnectionNotification {
        VPCEndpointConnectionNotification { properties }
    }
}

/// The [`AWS::EC2::VPCEndpointService`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html) resource type.
#[derive(Debug, Default)]
pub struct VPCEndpointService {
    properties: VPCEndpointServiceProperties
}

/// Properties for the `VPCEndpointService` resource.
#[derive(Debug, Default)]
pub struct VPCEndpointServiceProperties {
    /// Property [`AcceptanceRequired`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-acceptancerequired).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub acceptance_required: Option<::Value<bool>>,
    /// Property [`ContributorInsightsEnabled`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-contributorinsightsenabled).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub contributor_insights_enabled: Option<::Value<bool>>,
    /// Property [`GatewayLoadBalancerArns`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-gatewayloadbalancerarns).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub gateway_load_balancer_arns: Option<::ValueList<String>>,
    /// Property [`NetworkLoadBalancerArns`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-networkloadbalancerarns).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub network_load_balancer_arns: Option<::ValueList<String>>,
    /// Property [`PayerResponsibility`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-payerresponsibility).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub payer_responsibility: Option<::Value<String>>,
}

impl ::serde::Serialize for VPCEndpointServiceProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref acceptance_required) = self.acceptance_required {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "AcceptanceRequired", acceptance_required)?;
        }
        if let Some(ref contributor_insights_enabled) = self.contributor_insights_enabled {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "ContributorInsightsEnabled", contributor_insights_enabled)?;
        }
        if let Some(ref gateway_load_balancer_arns) = self.gateway_load_balancer_arns {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "GatewayLoadBalancerArns", gateway_load_balancer_arns)?;
        }
        if let Some(ref network_load_balancer_arns) = self.network_load_balancer_arns {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetworkLoadBalancerArns", network_load_balancer_arns)?;
        }
        if let Some(ref payer_responsibility) = self.payer_responsibility {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "PayerResponsibility", payer_responsibility)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for VPCEndpointServiceProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<VPCEndpointServiceProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = VPCEndpointServiceProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type VPCEndpointServiceProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut acceptance_required: Option<::Value<bool>> = None;
                let mut contributor_insights_enabled: Option<::Value<bool>> = None;
                let mut gateway_load_balancer_arns: Option<::ValueList<String>> = None;
                let mut network_load_balancer_arns: Option<::ValueList<String>> = None;
                let mut payer_responsibility: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "AcceptanceRequired" => {
                            acceptance_required = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "ContributorInsightsEnabled" => {
                            contributor_insights_enabled = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "GatewayLoadBalancerArns" => {
                            gateway_load_balancer_arns = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "NetworkLoadBalancerArns" => {
                            network_load_balancer_arns = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "PayerResponsibility" => {
                            payer_responsibility = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(VPCEndpointServiceProperties {
                    acceptance_required: acceptance_required,
                    contributor_insights_enabled: contributor_insights_enabled,
                    gateway_load_balancer_arns: gateway_load_balancer_arns,
                    network_load_balancer_arns: network_load_balancer_arns,
                    payer_responsibility: payer_responsibility,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for VPCEndpointService {
    type Properties = VPCEndpointServiceProperties;
    const TYPE: &'static str = "AWS::EC2::VPCEndpointService";
    fn properties(&self) -> &VPCEndpointServiceProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut VPCEndpointServiceProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for VPCEndpointService {}

impl From<VPCEndpointServiceProperties> for VPCEndpointService {
    fn from(properties: VPCEndpointServiceProperties) -> VPCEndpointService {
        VPCEndpointService { properties }
    }
}

/// The [`AWS::EC2::VPCEndpointServicePermissions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservicepermissions.html) resource type.
#[derive(Debug, Default)]
pub struct VPCEndpointServicePermissions {
    properties: VPCEndpointServicePermissionsProperties
}

/// Properties for the `VPCEndpointServicePermissions` resource.
#[derive(Debug, Default)]
pub struct VPCEndpointServicePermissionsProperties {
    /// Property [`AllowedPrincipals`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservicepermissions.html#cfn-ec2-vpcendpointservicepermissions-allowedprincipals).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub allowed_principals: Option<::ValueList<String>>,
    /// Property [`ServiceId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservicepermissions.html#cfn-ec2-vpcendpointservicepermissions-serviceid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub service_id: ::Value<String>,
}

impl ::serde::Serialize for VPCEndpointServicePermissionsProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref allowed_principals) = self.allowed_principals {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "AllowedPrincipals", allowed_principals)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "ServiceId", &self.service_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for VPCEndpointServicePermissionsProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<VPCEndpointServicePermissionsProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = VPCEndpointServicePermissionsProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type VPCEndpointServicePermissionsProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut allowed_principals: Option<::ValueList<String>> = None;
                let mut service_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "AllowedPrincipals" => {
                            allowed_principals = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "ServiceId" => {
                            service_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(VPCEndpointServicePermissionsProperties {
                    allowed_principals: allowed_principals,
                    service_id: service_id.ok_or(::serde::de::Error::missing_field("ServiceId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for VPCEndpointServicePermissions {
    type Properties = VPCEndpointServicePermissionsProperties;
    const TYPE: &'static str = "AWS::EC2::VPCEndpointServicePermissions";
    fn properties(&self) -> &VPCEndpointServicePermissionsProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut VPCEndpointServicePermissionsProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for VPCEndpointServicePermissions {}

impl From<VPCEndpointServicePermissionsProperties> for VPCEndpointServicePermissions {
    fn from(properties: VPCEndpointServicePermissionsProperties) -> VPCEndpointServicePermissions {
        VPCEndpointServicePermissions { properties }
    }
}

/// The [`AWS::EC2::VPCGatewayAttachment`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcgatewayattachment.html) resource type.
#[derive(Debug, Default)]
pub struct VPCGatewayAttachment {
    properties: VPCGatewayAttachmentProperties
}

/// Properties for the `VPCGatewayAttachment` resource.
#[derive(Debug, Default)]
pub struct VPCGatewayAttachmentProperties {
    /// Property [`InternetGatewayId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcgatewayattachment.html#cfn-ec2-vpcgatewayattachment-internetgatewayid).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub internet_gateway_id: Option<::Value<String>>,
    /// Property [`VpcId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcgatewayattachment.html#cfn-ec2-vpcgatewayattachment-vpcid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub vpc_id: ::Value<String>,
    /// Property [`VpnGatewayId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcgatewayattachment.html#cfn-ec2-vpcgatewayattachment-vpngatewayid).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub vpn_gateway_id: Option<::Value<String>>,
}

impl ::serde::Serialize for VPCGatewayAttachmentProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref internet_gateway_id) = self.internet_gateway_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "InternetGatewayId", internet_gateway_id)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "VpcId", &self.vpc_id)?;
        if let Some(ref vpn_gateway_id) = self.vpn_gateway_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "VpnGatewayId", vpn_gateway_id)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for VPCGatewayAttachmentProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<VPCGatewayAttachmentProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = VPCGatewayAttachmentProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type VPCGatewayAttachmentProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut internet_gateway_id: Option<::Value<String>> = None;
                let mut vpc_id: Option<::Value<String>> = None;
                let mut vpn_gateway_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "InternetGatewayId" => {
                            internet_gateway_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "VpcId" => {
                            vpc_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "VpnGatewayId" => {
                            vpn_gateway_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(VPCGatewayAttachmentProperties {
                    internet_gateway_id: internet_gateway_id,
                    vpc_id: vpc_id.ok_or(::serde::de::Error::missing_field("VpcId"))?,
                    vpn_gateway_id: vpn_gateway_id,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for VPCGatewayAttachment {
    type Properties = VPCGatewayAttachmentProperties;
    const TYPE: &'static str = "AWS::EC2::VPCGatewayAttachment";
    fn properties(&self) -> &VPCGatewayAttachmentProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut VPCGatewayAttachmentProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for VPCGatewayAttachment {}

impl From<VPCGatewayAttachmentProperties> for VPCGatewayAttachment {
    fn from(properties: VPCGatewayAttachmentProperties) -> VPCGatewayAttachment {
        VPCGatewayAttachment { properties }
    }
}

/// The [`AWS::EC2::VPCPeeringConnection`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html) resource type.
#[derive(Debug, Default)]
pub struct VPCPeeringConnection {
    properties: VPCPeeringConnectionProperties
}

/// Properties for the `VPCPeeringConnection` resource.
#[derive(Debug, Default)]
pub struct VPCPeeringConnectionProperties {
    /// Property [`PeerOwnerId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-peerownerid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub peer_owner_id: Option<::Value<String>>,
    /// Property [`PeerRegion`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-peerregion).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub peer_region: Option<::Value<String>>,
    /// Property [`PeerRoleArn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-peerrolearn).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub peer_role_arn: Option<::Value<String>>,
    /// Property [`PeerVpcId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-peervpcid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub peer_vpc_id: ::Value<String>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
    /// Property [`VpcId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-vpcid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub vpc_id: ::Value<String>,
}

impl ::serde::Serialize for VPCPeeringConnectionProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref peer_owner_id) = self.peer_owner_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "PeerOwnerId", peer_owner_id)?;
        }
        if let Some(ref peer_region) = self.peer_region {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "PeerRegion", peer_region)?;
        }
        if let Some(ref peer_role_arn) = self.peer_role_arn {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "PeerRoleArn", peer_role_arn)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "PeerVpcId", &self.peer_vpc_id)?;
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "VpcId", &self.vpc_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for VPCPeeringConnectionProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<VPCPeeringConnectionProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = VPCPeeringConnectionProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type VPCPeeringConnectionProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut peer_owner_id: Option<::Value<String>> = None;
                let mut peer_region: Option<::Value<String>> = None;
                let mut peer_role_arn: Option<::Value<String>> = None;
                let mut peer_vpc_id: Option<::Value<String>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;
                let mut vpc_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "PeerOwnerId" => {
                            peer_owner_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "PeerRegion" => {
                            peer_region = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "PeerRoleArn" => {
                            peer_role_arn = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "PeerVpcId" => {
                            peer_vpc_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "VpcId" => {
                            vpc_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(VPCPeeringConnectionProperties {
                    peer_owner_id: peer_owner_id,
                    peer_region: peer_region,
                    peer_role_arn: peer_role_arn,
                    peer_vpc_id: peer_vpc_id.ok_or(::serde::de::Error::missing_field("PeerVpcId"))?,
                    tags: tags,
                    vpc_id: vpc_id.ok_or(::serde::de::Error::missing_field("VpcId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for VPCPeeringConnection {
    type Properties = VPCPeeringConnectionProperties;
    const TYPE: &'static str = "AWS::EC2::VPCPeeringConnection";
    fn properties(&self) -> &VPCPeeringConnectionProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut VPCPeeringConnectionProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for VPCPeeringConnection {}

impl From<VPCPeeringConnectionProperties> for VPCPeeringConnection {
    fn from(properties: VPCPeeringConnectionProperties) -> VPCPeeringConnection {
        VPCPeeringConnection { properties }
    }
}

/// The [`AWS::EC2::VPNConnection`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html) resource type.
#[derive(Debug, Default)]
pub struct VPNConnection {
    properties: VPNConnectionProperties
}

/// Properties for the `VPNConnection` resource.
#[derive(Debug, Default)]
pub struct VPNConnectionProperties {
    /// Property [`CustomerGatewayId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-customergatewayid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub customer_gateway_id: ::Value<String>,
    /// Property [`StaticRoutesOnly`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-staticroutesonly).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub static_routes_only: Option<::Value<bool>>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
    /// Property [`TransitGatewayId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-transitgatewayid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub transit_gateway_id: Option<::Value<String>>,
    /// Property [`Type`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-type).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub r#type: ::Value<String>,
    /// Property [`VpnGatewayId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-vpngatewayid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub vpn_gateway_id: Option<::Value<String>>,
    /// Property [`VpnTunnelOptionsSpecifications`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnection.html#cfn-ec2-vpnconnection-vpntunneloptionsspecifications).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub vpn_tunnel_options_specifications: Option<::ValueList<self::vpn_connection::VpnTunnelOptionsSpecification>>,
}

impl ::serde::Serialize for VPNConnectionProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "CustomerGatewayId", &self.customer_gateway_id)?;
        if let Some(ref static_routes_only) = self.static_routes_only {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "StaticRoutesOnly", static_routes_only)?;
        }
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        if let Some(ref transit_gateway_id) = self.transit_gateway_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "TransitGatewayId", transit_gateway_id)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "Type", &self.r#type)?;
        if let Some(ref vpn_gateway_id) = self.vpn_gateway_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "VpnGatewayId", vpn_gateway_id)?;
        }
        if let Some(ref vpn_tunnel_options_specifications) = self.vpn_tunnel_options_specifications {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "VpnTunnelOptionsSpecifications", vpn_tunnel_options_specifications)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for VPNConnectionProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<VPNConnectionProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = VPNConnectionProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type VPNConnectionProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut customer_gateway_id: Option<::Value<String>> = None;
                let mut static_routes_only: Option<::Value<bool>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;
                let mut transit_gateway_id: Option<::Value<String>> = None;
                let mut r#type: Option<::Value<String>> = None;
                let mut vpn_gateway_id: Option<::Value<String>> = None;
                let mut vpn_tunnel_options_specifications: Option<::ValueList<self::vpn_connection::VpnTunnelOptionsSpecification>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "CustomerGatewayId" => {
                            customer_gateway_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "StaticRoutesOnly" => {
                            static_routes_only = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TransitGatewayId" => {
                            transit_gateway_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Type" => {
                            r#type = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "VpnGatewayId" => {
                            vpn_gateway_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "VpnTunnelOptionsSpecifications" => {
                            vpn_tunnel_options_specifications = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(VPNConnectionProperties {
                    customer_gateway_id: customer_gateway_id.ok_or(::serde::de::Error::missing_field("CustomerGatewayId"))?,
                    static_routes_only: static_routes_only,
                    tags: tags,
                    transit_gateway_id: transit_gateway_id,
                    r#type: r#type.ok_or(::serde::de::Error::missing_field("Type"))?,
                    vpn_gateway_id: vpn_gateway_id,
                    vpn_tunnel_options_specifications: vpn_tunnel_options_specifications,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for VPNConnection {
    type Properties = VPNConnectionProperties;
    const TYPE: &'static str = "AWS::EC2::VPNConnection";
    fn properties(&self) -> &VPNConnectionProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut VPNConnectionProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for VPNConnection {}

impl From<VPNConnectionProperties> for VPNConnection {
    fn from(properties: VPNConnectionProperties) -> VPNConnection {
        VPNConnection { properties }
    }
}

/// The [`AWS::EC2::VPNConnectionRoute`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnectionroute.html) resource type.
#[derive(Debug, Default)]
pub struct VPNConnectionRoute {
    properties: VPNConnectionRouteProperties
}

/// Properties for the `VPNConnectionRoute` resource.
#[derive(Debug, Default)]
pub struct VPNConnectionRouteProperties {
    /// Property [`DestinationCidrBlock`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnectionroute.html#cfn-ec2-vpnconnectionroute-destinationcidrblock).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub destination_cidr_block: ::Value<String>,
    /// Property [`VpnConnectionId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpnconnectionroute.html#cfn-ec2-vpnconnectionroute-vpnconnectionid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub vpn_connection_id: ::Value<String>,
}

impl ::serde::Serialize for VPNConnectionRouteProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "DestinationCidrBlock", &self.destination_cidr_block)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "VpnConnectionId", &self.vpn_connection_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for VPNConnectionRouteProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<VPNConnectionRouteProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = VPNConnectionRouteProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type VPNConnectionRouteProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut destination_cidr_block: Option<::Value<String>> = None;
                let mut vpn_connection_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "DestinationCidrBlock" => {
                            destination_cidr_block = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "VpnConnectionId" => {
                            vpn_connection_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(VPNConnectionRouteProperties {
                    destination_cidr_block: destination_cidr_block.ok_or(::serde::de::Error::missing_field("DestinationCidrBlock"))?,
                    vpn_connection_id: vpn_connection_id.ok_or(::serde::de::Error::missing_field("VpnConnectionId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for VPNConnectionRoute {
    type Properties = VPNConnectionRouteProperties;
    const TYPE: &'static str = "AWS::EC2::VPNConnectionRoute";
    fn properties(&self) -> &VPNConnectionRouteProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut VPNConnectionRouteProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for VPNConnectionRoute {}

impl From<VPNConnectionRouteProperties> for VPNConnectionRoute {
    fn from(properties: VPNConnectionRouteProperties) -> VPNConnectionRoute {
        VPNConnectionRoute { properties }
    }
}

/// The [`AWS::EC2::VPNGateway`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngateway.html) resource type.
#[derive(Debug, Default)]
pub struct VPNGateway {
    properties: VPNGatewayProperties
}

/// Properties for the `VPNGateway` resource.
#[derive(Debug, Default)]
pub struct VPNGatewayProperties {
    /// Property [`AmazonSideAsn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngateway.html#cfn-ec2-vpngateway-amazonsideasn).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub amazon_side_asn: Option<::Value<u32>>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngateway.html#cfn-ec2-vpngateway-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
    /// Property [`Type`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngateway.html#cfn-ec2-vpngateway-type).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub r#type: ::Value<String>,
}

impl ::serde::Serialize for VPNGatewayProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref amazon_side_asn) = self.amazon_side_asn {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "AmazonSideAsn", amazon_side_asn)?;
        }
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "Type", &self.r#type)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for VPNGatewayProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<VPNGatewayProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = VPNGatewayProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type VPNGatewayProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut amazon_side_asn: Option<::Value<u32>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;
                let mut r#type: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "AmazonSideAsn" => {
                            amazon_side_asn = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Type" => {
                            r#type = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(VPNGatewayProperties {
                    amazon_side_asn: amazon_side_asn,
                    tags: tags,
                    r#type: r#type.ok_or(::serde::de::Error::missing_field("Type"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for VPNGateway {
    type Properties = VPNGatewayProperties;
    const TYPE: &'static str = "AWS::EC2::VPNGateway";
    fn properties(&self) -> &VPNGatewayProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut VPNGatewayProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for VPNGateway {}

impl From<VPNGatewayProperties> for VPNGateway {
    fn from(properties: VPNGatewayProperties) -> VPNGateway {
        VPNGateway { properties }
    }
}

/// The [`AWS::EC2::VPNGatewayRoutePropagation`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-gatewayrouteprop.html) resource type.
#[derive(Debug, Default)]
pub struct VPNGatewayRoutePropagation {
    properties: VPNGatewayRoutePropagationProperties
}

/// Properties for the `VPNGatewayRoutePropagation` resource.
#[derive(Debug, Default)]
pub struct VPNGatewayRoutePropagationProperties {
    /// Property [`RouteTableIds`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-gatewayrouteprop.html#cfn-ec2-vpngatewayrouteprop-routetableids).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub route_table_ids: ::ValueList<String>,
    /// Property [`VpnGatewayId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-gatewayrouteprop.html#cfn-ec2-vpngatewayrouteprop-vpngatewayid).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub vpn_gateway_id: ::Value<String>,
}

impl ::serde::Serialize for VPNGatewayRoutePropagationProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "RouteTableIds", &self.route_table_ids)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "VpnGatewayId", &self.vpn_gateway_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for VPNGatewayRoutePropagationProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<VPNGatewayRoutePropagationProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = VPNGatewayRoutePropagationProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type VPNGatewayRoutePropagationProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut route_table_ids: Option<::ValueList<String>> = None;
                let mut vpn_gateway_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "RouteTableIds" => {
                            route_table_ids = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "VpnGatewayId" => {
                            vpn_gateway_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(VPNGatewayRoutePropagationProperties {
                    route_table_ids: route_table_ids.ok_or(::serde::de::Error::missing_field("RouteTableIds"))?,
                    vpn_gateway_id: vpn_gateway_id.ok_or(::serde::de::Error::missing_field("VpnGatewayId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for VPNGatewayRoutePropagation {
    type Properties = VPNGatewayRoutePropagationProperties;
    const TYPE: &'static str = "AWS::EC2::VPNGatewayRoutePropagation";
    fn properties(&self) -> &VPNGatewayRoutePropagationProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut VPNGatewayRoutePropagationProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for VPNGatewayRoutePropagation {}

impl From<VPNGatewayRoutePropagationProperties> for VPNGatewayRoutePropagation {
    fn from(properties: VPNGatewayRoutePropagationProperties) -> VPNGatewayRoutePropagation {
        VPNGatewayRoutePropagation { properties }
    }
}

/// The [`AWS::EC2::VerifiedAccessEndpoint`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html) resource type.
#[derive(Debug, Default)]
pub struct VerifiedAccessEndpoint {
    properties: VerifiedAccessEndpointProperties
}

/// Properties for the `VerifiedAccessEndpoint` resource.
#[derive(Debug, Default)]
pub struct VerifiedAccessEndpointProperties {
    /// Property [`ApplicationDomain`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-applicationdomain).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub application_domain: ::Value<String>,
    /// Property [`AttachmentType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-attachmenttype).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub attachment_type: ::Value<String>,
    /// Property [`Description`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-description).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub description: Option<::Value<String>>,
    /// Property [`DomainCertificateArn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-domaincertificatearn).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub domain_certificate_arn: ::Value<String>,
    /// Property [`EndpointDomainPrefix`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-endpointdomainprefix).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub endpoint_domain_prefix: ::Value<String>,
    /// Property [`EndpointType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-endpointtype).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub endpoint_type: ::Value<String>,
    /// Property [`LoadBalancerOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub load_balancer_options: Option<::Value<self::verified_access_endpoint::LoadBalancerOptions>>,
    /// Property [`NetworkInterfaceOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-networkinterfaceoptions).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub network_interface_options: Option<::Value<self::verified_access_endpoint::NetworkInterfaceOptions>>,
    /// Property [`PolicyDocument`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-policydocument).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub policy_document: Option<::Value<String>>,
    /// Property [`PolicyEnabled`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-policyenabled).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub policy_enabled: Option<::Value<bool>>,
    /// Property [`SecurityGroupIds`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-securitygroupids).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub security_group_ids: Option<::ValueList<String>>,
    /// Property [`SseSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-ssespecification).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub sse_specification: Option<::Value<self::verified_access_endpoint::SseSpecification>>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
    /// Property [`VerifiedAccessGroupId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessendpoint.html#cfn-ec2-verifiedaccessendpoint-verifiedaccessgroupid).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub verified_access_group_id: ::Value<String>,
}

impl ::serde::Serialize for VerifiedAccessEndpointProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "ApplicationDomain", &self.application_domain)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "AttachmentType", &self.attachment_type)?;
        if let Some(ref description) = self.description {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Description", description)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "DomainCertificateArn", &self.domain_certificate_arn)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "EndpointDomainPrefix", &self.endpoint_domain_prefix)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "EndpointType", &self.endpoint_type)?;
        if let Some(ref load_balancer_options) = self.load_balancer_options {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "LoadBalancerOptions", load_balancer_options)?;
        }
        if let Some(ref network_interface_options) = self.network_interface_options {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetworkInterfaceOptions", network_interface_options)?;
        }
        if let Some(ref policy_document) = self.policy_document {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "PolicyDocument", policy_document)?;
        }
        if let Some(ref policy_enabled) = self.policy_enabled {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "PolicyEnabled", policy_enabled)?;
        }
        if let Some(ref security_group_ids) = self.security_group_ids {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SecurityGroupIds", security_group_ids)?;
        }
        if let Some(ref sse_specification) = self.sse_specification {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SseSpecification", sse_specification)?;
        }
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "VerifiedAccessGroupId", &self.verified_access_group_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for VerifiedAccessEndpointProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<VerifiedAccessEndpointProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = VerifiedAccessEndpointProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type VerifiedAccessEndpointProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut application_domain: Option<::Value<String>> = None;
                let mut attachment_type: Option<::Value<String>> = None;
                let mut description: Option<::Value<String>> = None;
                let mut domain_certificate_arn: Option<::Value<String>> = None;
                let mut endpoint_domain_prefix: Option<::Value<String>> = None;
                let mut endpoint_type: Option<::Value<String>> = None;
                let mut load_balancer_options: Option<::Value<self::verified_access_endpoint::LoadBalancerOptions>> = None;
                let mut network_interface_options: Option<::Value<self::verified_access_endpoint::NetworkInterfaceOptions>> = None;
                let mut policy_document: Option<::Value<String>> = None;
                let mut policy_enabled: Option<::Value<bool>> = None;
                let mut security_group_ids: Option<::ValueList<String>> = None;
                let mut sse_specification: Option<::Value<self::verified_access_endpoint::SseSpecification>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;
                let mut verified_access_group_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "ApplicationDomain" => {
                            application_domain = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "AttachmentType" => {
                            attachment_type = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Description" => {
                            description = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "DomainCertificateArn" => {
                            domain_certificate_arn = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "EndpointDomainPrefix" => {
                            endpoint_domain_prefix = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "EndpointType" => {
                            endpoint_type = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "LoadBalancerOptions" => {
                            load_balancer_options = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "NetworkInterfaceOptions" => {
                            network_interface_options = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "PolicyDocument" => {
                            policy_document = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "PolicyEnabled" => {
                            policy_enabled = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SecurityGroupIds" => {
                            security_group_ids = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SseSpecification" => {
                            sse_specification = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "VerifiedAccessGroupId" => {
                            verified_access_group_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(VerifiedAccessEndpointProperties {
                    application_domain: application_domain.ok_or(::serde::de::Error::missing_field("ApplicationDomain"))?,
                    attachment_type: attachment_type.ok_or(::serde::de::Error::missing_field("AttachmentType"))?,
                    description: description,
                    domain_certificate_arn: domain_certificate_arn.ok_or(::serde::de::Error::missing_field("DomainCertificateArn"))?,
                    endpoint_domain_prefix: endpoint_domain_prefix.ok_or(::serde::de::Error::missing_field("EndpointDomainPrefix"))?,
                    endpoint_type: endpoint_type.ok_or(::serde::de::Error::missing_field("EndpointType"))?,
                    load_balancer_options: load_balancer_options,
                    network_interface_options: network_interface_options,
                    policy_document: policy_document,
                    policy_enabled: policy_enabled,
                    security_group_ids: security_group_ids,
                    sse_specification: sse_specification,
                    tags: tags,
                    verified_access_group_id: verified_access_group_id.ok_or(::serde::de::Error::missing_field("VerifiedAccessGroupId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for VerifiedAccessEndpoint {
    type Properties = VerifiedAccessEndpointProperties;
    const TYPE: &'static str = "AWS::EC2::VerifiedAccessEndpoint";
    fn properties(&self) -> &VerifiedAccessEndpointProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut VerifiedAccessEndpointProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for VerifiedAccessEndpoint {}

impl From<VerifiedAccessEndpointProperties> for VerifiedAccessEndpoint {
    fn from(properties: VerifiedAccessEndpointProperties) -> VerifiedAccessEndpoint {
        VerifiedAccessEndpoint { properties }
    }
}

/// The [`AWS::EC2::VerifiedAccessGroup`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html) resource type.
#[derive(Debug, Default)]
pub struct VerifiedAccessGroup {
    properties: VerifiedAccessGroupProperties
}

/// Properties for the `VerifiedAccessGroup` resource.
#[derive(Debug, Default)]
pub struct VerifiedAccessGroupProperties {
    /// Property [`Description`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html#cfn-ec2-verifiedaccessgroup-description).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub description: Option<::Value<String>>,
    /// Property [`PolicyDocument`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html#cfn-ec2-verifiedaccessgroup-policydocument).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub policy_document: Option<::Value<String>>,
    /// Property [`PolicyEnabled`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html#cfn-ec2-verifiedaccessgroup-policyenabled).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub policy_enabled: Option<::Value<bool>>,
    /// Property [`SseSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html#cfn-ec2-verifiedaccessgroup-ssespecification).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub sse_specification: Option<::Value<self::verified_access_group::SseSpecification>>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html#cfn-ec2-verifiedaccessgroup-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
    /// Property [`VerifiedAccessInstanceId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessgroup.html#cfn-ec2-verifiedaccessgroup-verifiedaccessinstanceid).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub verified_access_instance_id: ::Value<String>,
}

impl ::serde::Serialize for VerifiedAccessGroupProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref description) = self.description {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Description", description)?;
        }
        if let Some(ref policy_document) = self.policy_document {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "PolicyDocument", policy_document)?;
        }
        if let Some(ref policy_enabled) = self.policy_enabled {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "PolicyEnabled", policy_enabled)?;
        }
        if let Some(ref sse_specification) = self.sse_specification {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SseSpecification", sse_specification)?;
        }
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "VerifiedAccessInstanceId", &self.verified_access_instance_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for VerifiedAccessGroupProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<VerifiedAccessGroupProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = VerifiedAccessGroupProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type VerifiedAccessGroupProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut description: Option<::Value<String>> = None;
                let mut policy_document: Option<::Value<String>> = None;
                let mut policy_enabled: Option<::Value<bool>> = None;
                let mut sse_specification: Option<::Value<self::verified_access_group::SseSpecification>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;
                let mut verified_access_instance_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "Description" => {
                            description = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "PolicyDocument" => {
                            policy_document = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "PolicyEnabled" => {
                            policy_enabled = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SseSpecification" => {
                            sse_specification = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "VerifiedAccessInstanceId" => {
                            verified_access_instance_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(VerifiedAccessGroupProperties {
                    description: description,
                    policy_document: policy_document,
                    policy_enabled: policy_enabled,
                    sse_specification: sse_specification,
                    tags: tags,
                    verified_access_instance_id: verified_access_instance_id.ok_or(::serde::de::Error::missing_field("VerifiedAccessInstanceId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for VerifiedAccessGroup {
    type Properties = VerifiedAccessGroupProperties;
    const TYPE: &'static str = "AWS::EC2::VerifiedAccessGroup";
    fn properties(&self) -> &VerifiedAccessGroupProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut VerifiedAccessGroupProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for VerifiedAccessGroup {}

impl From<VerifiedAccessGroupProperties> for VerifiedAccessGroup {
    fn from(properties: VerifiedAccessGroupProperties) -> VerifiedAccessGroup {
        VerifiedAccessGroup { properties }
    }
}

/// The [`AWS::EC2::VerifiedAccessInstance`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html) resource type.
#[derive(Debug, Default)]
pub struct VerifiedAccessInstance {
    properties: VerifiedAccessInstanceProperties
}

/// Properties for the `VerifiedAccessInstance` resource.
#[derive(Debug, Default)]
pub struct VerifiedAccessInstanceProperties {
    /// Property [`Description`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html#cfn-ec2-verifiedaccessinstance-description).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub description: Option<::Value<String>>,
    /// Property [`FipsEnabled`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html#cfn-ec2-verifiedaccessinstance-fipsenabled).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub fips_enabled: Option<::Value<bool>>,
    /// Property [`LoggingConfigurations`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html#cfn-ec2-verifiedaccessinstance-loggingconfigurations).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub logging_configurations: Option<::Value<self::verified_access_instance::VerifiedAccessLogs>>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html#cfn-ec2-verifiedaccessinstance-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
    /// Property [`VerifiedAccessTrustProviderIds`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustproviderids).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub verified_access_trust_provider_ids: Option<::ValueList<String>>,
    /// Property [`VerifiedAccessTrustProviders`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccessinstance.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustproviders).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub verified_access_trust_providers: Option<::ValueList<self::verified_access_instance::VerifiedAccessTrustProvider>>,
}

impl ::serde::Serialize for VerifiedAccessInstanceProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref description) = self.description {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Description", description)?;
        }
        if let Some(ref fips_enabled) = self.fips_enabled {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "FipsEnabled", fips_enabled)?;
        }
        if let Some(ref logging_configurations) = self.logging_configurations {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "LoggingConfigurations", logging_configurations)?;
        }
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        if let Some(ref verified_access_trust_provider_ids) = self.verified_access_trust_provider_ids {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "VerifiedAccessTrustProviderIds", verified_access_trust_provider_ids)?;
        }
        if let Some(ref verified_access_trust_providers) = self.verified_access_trust_providers {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "VerifiedAccessTrustProviders", verified_access_trust_providers)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for VerifiedAccessInstanceProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<VerifiedAccessInstanceProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = VerifiedAccessInstanceProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type VerifiedAccessInstanceProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut description: Option<::Value<String>> = None;
                let mut fips_enabled: Option<::Value<bool>> = None;
                let mut logging_configurations: Option<::Value<self::verified_access_instance::VerifiedAccessLogs>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;
                let mut verified_access_trust_provider_ids: Option<::ValueList<String>> = None;
                let mut verified_access_trust_providers: Option<::ValueList<self::verified_access_instance::VerifiedAccessTrustProvider>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "Description" => {
                            description = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "FipsEnabled" => {
                            fips_enabled = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "LoggingConfigurations" => {
                            logging_configurations = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "VerifiedAccessTrustProviderIds" => {
                            verified_access_trust_provider_ids = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "VerifiedAccessTrustProviders" => {
                            verified_access_trust_providers = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(VerifiedAccessInstanceProperties {
                    description: description,
                    fips_enabled: fips_enabled,
                    logging_configurations: logging_configurations,
                    tags: tags,
                    verified_access_trust_provider_ids: verified_access_trust_provider_ids,
                    verified_access_trust_providers: verified_access_trust_providers,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for VerifiedAccessInstance {
    type Properties = VerifiedAccessInstanceProperties;
    const TYPE: &'static str = "AWS::EC2::VerifiedAccessInstance";
    fn properties(&self) -> &VerifiedAccessInstanceProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut VerifiedAccessInstanceProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for VerifiedAccessInstance {}

impl From<VerifiedAccessInstanceProperties> for VerifiedAccessInstance {
    fn from(properties: VerifiedAccessInstanceProperties) -> VerifiedAccessInstance {
        VerifiedAccessInstance { properties }
    }
}

/// The [`AWS::EC2::VerifiedAccessTrustProvider`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html) resource type.
#[derive(Debug, Default)]
pub struct VerifiedAccessTrustProvider {
    properties: VerifiedAccessTrustProviderProperties
}

/// Properties for the `VerifiedAccessTrustProvider` resource.
#[derive(Debug, Default)]
pub struct VerifiedAccessTrustProviderProperties {
    /// Property [`Description`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-description).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub description: Option<::Value<String>>,
    /// Property [`DeviceOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-deviceoptions).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub device_options: Option<::Value<self::verified_access_trust_provider::DeviceOptions>>,
    /// Property [`DeviceTrustProviderType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-devicetrustprovidertype).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub device_trust_provider_type: Option<::Value<String>>,
    /// Property [`OidcOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub oidc_options: Option<::Value<self::verified_access_trust_provider::OidcOptions>>,
    /// Property [`PolicyReferenceName`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-policyreferencename).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub policy_reference_name: ::Value<String>,
    /// Property [`SseSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-ssespecification).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub sse_specification: Option<::Value<self::verified_access_trust_provider::SseSpecification>>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
    /// Property [`TrustProviderType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-trustprovidertype).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub trust_provider_type: ::Value<String>,
    /// Property [`UserTrustProviderType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccesstrustprovider-usertrustprovidertype).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub user_trust_provider_type: Option<::Value<String>>,
}

impl ::serde::Serialize for VerifiedAccessTrustProviderProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref description) = self.description {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Description", description)?;
        }
        if let Some(ref device_options) = self.device_options {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "DeviceOptions", device_options)?;
        }
        if let Some(ref device_trust_provider_type) = self.device_trust_provider_type {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "DeviceTrustProviderType", device_trust_provider_type)?;
        }
        if let Some(ref oidc_options) = self.oidc_options {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "OidcOptions", oidc_options)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "PolicyReferenceName", &self.policy_reference_name)?;
        if let Some(ref sse_specification) = self.sse_specification {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SseSpecification", sse_specification)?;
        }
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "TrustProviderType", &self.trust_provider_type)?;
        if let Some(ref user_trust_provider_type) = self.user_trust_provider_type {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "UserTrustProviderType", user_trust_provider_type)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for VerifiedAccessTrustProviderProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<VerifiedAccessTrustProviderProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = VerifiedAccessTrustProviderProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type VerifiedAccessTrustProviderProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut description: Option<::Value<String>> = None;
                let mut device_options: Option<::Value<self::verified_access_trust_provider::DeviceOptions>> = None;
                let mut device_trust_provider_type: Option<::Value<String>> = None;
                let mut oidc_options: Option<::Value<self::verified_access_trust_provider::OidcOptions>> = None;
                let mut policy_reference_name: Option<::Value<String>> = None;
                let mut sse_specification: Option<::Value<self::verified_access_trust_provider::SseSpecification>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;
                let mut trust_provider_type: Option<::Value<String>> = None;
                let mut user_trust_provider_type: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "Description" => {
                            description = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "DeviceOptions" => {
                            device_options = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "DeviceTrustProviderType" => {
                            device_trust_provider_type = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "OidcOptions" => {
                            oidc_options = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "PolicyReferenceName" => {
                            policy_reference_name = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SseSpecification" => {
                            sse_specification = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "TrustProviderType" => {
                            trust_provider_type = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "UserTrustProviderType" => {
                            user_trust_provider_type = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(VerifiedAccessTrustProviderProperties {
                    description: description,
                    device_options: device_options,
                    device_trust_provider_type: device_trust_provider_type,
                    oidc_options: oidc_options,
                    policy_reference_name: policy_reference_name.ok_or(::serde::de::Error::missing_field("PolicyReferenceName"))?,
                    sse_specification: sse_specification,
                    tags: tags,
                    trust_provider_type: trust_provider_type.ok_or(::serde::de::Error::missing_field("TrustProviderType"))?,
                    user_trust_provider_type: user_trust_provider_type,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for VerifiedAccessTrustProvider {
    type Properties = VerifiedAccessTrustProviderProperties;
    const TYPE: &'static str = "AWS::EC2::VerifiedAccessTrustProvider";
    fn properties(&self) -> &VerifiedAccessTrustProviderProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut VerifiedAccessTrustProviderProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for VerifiedAccessTrustProvider {}

impl From<VerifiedAccessTrustProviderProperties> for VerifiedAccessTrustProvider {
    fn from(properties: VerifiedAccessTrustProviderProperties) -> VerifiedAccessTrustProvider {
        VerifiedAccessTrustProvider { properties }
    }
}

/// The [`AWS::EC2::Volume`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html) resource type.
#[derive(Debug, Default)]
pub struct Volume {
    properties: VolumeProperties
}

/// Properties for the `Volume` resource.
#[derive(Debug, Default)]
pub struct VolumeProperties {
    /// Property [`AutoEnableIO`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-autoenableio).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub auto_enable_io: Option<::Value<bool>>,
    /// Property [`AvailabilityZone`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-availabilityzone).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub availability_zone: ::Value<String>,
    /// Property [`Encrypted`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-encrypted).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub encrypted: Option<::Value<bool>>,
    /// Property [`Iops`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-iops).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub iops: Option<::Value<u32>>,
    /// Property [`KmsKeyId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-kmskeyid).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub kms_key_id: Option<::Value<String>>,
    /// Property [`MultiAttachEnabled`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-multiattachenabled).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub multi_attach_enabled: Option<::Value<bool>>,
    /// Property [`OutpostArn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-outpostarn).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub outpost_arn: Option<::Value<String>>,
    /// Property [`Size`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-size).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub size: Option<::Value<u32>>,
    /// Property [`SnapshotId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-snapshotid).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub snapshot_id: Option<::Value<String>>,
    /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-tags).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub tags: Option<::ValueList<::Tag>>,
    /// Property [`Throughput`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-throughput).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub throughput: Option<::Value<u32>>,
    /// Property [`VolumeType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volume.html#cfn-ec2-volume-volumetype).
    ///
    /// Update type: _Mutable_.
    /// AWS CloudFormation doesn't replace the resource when you change this property.
    pub volume_type: Option<::Value<String>>,
}

impl ::serde::Serialize for VolumeProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref auto_enable_io) = self.auto_enable_io {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "AutoEnableIO", auto_enable_io)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "AvailabilityZone", &self.availability_zone)?;
        if let Some(ref encrypted) = self.encrypted {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Encrypted", encrypted)?;
        }
        if let Some(ref iops) = self.iops {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Iops", iops)?;
        }
        if let Some(ref kms_key_id) = self.kms_key_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "KmsKeyId", kms_key_id)?;
        }
        if let Some(ref multi_attach_enabled) = self.multi_attach_enabled {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "MultiAttachEnabled", multi_attach_enabled)?;
        }
        if let Some(ref outpost_arn) = self.outpost_arn {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "OutpostArn", outpost_arn)?;
        }
        if let Some(ref size) = self.size {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Size", size)?;
        }
        if let Some(ref snapshot_id) = self.snapshot_id {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SnapshotId", snapshot_id)?;
        }
        if let Some(ref tags) = self.tags {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
        }
        if let Some(ref throughput) = self.throughput {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Throughput", throughput)?;
        }
        if let Some(ref volume_type) = self.volume_type {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "VolumeType", volume_type)?;
        }
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for VolumeProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<VolumeProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = VolumeProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type VolumeProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut auto_enable_io: Option<::Value<bool>> = None;
                let mut availability_zone: Option<::Value<String>> = None;
                let mut encrypted: Option<::Value<bool>> = None;
                let mut iops: Option<::Value<u32>> = None;
                let mut kms_key_id: Option<::Value<String>> = None;
                let mut multi_attach_enabled: Option<::Value<bool>> = None;
                let mut outpost_arn: Option<::Value<String>> = None;
                let mut size: Option<::Value<u32>> = None;
                let mut snapshot_id: Option<::Value<String>> = None;
                let mut tags: Option<::ValueList<::Tag>> = None;
                let mut throughput: Option<::Value<u32>> = None;
                let mut volume_type: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "AutoEnableIO" => {
                            auto_enable_io = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "AvailabilityZone" => {
                            availability_zone = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Encrypted" => {
                            encrypted = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Iops" => {
                            iops = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "KmsKeyId" => {
                            kms_key_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "MultiAttachEnabled" => {
                            multi_attach_enabled = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "OutpostArn" => {
                            outpost_arn = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Size" => {
                            size = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "SnapshotId" => {
                            snapshot_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Tags" => {
                            tags = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "Throughput" => {
                            throughput = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "VolumeType" => {
                            volume_type = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(VolumeProperties {
                    auto_enable_io: auto_enable_io,
                    availability_zone: availability_zone.ok_or(::serde::de::Error::missing_field("AvailabilityZone"))?,
                    encrypted: encrypted,
                    iops: iops,
                    kms_key_id: kms_key_id,
                    multi_attach_enabled: multi_attach_enabled,
                    outpost_arn: outpost_arn,
                    size: size,
                    snapshot_id: snapshot_id,
                    tags: tags,
                    throughput: throughput,
                    volume_type: volume_type,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for Volume {
    type Properties = VolumeProperties;
    const TYPE: &'static str = "AWS::EC2::Volume";
    fn properties(&self) -> &VolumeProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut VolumeProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for Volume {}

impl From<VolumeProperties> for Volume {
    fn from(properties: VolumeProperties) -> Volume {
        Volume { properties }
    }
}

/// The [`AWS::EC2::VolumeAttachment`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volumeattachment.html) resource type.
#[derive(Debug, Default)]
pub struct VolumeAttachment {
    properties: VolumeAttachmentProperties
}

/// Properties for the `VolumeAttachment` resource.
#[derive(Debug, Default)]
pub struct VolumeAttachmentProperties {
    /// Property [`Device`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volumeattachment.html#cfn-ec2-volumeattachment-device).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub device: Option<::Value<String>>,
    /// Property [`InstanceId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volumeattachment.html#cfn-ec2-volumeattachment-instanceid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub instance_id: ::Value<String>,
    /// Property [`VolumeId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-volumeattachment.html#cfn-ec2-volumeattachment-volumeid).
    ///
    /// Update type: _Immutable_.
    /// AWS CloudFormation replaces the resource when you change this property.
    pub volume_id: ::Value<String>,
}

impl ::serde::Serialize for VolumeAttachmentProperties {
    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
        let mut map = ::serde::Serializer::serialize_map(s, None)?;
        if let Some(ref device) = self.device {
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Device", device)?;
        }
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstanceId", &self.instance_id)?;
        ::serde::ser::SerializeMap::serialize_entry(&mut map, "VolumeId", &self.volume_id)?;
        ::serde::ser::SerializeMap::end(map)
    }
}

impl<'de> ::serde::Deserialize<'de> for VolumeAttachmentProperties {
    fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<VolumeAttachmentProperties, D::Error> {
        struct Visitor;

        impl<'de> ::serde::de::Visitor<'de> for Visitor {
            type Value = VolumeAttachmentProperties;

            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(f, "a struct of type VolumeAttachmentProperties")
            }

            fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                let mut device: Option<::Value<String>> = None;
                let mut instance_id: Option<::Value<String>> = None;
                let mut volume_id: Option<::Value<String>> = None;

                while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                    match __cfn_key.as_ref() {
                        "Device" => {
                            device = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "InstanceId" => {
                            instance_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        "VolumeId" => {
                            volume_id = ::serde::de::MapAccess::next_value(&mut map)?;
                        }
                        _ => {}
                    }
                }

                Ok(VolumeAttachmentProperties {
                    device: device,
                    instance_id: instance_id.ok_or(::serde::de::Error::missing_field("InstanceId"))?,
                    volume_id: volume_id.ok_or(::serde::de::Error::missing_field("VolumeId"))?,
                })
            }
        }

        d.deserialize_map(Visitor)
    }
}

impl ::Resource for VolumeAttachment {
    type Properties = VolumeAttachmentProperties;
    const TYPE: &'static str = "AWS::EC2::VolumeAttachment";
    fn properties(&self) -> &VolumeAttachmentProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut VolumeAttachmentProperties {
        &mut self.properties
    }
}

impl ::private::Sealed for VolumeAttachment {}

impl From<VolumeAttachmentProperties> for VolumeAttachment {
    fn from(properties: VolumeAttachmentProperties) -> VolumeAttachment {
        VolumeAttachment { properties }
    }
}

pub mod capacity_reservation {
    //! Property types for the `CapacityReservation` resource.

    /// The [`AWS::EC2::CapacityReservation.TagSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-tagspecification.html) property type.
    #[derive(Debug, Default)]
    pub struct TagSpecification {
        /// Property [`ResourceType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-tagspecification.html#cfn-ec2-capacityreservation-tagspecification-resourcetype).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub resource_type: Option<::Value<String>>,
        /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-tagspecification.html#cfn-ec2-capacityreservation-tagspecification-tags).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub tags: Option<::ValueList<::Tag>>,
    }

    impl ::codec::SerializeValue for TagSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref resource_type) = self.resource_type {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ResourceType", resource_type)?;
            }
            if let Some(ref tags) = self.tags {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for TagSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<TagSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = TagSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type TagSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut resource_type: Option<::Value<String>> = None;
                    let mut tags: Option<::ValueList<::Tag>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "ResourceType" => {
                                resource_type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Tags" => {
                                tags = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(TagSpecification {
                        resource_type: resource_type,
                        tags: tags,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }
}

pub mod capacity_reservation_fleet {
    //! Property types for the `CapacityReservationFleet` resource.

    /// The [`AWS::EC2::CapacityReservationFleet.InstanceTypeSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html) property type.
    #[derive(Debug, Default)]
    pub struct InstanceTypeSpecification {
        /// Property [`AvailabilityZone`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-availabilityzone).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub availability_zone: Option<::Value<String>>,
        /// Property [`AvailabilityZoneId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-availabilityzoneid).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub availability_zone_id: Option<::Value<String>>,
        /// Property [`EbsOptimized`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-ebsoptimized).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub ebs_optimized: Option<::Value<bool>>,
        /// Property [`InstancePlatform`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-instanceplatform).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub instance_platform: Option<::Value<String>>,
        /// Property [`InstanceType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-instancetype).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub instance_type: Option<::Value<String>>,
        /// Property [`Priority`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-priority).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub priority: Option<::Value<u32>>,
        /// Property [`Weight`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-weight).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub weight: Option<::Value<f64>>,
    }

    impl ::codec::SerializeValue for InstanceTypeSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref availability_zone) = self.availability_zone {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AvailabilityZone", availability_zone)?;
            }
            if let Some(ref availability_zone_id) = self.availability_zone_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AvailabilityZoneId", availability_zone_id)?;
            }
            if let Some(ref ebs_optimized) = self.ebs_optimized {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "EbsOptimized", ebs_optimized)?;
            }
            if let Some(ref instance_platform) = self.instance_platform {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstancePlatform", instance_platform)?;
            }
            if let Some(ref instance_type) = self.instance_type {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstanceType", instance_type)?;
            }
            if let Some(ref priority) = self.priority {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Priority", priority)?;
            }
            if let Some(ref weight) = self.weight {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Weight", weight)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for InstanceTypeSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<InstanceTypeSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = InstanceTypeSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type InstanceTypeSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut availability_zone: Option<::Value<String>> = None;
                    let mut availability_zone_id: Option<::Value<String>> = None;
                    let mut ebs_optimized: Option<::Value<bool>> = None;
                    let mut instance_platform: Option<::Value<String>> = None;
                    let mut instance_type: Option<::Value<String>> = None;
                    let mut priority: Option<::Value<u32>> = None;
                    let mut weight: Option<::Value<f64>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "AvailabilityZone" => {
                                availability_zone = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "AvailabilityZoneId" => {
                                availability_zone_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "EbsOptimized" => {
                                ebs_optimized = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "InstancePlatform" => {
                                instance_platform = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "InstanceType" => {
                                instance_type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Priority" => {
                                priority = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Weight" => {
                                weight = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(InstanceTypeSpecification {
                        availability_zone: availability_zone,
                        availability_zone_id: availability_zone_id,
                        ebs_optimized: ebs_optimized,
                        instance_platform: instance_platform,
                        instance_type: instance_type,
                        priority: priority,
                        weight: weight,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::CapacityReservationFleet.TagSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-tagspecification.html) property type.
    #[derive(Debug, Default)]
    pub struct TagSpecification {
        /// Property [`ResourceType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-tagspecification.html#cfn-ec2-capacityreservationfleet-tagspecification-resourcetype).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub resource_type: Option<::Value<String>>,
        /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-tagspecification.html#cfn-ec2-capacityreservationfleet-tagspecification-tags).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub tags: Option<::ValueList<::Tag>>,
    }

    impl ::codec::SerializeValue for TagSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref resource_type) = self.resource_type {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ResourceType", resource_type)?;
            }
            if let Some(ref tags) = self.tags {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for TagSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<TagSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = TagSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type TagSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut resource_type: Option<::Value<String>> = None;
                    let mut tags: Option<::ValueList<::Tag>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "ResourceType" => {
                                resource_type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Tags" => {
                                tags = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(TagSpecification {
                        resource_type: resource_type,
                        tags: tags,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }
}

pub mod client_vpn_endpoint {
    //! Property types for the `ClientVpnEndpoint` resource.

    /// The [`AWS::EC2::ClientVpnEndpoint.CertificateAuthenticationRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-certificateauthenticationrequest.html) property type.
    #[derive(Debug, Default)]
    pub struct CertificateAuthenticationRequest {
        /// Property [`ClientRootCertificateChainArn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-certificateauthenticationrequest.html#cfn-ec2-clientvpnendpoint-certificateauthenticationrequest-clientrootcertificatechainarn).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub client_root_certificate_chain_arn: ::Value<String>,
    }

    impl ::codec::SerializeValue for CertificateAuthenticationRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "ClientRootCertificateChainArn", &self.client_root_certificate_chain_arn)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for CertificateAuthenticationRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<CertificateAuthenticationRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = CertificateAuthenticationRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type CertificateAuthenticationRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut client_root_certificate_chain_arn: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "ClientRootCertificateChainArn" => {
                                client_root_certificate_chain_arn = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(CertificateAuthenticationRequest {
                        client_root_certificate_chain_arn: client_root_certificate_chain_arn.ok_or(::serde::de::Error::missing_field("ClientRootCertificateChainArn"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::ClientVpnEndpoint.ClientAuthenticationRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html) property type.
    #[derive(Debug, Default)]
    pub struct ClientAuthenticationRequest {
        /// Property [`ActiveDirectory`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-activedirectory).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub active_directory: Option<::Value<DirectoryServiceAuthenticationRequest>>,
        /// Property [`FederatedAuthentication`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-federatedauthentication).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub federated_authentication: Option<::Value<FederatedAuthenticationRequest>>,
        /// Property [`MutualAuthentication`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-mutualauthentication).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub mutual_authentication: Option<::Value<CertificateAuthenticationRequest>>,
        /// Property [`Type`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-type).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub r#type: ::Value<String>,
    }

    impl ::codec::SerializeValue for ClientAuthenticationRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref active_directory) = self.active_directory {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ActiveDirectory", active_directory)?;
            }
            if let Some(ref federated_authentication) = self.federated_authentication {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "FederatedAuthentication", federated_authentication)?;
            }
            if let Some(ref mutual_authentication) = self.mutual_authentication {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "MutualAuthentication", mutual_authentication)?;
            }
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Type", &self.r#type)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for ClientAuthenticationRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<ClientAuthenticationRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = ClientAuthenticationRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type ClientAuthenticationRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut active_directory: Option<::Value<DirectoryServiceAuthenticationRequest>> = None;
                    let mut federated_authentication: Option<::Value<FederatedAuthenticationRequest>> = None;
                    let mut mutual_authentication: Option<::Value<CertificateAuthenticationRequest>> = None;
                    let mut r#type: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "ActiveDirectory" => {
                                active_directory = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "FederatedAuthentication" => {
                                federated_authentication = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "MutualAuthentication" => {
                                mutual_authentication = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Type" => {
                                r#type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(ClientAuthenticationRequest {
                        active_directory: active_directory,
                        federated_authentication: federated_authentication,
                        mutual_authentication: mutual_authentication,
                        r#type: r#type.ok_or(::serde::de::Error::missing_field("Type"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::ClientVpnEndpoint.ClientConnectOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientconnectoptions.html) property type.
    #[derive(Debug, Default)]
    pub struct ClientConnectOptions {
        /// Property [`Enabled`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientconnectoptions.html#cfn-ec2-clientvpnendpoint-clientconnectoptions-enabled).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub enabled: ::Value<bool>,
        /// Property [`LambdaFunctionArn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientconnectoptions.html#cfn-ec2-clientvpnendpoint-clientconnectoptions-lambdafunctionarn).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub lambda_function_arn: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for ClientConnectOptions {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Enabled", &self.enabled)?;
            if let Some(ref lambda_function_arn) = self.lambda_function_arn {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "LambdaFunctionArn", lambda_function_arn)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for ClientConnectOptions {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<ClientConnectOptions, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = ClientConnectOptions;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type ClientConnectOptions")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut enabled: Option<::Value<bool>> = None;
                    let mut lambda_function_arn: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Enabled" => {
                                enabled = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "LambdaFunctionArn" => {
                                lambda_function_arn = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(ClientConnectOptions {
                        enabled: enabled.ok_or(::serde::de::Error::missing_field("Enabled"))?,
                        lambda_function_arn: lambda_function_arn,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::ClientVpnEndpoint.ClientLoginBannerOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientloginbanneroptions.html) property type.
    #[derive(Debug, Default)]
    pub struct ClientLoginBannerOptions {
        /// Property [`BannerText`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientloginbanneroptions.html#cfn-ec2-clientvpnendpoint-clientloginbanneroptions-bannertext).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub banner_text: Option<::Value<String>>,
        /// Property [`Enabled`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientloginbanneroptions.html#cfn-ec2-clientvpnendpoint-clientloginbanneroptions-enabled).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub enabled: ::Value<bool>,
    }

    impl ::codec::SerializeValue for ClientLoginBannerOptions {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref banner_text) = self.banner_text {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "BannerText", banner_text)?;
            }
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Enabled", &self.enabled)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for ClientLoginBannerOptions {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<ClientLoginBannerOptions, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = ClientLoginBannerOptions;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type ClientLoginBannerOptions")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut banner_text: Option<::Value<String>> = None;
                    let mut enabled: Option<::Value<bool>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "BannerText" => {
                                banner_text = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Enabled" => {
                                enabled = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(ClientLoginBannerOptions {
                        banner_text: banner_text,
                        enabled: enabled.ok_or(::serde::de::Error::missing_field("Enabled"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::ClientVpnEndpoint.ConnectionLogOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html) property type.
    #[derive(Debug, Default)]
    pub struct ConnectionLogOptions {
        /// Property [`CloudwatchLogGroup`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html#cfn-ec2-clientvpnendpoint-connectionlogoptions-cloudwatchloggroup).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub cloudwatch_log_group: Option<::Value<String>>,
        /// Property [`CloudwatchLogStream`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html#cfn-ec2-clientvpnendpoint-connectionlogoptions-cloudwatchlogstream).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub cloudwatch_log_stream: Option<::Value<String>>,
        /// Property [`Enabled`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html#cfn-ec2-clientvpnendpoint-connectionlogoptions-enabled).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub enabled: ::Value<bool>,
    }

    impl ::codec::SerializeValue for ConnectionLogOptions {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref cloudwatch_log_group) = self.cloudwatch_log_group {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "CloudwatchLogGroup", cloudwatch_log_group)?;
            }
            if let Some(ref cloudwatch_log_stream) = self.cloudwatch_log_stream {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "CloudwatchLogStream", cloudwatch_log_stream)?;
            }
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Enabled", &self.enabled)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for ConnectionLogOptions {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<ConnectionLogOptions, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = ConnectionLogOptions;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type ConnectionLogOptions")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut cloudwatch_log_group: Option<::Value<String>> = None;
                    let mut cloudwatch_log_stream: Option<::Value<String>> = None;
                    let mut enabled: Option<::Value<bool>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "CloudwatchLogGroup" => {
                                cloudwatch_log_group = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "CloudwatchLogStream" => {
                                cloudwatch_log_stream = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Enabled" => {
                                enabled = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(ConnectionLogOptions {
                        cloudwatch_log_group: cloudwatch_log_group,
                        cloudwatch_log_stream: cloudwatch_log_stream,
                        enabled: enabled.ok_or(::serde::de::Error::missing_field("Enabled"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::ClientVpnEndpoint.DirectoryServiceAuthenticationRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-directoryserviceauthenticationrequest.html) property type.
    #[derive(Debug, Default)]
    pub struct DirectoryServiceAuthenticationRequest {
        /// Property [`DirectoryId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-directoryserviceauthenticationrequest.html#cfn-ec2-clientvpnendpoint-directoryserviceauthenticationrequest-directoryid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub directory_id: ::Value<String>,
    }

    impl ::codec::SerializeValue for DirectoryServiceAuthenticationRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "DirectoryId", &self.directory_id)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for DirectoryServiceAuthenticationRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<DirectoryServiceAuthenticationRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = DirectoryServiceAuthenticationRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type DirectoryServiceAuthenticationRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut directory_id: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "DirectoryId" => {
                                directory_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(DirectoryServiceAuthenticationRequest {
                        directory_id: directory_id.ok_or(::serde::de::Error::missing_field("DirectoryId"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::ClientVpnEndpoint.FederatedAuthenticationRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-federatedauthenticationrequest.html) property type.
    #[derive(Debug, Default)]
    pub struct FederatedAuthenticationRequest {
        /// Property [`SAMLProviderArn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-federatedauthenticationrequest.html#cfn-ec2-clientvpnendpoint-federatedauthenticationrequest-samlproviderarn).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub saml_provider_arn: ::Value<String>,
        /// Property [`SelfServiceSAMLProviderArn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-federatedauthenticationrequest.html#cfn-ec2-clientvpnendpoint-federatedauthenticationrequest-selfservicesamlproviderarn).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub self_service_saml_provider_arn: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for FederatedAuthenticationRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "SAMLProviderArn", &self.saml_provider_arn)?;
            if let Some(ref self_service_saml_provider_arn) = self.self_service_saml_provider_arn {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SelfServiceSAMLProviderArn", self_service_saml_provider_arn)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for FederatedAuthenticationRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<FederatedAuthenticationRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = FederatedAuthenticationRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type FederatedAuthenticationRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut saml_provider_arn: Option<::Value<String>> = None;
                    let mut self_service_saml_provider_arn: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "SAMLProviderArn" => {
                                saml_provider_arn = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SelfServiceSAMLProviderArn" => {
                                self_service_saml_provider_arn = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(FederatedAuthenticationRequest {
                        saml_provider_arn: saml_provider_arn.ok_or(::serde::de::Error::missing_field("SAMLProviderArn"))?,
                        self_service_saml_provider_arn: self_service_saml_provider_arn,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::ClientVpnEndpoint.TagSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-tagspecification.html) property type.
    #[derive(Debug, Default)]
    pub struct TagSpecification {
        /// Property [`ResourceType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-tagspecification.html#cfn-ec2-clientvpnendpoint-tagspecification-resourcetype).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub resource_type: ::Value<String>,
        /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-tagspecification.html#cfn-ec2-clientvpnendpoint-tagspecification-tags).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub tags: ::ValueList<::Tag>,
    }

    impl ::codec::SerializeValue for TagSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "ResourceType", &self.resource_type)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", &self.tags)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for TagSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<TagSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = TagSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type TagSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut resource_type: Option<::Value<String>> = None;
                    let mut tags: Option<::ValueList<::Tag>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "ResourceType" => {
                                resource_type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Tags" => {
                                tags = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(TagSpecification {
                        resource_type: resource_type.ok_or(::serde::de::Error::missing_field("ResourceType"))?,
                        tags: tags.ok_or(::serde::de::Error::missing_field("Tags"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }
}

pub mod ec2_fleet {
    //! Property types for the `EC2Fleet` resource.

    /// The [`AWS::EC2::EC2Fleet.AcceleratorCountRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-acceleratorcountrequest.html) property type.
    #[derive(Debug, Default)]
    pub struct AcceleratorCountRequest {
        /// Property [`Max`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-acceleratorcountrequest.html#cfn-ec2-ec2fleet-acceleratorcountrequest-max).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub max: Option<::Value<u32>>,
        /// Property [`Min`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-acceleratorcountrequest.html#cfn-ec2-ec2fleet-acceleratorcountrequest-min).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub min: Option<::Value<u32>>,
    }

    impl ::codec::SerializeValue for AcceleratorCountRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref max) = self.max {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Max", max)?;
            }
            if let Some(ref min) = self.min {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Min", min)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for AcceleratorCountRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<AcceleratorCountRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = AcceleratorCountRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type AcceleratorCountRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut max: Option<::Value<u32>> = None;
                    let mut min: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Max" => {
                                max = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Min" => {
                                min = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(AcceleratorCountRequest {
                        max: max,
                        min: min,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::EC2Fleet.AcceleratorTotalMemoryMiBRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-acceleratortotalmemorymibrequest.html) property type.
    #[derive(Debug, Default)]
    pub struct AcceleratorTotalMemoryMiBRequest {
        /// Property [`Max`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-acceleratortotalmemorymibrequest.html#cfn-ec2-ec2fleet-acceleratortotalmemorymibrequest-max).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub max: Option<::Value<u32>>,
        /// Property [`Min`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-acceleratortotalmemorymibrequest.html#cfn-ec2-ec2fleet-acceleratortotalmemorymibrequest-min).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub min: Option<::Value<u32>>,
    }

    impl ::codec::SerializeValue for AcceleratorTotalMemoryMiBRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref max) = self.max {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Max", max)?;
            }
            if let Some(ref min) = self.min {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Min", min)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for AcceleratorTotalMemoryMiBRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<AcceleratorTotalMemoryMiBRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = AcceleratorTotalMemoryMiBRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type AcceleratorTotalMemoryMiBRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut max: Option<::Value<u32>> = None;
                    let mut min: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Max" => {
                                max = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Min" => {
                                min = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(AcceleratorTotalMemoryMiBRequest {
                        max: max,
                        min: min,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::EC2Fleet.BaselineEbsBandwidthMbpsRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-baselineebsbandwidthmbpsrequest.html) property type.
    #[derive(Debug, Default)]
    pub struct BaselineEbsBandwidthMbpsRequest {
        /// Property [`Max`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-baselineebsbandwidthmbpsrequest.html#cfn-ec2-ec2fleet-baselineebsbandwidthmbpsrequest-max).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub max: Option<::Value<u32>>,
        /// Property [`Min`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-baselineebsbandwidthmbpsrequest.html#cfn-ec2-ec2fleet-baselineebsbandwidthmbpsrequest-min).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub min: Option<::Value<u32>>,
    }

    impl ::codec::SerializeValue for BaselineEbsBandwidthMbpsRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref max) = self.max {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Max", max)?;
            }
            if let Some(ref min) = self.min {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Min", min)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for BaselineEbsBandwidthMbpsRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<BaselineEbsBandwidthMbpsRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = BaselineEbsBandwidthMbpsRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type BaselineEbsBandwidthMbpsRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut max: Option<::Value<u32>> = None;
                    let mut min: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Max" => {
                                max = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Min" => {
                                min = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(BaselineEbsBandwidthMbpsRequest {
                        max: max,
                        min: min,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::EC2Fleet.CapacityRebalance`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-capacityrebalance.html) property type.
    #[derive(Debug, Default)]
    pub struct CapacityRebalance {
        /// Property [`ReplacementStrategy`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-capacityrebalance.html#cfn-ec2-ec2fleet-capacityrebalance-replacementstrategy).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub replacement_strategy: Option<::Value<String>>,
        /// Property [`TerminationDelay`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-capacityrebalance.html#cfn-ec2-ec2fleet-capacityrebalance-terminationdelay).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub termination_delay: Option<::Value<u32>>,
    }

    impl ::codec::SerializeValue for CapacityRebalance {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref replacement_strategy) = self.replacement_strategy {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ReplacementStrategy", replacement_strategy)?;
            }
            if let Some(ref termination_delay) = self.termination_delay {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "TerminationDelay", termination_delay)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for CapacityRebalance {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<CapacityRebalance, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = CapacityRebalance;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type CapacityRebalance")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut replacement_strategy: Option<::Value<String>> = None;
                    let mut termination_delay: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "ReplacementStrategy" => {
                                replacement_strategy = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "TerminationDelay" => {
                                termination_delay = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(CapacityRebalance {
                        replacement_strategy: replacement_strategy,
                        termination_delay: termination_delay,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::EC2Fleet.CapacityReservationOptionsRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-capacityreservationoptionsrequest.html) property type.
    #[derive(Debug, Default)]
    pub struct CapacityReservationOptionsRequest {
        /// Property [`UsageStrategy`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-capacityreservationoptionsrequest.html#cfn-ec2-ec2fleet-capacityreservationoptionsrequest-usagestrategy).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub usage_strategy: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for CapacityReservationOptionsRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref usage_strategy) = self.usage_strategy {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "UsageStrategy", usage_strategy)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for CapacityReservationOptionsRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<CapacityReservationOptionsRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = CapacityReservationOptionsRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type CapacityReservationOptionsRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut usage_strategy: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "UsageStrategy" => {
                                usage_strategy = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(CapacityReservationOptionsRequest {
                        usage_strategy: usage_strategy,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::EC2Fleet.FleetLaunchTemplateConfigRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html) property type.
    #[derive(Debug, Default)]
    pub struct FleetLaunchTemplateConfigRequest {
        /// Property [`LaunchTemplateSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateconfigrequest-launchtemplatespecification).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub launch_template_specification: Option<::Value<FleetLaunchTemplateSpecificationRequest>>,
        /// Property [`Overrides`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateconfigrequest-overrides).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub overrides: Option<::ValueList<FleetLaunchTemplateOverridesRequest>>,
    }

    impl ::codec::SerializeValue for FleetLaunchTemplateConfigRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref launch_template_specification) = self.launch_template_specification {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "LaunchTemplateSpecification", launch_template_specification)?;
            }
            if let Some(ref overrides) = self.overrides {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Overrides", overrides)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for FleetLaunchTemplateConfigRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<FleetLaunchTemplateConfigRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = FleetLaunchTemplateConfigRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type FleetLaunchTemplateConfigRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut launch_template_specification: Option<::Value<FleetLaunchTemplateSpecificationRequest>> = None;
                    let mut overrides: Option<::ValueList<FleetLaunchTemplateOverridesRequest>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "LaunchTemplateSpecification" => {
                                launch_template_specification = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Overrides" => {
                                overrides = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(FleetLaunchTemplateConfigRequest {
                        launch_template_specification: launch_template_specification,
                        overrides: overrides,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::EC2Fleet.FleetLaunchTemplateOverridesRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html) property type.
    #[derive(Debug, Default)]
    pub struct FleetLaunchTemplateOverridesRequest {
        /// Property [`AvailabilityZone`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-availabilityzone).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub availability_zone: Option<::Value<String>>,
        /// Property [`InstanceRequirements`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-instancerequirements).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub instance_requirements: Option<::Value<InstanceRequirementsRequest>>,
        /// Property [`InstanceType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-instancetype).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub instance_type: Option<::Value<String>>,
        /// Property [`MaxPrice`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-maxprice).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub max_price: Option<::Value<String>>,
        /// Property [`Placement`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-placement).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub placement: Option<::Value<Placement>>,
        /// Property [`Priority`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-priority).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub priority: Option<::Value<f64>>,
        /// Property [`SubnetId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-subnetid).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub subnet_id: Option<::Value<String>>,
        /// Property [`WeightedCapacity`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-weightedcapacity).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub weighted_capacity: Option<::Value<f64>>,
    }

    impl ::codec::SerializeValue for FleetLaunchTemplateOverridesRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref availability_zone) = self.availability_zone {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AvailabilityZone", availability_zone)?;
            }
            if let Some(ref instance_requirements) = self.instance_requirements {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstanceRequirements", instance_requirements)?;
            }
            if let Some(ref instance_type) = self.instance_type {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstanceType", instance_type)?;
            }
            if let Some(ref max_price) = self.max_price {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "MaxPrice", max_price)?;
            }
            if let Some(ref placement) = self.placement {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Placement", placement)?;
            }
            if let Some(ref priority) = self.priority {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Priority", priority)?;
            }
            if let Some(ref subnet_id) = self.subnet_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SubnetId", subnet_id)?;
            }
            if let Some(ref weighted_capacity) = self.weighted_capacity {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "WeightedCapacity", weighted_capacity)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for FleetLaunchTemplateOverridesRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<FleetLaunchTemplateOverridesRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = FleetLaunchTemplateOverridesRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type FleetLaunchTemplateOverridesRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut availability_zone: Option<::Value<String>> = None;
                    let mut instance_requirements: Option<::Value<InstanceRequirementsRequest>> = None;
                    let mut instance_type: Option<::Value<String>> = None;
                    let mut max_price: Option<::Value<String>> = None;
                    let mut placement: Option<::Value<Placement>> = None;
                    let mut priority: Option<::Value<f64>> = None;
                    let mut subnet_id: Option<::Value<String>> = None;
                    let mut weighted_capacity: Option<::Value<f64>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "AvailabilityZone" => {
                                availability_zone = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "InstanceRequirements" => {
                                instance_requirements = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "InstanceType" => {
                                instance_type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "MaxPrice" => {
                                max_price = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Placement" => {
                                placement = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Priority" => {
                                priority = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SubnetId" => {
                                subnet_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "WeightedCapacity" => {
                                weighted_capacity = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(FleetLaunchTemplateOverridesRequest {
                        availability_zone: availability_zone,
                        instance_requirements: instance_requirements,
                        instance_type: instance_type,
                        max_price: max_price,
                        placement: placement,
                        priority: priority,
                        subnet_id: subnet_id,
                        weighted_capacity: weighted_capacity,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::EC2Fleet.FleetLaunchTemplateSpecificationRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest.html) property type.
    #[derive(Debug, Default)]
    pub struct FleetLaunchTemplateSpecificationRequest {
        /// Property [`LaunchTemplateId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest-launchtemplateid).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub launch_template_id: Option<::Value<String>>,
        /// Property [`LaunchTemplateName`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest-launchtemplatename).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub launch_template_name: Option<::Value<String>>,
        /// Property [`Version`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest-version).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub version: ::Value<String>,
    }

    impl ::codec::SerializeValue for FleetLaunchTemplateSpecificationRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref launch_template_id) = self.launch_template_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "LaunchTemplateId", launch_template_id)?;
            }
            if let Some(ref launch_template_name) = self.launch_template_name {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "LaunchTemplateName", launch_template_name)?;
            }
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Version", &self.version)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for FleetLaunchTemplateSpecificationRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<FleetLaunchTemplateSpecificationRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = FleetLaunchTemplateSpecificationRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type FleetLaunchTemplateSpecificationRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut launch_template_id: Option<::Value<String>> = None;
                    let mut launch_template_name: Option<::Value<String>> = None;
                    let mut version: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "LaunchTemplateId" => {
                                launch_template_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "LaunchTemplateName" => {
                                launch_template_name = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Version" => {
                                version = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(FleetLaunchTemplateSpecificationRequest {
                        launch_template_id: launch_template_id,
                        launch_template_name: launch_template_name,
                        version: version.ok_or(::serde::de::Error::missing_field("Version"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::EC2Fleet.InstanceRequirementsRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html) property type.
    #[derive(Debug, Default)]
    pub struct InstanceRequirementsRequest {
        /// Property [`AcceleratorCount`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-acceleratorcount).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub accelerator_count: Option<::Value<AcceleratorCountRequest>>,
        /// Property [`AcceleratorManufacturers`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-acceleratormanufacturers).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub accelerator_manufacturers: Option<::ValueList<String>>,
        /// Property [`AcceleratorNames`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-acceleratornames).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub accelerator_names: Option<::ValueList<String>>,
        /// Property [`AcceleratorTotalMemoryMiB`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-acceleratortotalmemorymib).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub accelerator_total_memory_mi_b: Option<::Value<AcceleratorTotalMemoryMiBRequest>>,
        /// Property [`AcceleratorTypes`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-acceleratortypes).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub accelerator_types: Option<::ValueList<String>>,
        /// Property [`AllowedInstanceTypes`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-allowedinstancetypes).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub allowed_instance_types: Option<::ValueList<String>>,
        /// Property [`BareMetal`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-baremetal).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub bare_metal: Option<::Value<String>>,
        /// Property [`BaselineEbsBandwidthMbps`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-baselineebsbandwidthmbps).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub baseline_ebs_bandwidth_mbps: Option<::Value<BaselineEbsBandwidthMbpsRequest>>,
        /// Property [`BurstablePerformance`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-burstableperformance).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub burstable_performance: Option<::Value<String>>,
        /// Property [`CpuManufacturers`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-cpumanufacturers).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub cpu_manufacturers: Option<::ValueList<String>>,
        /// Property [`ExcludedInstanceTypes`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-excludedinstancetypes).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub excluded_instance_types: Option<::ValueList<String>>,
        /// Property [`InstanceGenerations`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-instancegenerations).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub instance_generations: Option<::ValueList<String>>,
        /// Property [`LocalStorage`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-localstorage).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub local_storage: Option<::Value<String>>,
        /// Property [`LocalStorageTypes`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-localstoragetypes).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub local_storage_types: Option<::ValueList<String>>,
        /// Property [`MemoryGiBPerVCpu`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-memorygibpervcpu).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub memory_gi_b_per_v_cpu: Option<::Value<MemoryGiBPerVCpuRequest>>,
        /// Property [`MemoryMiB`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-memorymib).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub memory_mi_b: Option<::Value<MemoryMiBRequest>>,
        /// Property [`NetworkBandwidthGbps`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-networkbandwidthgbps).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub network_bandwidth_gbps: Option<::Value<NetworkBandwidthGbpsRequest>>,
        /// Property [`NetworkInterfaceCount`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-networkinterfacecount).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub network_interface_count: Option<::Value<NetworkInterfaceCountRequest>>,
        /// Property [`OnDemandMaxPricePercentageOverLowestPrice`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-ondemandmaxpricepercentageoverlowestprice).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub on_demand_max_price_percentage_over_lowest_price: Option<::Value<u32>>,
        /// Property [`RequireHibernateSupport`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-requirehibernatesupport).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub require_hibernate_support: Option<::Value<bool>>,
        /// Property [`SpotMaxPricePercentageOverLowestPrice`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-spotmaxpricepercentageoverlowestprice).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub spot_max_price_percentage_over_lowest_price: Option<::Value<u32>>,
        /// Property [`TotalLocalStorageGB`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-totallocalstoragegb).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub total_local_storage_gb: Option<::Value<TotalLocalStorageGBRequest>>,
        /// Property [`VCpuCount`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-vcpucount).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub v_cpu_count: Option<::Value<VCpuCountRangeRequest>>,
    }

    impl ::codec::SerializeValue for InstanceRequirementsRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref accelerator_count) = self.accelerator_count {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AcceleratorCount", accelerator_count)?;
            }
            if let Some(ref accelerator_manufacturers) = self.accelerator_manufacturers {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AcceleratorManufacturers", accelerator_manufacturers)?;
            }
            if let Some(ref accelerator_names) = self.accelerator_names {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AcceleratorNames", accelerator_names)?;
            }
            if let Some(ref accelerator_total_memory_mi_b) = self.accelerator_total_memory_mi_b {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AcceleratorTotalMemoryMiB", accelerator_total_memory_mi_b)?;
            }
            if let Some(ref accelerator_types) = self.accelerator_types {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AcceleratorTypes", accelerator_types)?;
            }
            if let Some(ref allowed_instance_types) = self.allowed_instance_types {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AllowedInstanceTypes", allowed_instance_types)?;
            }
            if let Some(ref bare_metal) = self.bare_metal {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "BareMetal", bare_metal)?;
            }
            if let Some(ref baseline_ebs_bandwidth_mbps) = self.baseline_ebs_bandwidth_mbps {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "BaselineEbsBandwidthMbps", baseline_ebs_bandwidth_mbps)?;
            }
            if let Some(ref burstable_performance) = self.burstable_performance {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "BurstablePerformance", burstable_performance)?;
            }
            if let Some(ref cpu_manufacturers) = self.cpu_manufacturers {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "CpuManufacturers", cpu_manufacturers)?;
            }
            if let Some(ref excluded_instance_types) = self.excluded_instance_types {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ExcludedInstanceTypes", excluded_instance_types)?;
            }
            if let Some(ref instance_generations) = self.instance_generations {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstanceGenerations", instance_generations)?;
            }
            if let Some(ref local_storage) = self.local_storage {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "LocalStorage", local_storage)?;
            }
            if let Some(ref local_storage_types) = self.local_storage_types {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "LocalStorageTypes", local_storage_types)?;
            }
            if let Some(ref memory_gi_b_per_v_cpu) = self.memory_gi_b_per_v_cpu {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "MemoryGiBPerVCpu", memory_gi_b_per_v_cpu)?;
            }
            if let Some(ref memory_mi_b) = self.memory_mi_b {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "MemoryMiB", memory_mi_b)?;
            }
            if let Some(ref network_bandwidth_gbps) = self.network_bandwidth_gbps {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetworkBandwidthGbps", network_bandwidth_gbps)?;
            }
            if let Some(ref network_interface_count) = self.network_interface_count {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetworkInterfaceCount", network_interface_count)?;
            }
            if let Some(ref on_demand_max_price_percentage_over_lowest_price) = self.on_demand_max_price_percentage_over_lowest_price {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "OnDemandMaxPricePercentageOverLowestPrice", on_demand_max_price_percentage_over_lowest_price)?;
            }
            if let Some(ref require_hibernate_support) = self.require_hibernate_support {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "RequireHibernateSupport", require_hibernate_support)?;
            }
            if let Some(ref spot_max_price_percentage_over_lowest_price) = self.spot_max_price_percentage_over_lowest_price {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SpotMaxPricePercentageOverLowestPrice", spot_max_price_percentage_over_lowest_price)?;
            }
            if let Some(ref total_local_storage_gb) = self.total_local_storage_gb {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "TotalLocalStorageGB", total_local_storage_gb)?;
            }
            if let Some(ref v_cpu_count) = self.v_cpu_count {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "VCpuCount", v_cpu_count)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for InstanceRequirementsRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<InstanceRequirementsRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = InstanceRequirementsRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type InstanceRequirementsRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut accelerator_count: Option<::Value<AcceleratorCountRequest>> = None;
                    let mut accelerator_manufacturers: Option<::ValueList<String>> = None;
                    let mut accelerator_names: Option<::ValueList<String>> = None;
                    let mut accelerator_total_memory_mi_b: Option<::Value<AcceleratorTotalMemoryMiBRequest>> = None;
                    let mut accelerator_types: Option<::ValueList<String>> = None;
                    let mut allowed_instance_types: Option<::ValueList<String>> = None;
                    let mut bare_metal: Option<::Value<String>> = None;
                    let mut baseline_ebs_bandwidth_mbps: Option<::Value<BaselineEbsBandwidthMbpsRequest>> = None;
                    let mut burstable_performance: Option<::Value<String>> = None;
                    let mut cpu_manufacturers: Option<::ValueList<String>> = None;
                    let mut excluded_instance_types: Option<::ValueList<String>> = None;
                    let mut instance_generations: Option<::ValueList<String>> = None;
                    let mut local_storage: Option<::Value<String>> = None;
                    let mut local_storage_types: Option<::ValueList<String>> = None;
                    let mut memory_gi_b_per_v_cpu: Option<::Value<MemoryGiBPerVCpuRequest>> = None;
                    let mut memory_mi_b: Option<::Value<MemoryMiBRequest>> = None;
                    let mut network_bandwidth_gbps: Option<::Value<NetworkBandwidthGbpsRequest>> = None;
                    let mut network_interface_count: Option<::Value<NetworkInterfaceCountRequest>> = None;
                    let mut on_demand_max_price_percentage_over_lowest_price: Option<::Value<u32>> = None;
                    let mut require_hibernate_support: Option<::Value<bool>> = None;
                    let mut spot_max_price_percentage_over_lowest_price: Option<::Value<u32>> = None;
                    let mut total_local_storage_gb: Option<::Value<TotalLocalStorageGBRequest>> = None;
                    let mut v_cpu_count: Option<::Value<VCpuCountRangeRequest>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "AcceleratorCount" => {
                                accelerator_count = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "AcceleratorManufacturers" => {
                                accelerator_manufacturers = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "AcceleratorNames" => {
                                accelerator_names = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "AcceleratorTotalMemoryMiB" => {
                                accelerator_total_memory_mi_b = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "AcceleratorTypes" => {
                                accelerator_types = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "AllowedInstanceTypes" => {
                                allowed_instance_types = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "BareMetal" => {
                                bare_metal = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "BaselineEbsBandwidthMbps" => {
                                baseline_ebs_bandwidth_mbps = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "BurstablePerformance" => {
                                burstable_performance = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "CpuManufacturers" => {
                                cpu_manufacturers = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ExcludedInstanceTypes" => {
                                excluded_instance_types = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "InstanceGenerations" => {
                                instance_generations = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "LocalStorage" => {
                                local_storage = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "LocalStorageTypes" => {
                                local_storage_types = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "MemoryGiBPerVCpu" => {
                                memory_gi_b_per_v_cpu = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "MemoryMiB" => {
                                memory_mi_b = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "NetworkBandwidthGbps" => {
                                network_bandwidth_gbps = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "NetworkInterfaceCount" => {
                                network_interface_count = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "OnDemandMaxPricePercentageOverLowestPrice" => {
                                on_demand_max_price_percentage_over_lowest_price = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "RequireHibernateSupport" => {
                                require_hibernate_support = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SpotMaxPricePercentageOverLowestPrice" => {
                                spot_max_price_percentage_over_lowest_price = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "TotalLocalStorageGB" => {
                                total_local_storage_gb = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "VCpuCount" => {
                                v_cpu_count = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(InstanceRequirementsRequest {
                        accelerator_count: accelerator_count,
                        accelerator_manufacturers: accelerator_manufacturers,
                        accelerator_names: accelerator_names,
                        accelerator_total_memory_mi_b: accelerator_total_memory_mi_b,
                        accelerator_types: accelerator_types,
                        allowed_instance_types: allowed_instance_types,
                        bare_metal: bare_metal,
                        baseline_ebs_bandwidth_mbps: baseline_ebs_bandwidth_mbps,
                        burstable_performance: burstable_performance,
                        cpu_manufacturers: cpu_manufacturers,
                        excluded_instance_types: excluded_instance_types,
                        instance_generations: instance_generations,
                        local_storage: local_storage,
                        local_storage_types: local_storage_types,
                        memory_gi_b_per_v_cpu: memory_gi_b_per_v_cpu,
                        memory_mi_b: memory_mi_b,
                        network_bandwidth_gbps: network_bandwidth_gbps,
                        network_interface_count: network_interface_count,
                        on_demand_max_price_percentage_over_lowest_price: on_demand_max_price_percentage_over_lowest_price,
                        require_hibernate_support: require_hibernate_support,
                        spot_max_price_percentage_over_lowest_price: spot_max_price_percentage_over_lowest_price,
                        total_local_storage_gb: total_local_storage_gb,
                        v_cpu_count: v_cpu_count,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::EC2Fleet.MaintenanceStrategies`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-maintenancestrategies.html) property type.
    #[derive(Debug, Default)]
    pub struct MaintenanceStrategies {
        /// Property [`CapacityRebalance`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-maintenancestrategies.html#cfn-ec2-ec2fleet-maintenancestrategies-capacityrebalance).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub capacity_rebalance: Option<::Value<CapacityRebalance>>,
    }

    impl ::codec::SerializeValue for MaintenanceStrategies {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref capacity_rebalance) = self.capacity_rebalance {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "CapacityRebalance", capacity_rebalance)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for MaintenanceStrategies {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<MaintenanceStrategies, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = MaintenanceStrategies;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type MaintenanceStrategies")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut capacity_rebalance: Option<::Value<CapacityRebalance>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "CapacityRebalance" => {
                                capacity_rebalance = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(MaintenanceStrategies {
                        capacity_rebalance: capacity_rebalance,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::EC2Fleet.MemoryGiBPerVCpuRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-memorygibpervcpurequest.html) property type.
    #[derive(Debug, Default)]
    pub struct MemoryGiBPerVCpuRequest {
        /// Property [`Max`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-memorygibpervcpurequest.html#cfn-ec2-ec2fleet-memorygibpervcpurequest-max).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub max: Option<::Value<f64>>,
        /// Property [`Min`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-memorygibpervcpurequest.html#cfn-ec2-ec2fleet-memorygibpervcpurequest-min).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub min: Option<::Value<f64>>,
    }

    impl ::codec::SerializeValue for MemoryGiBPerVCpuRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref max) = self.max {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Max", max)?;
            }
            if let Some(ref min) = self.min {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Min", min)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for MemoryGiBPerVCpuRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<MemoryGiBPerVCpuRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = MemoryGiBPerVCpuRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type MemoryGiBPerVCpuRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut max: Option<::Value<f64>> = None;
                    let mut min: Option<::Value<f64>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Max" => {
                                max = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Min" => {
                                min = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(MemoryGiBPerVCpuRequest {
                        max: max,
                        min: min,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::EC2Fleet.MemoryMiBRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-memorymibrequest.html) property type.
    #[derive(Debug, Default)]
    pub struct MemoryMiBRequest {
        /// Property [`Max`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-memorymibrequest.html#cfn-ec2-ec2fleet-memorymibrequest-max).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub max: Option<::Value<u32>>,
        /// Property [`Min`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-memorymibrequest.html#cfn-ec2-ec2fleet-memorymibrequest-min).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub min: Option<::Value<u32>>,
    }

    impl ::codec::SerializeValue for MemoryMiBRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref max) = self.max {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Max", max)?;
            }
            if let Some(ref min) = self.min {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Min", min)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for MemoryMiBRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<MemoryMiBRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = MemoryMiBRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type MemoryMiBRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut max: Option<::Value<u32>> = None;
                    let mut min: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Max" => {
                                max = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Min" => {
                                min = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(MemoryMiBRequest {
                        max: max,
                        min: min,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::EC2Fleet.NetworkBandwidthGbpsRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-networkbandwidthgbpsrequest.html) property type.
    #[derive(Debug, Default)]
    pub struct NetworkBandwidthGbpsRequest {
        /// Property [`Max`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-networkbandwidthgbpsrequest.html#cfn-ec2-ec2fleet-networkbandwidthgbpsrequest-max).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub max: Option<::Value<f64>>,
        /// Property [`Min`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-networkbandwidthgbpsrequest.html#cfn-ec2-ec2fleet-networkbandwidthgbpsrequest-min).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub min: Option<::Value<f64>>,
    }

    impl ::codec::SerializeValue for NetworkBandwidthGbpsRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref max) = self.max {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Max", max)?;
            }
            if let Some(ref min) = self.min {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Min", min)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for NetworkBandwidthGbpsRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<NetworkBandwidthGbpsRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = NetworkBandwidthGbpsRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type NetworkBandwidthGbpsRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut max: Option<::Value<f64>> = None;
                    let mut min: Option<::Value<f64>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Max" => {
                                max = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Min" => {
                                min = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(NetworkBandwidthGbpsRequest {
                        max: max,
                        min: min,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::EC2Fleet.NetworkInterfaceCountRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-networkinterfacecountrequest.html) property type.
    #[derive(Debug, Default)]
    pub struct NetworkInterfaceCountRequest {
        /// Property [`Max`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-networkinterfacecountrequest.html#cfn-ec2-ec2fleet-networkinterfacecountrequest-max).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub max: Option<::Value<u32>>,
        /// Property [`Min`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-networkinterfacecountrequest.html#cfn-ec2-ec2fleet-networkinterfacecountrequest-min).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub min: Option<::Value<u32>>,
    }

    impl ::codec::SerializeValue for NetworkInterfaceCountRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref max) = self.max {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Max", max)?;
            }
            if let Some(ref min) = self.min {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Min", min)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for NetworkInterfaceCountRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<NetworkInterfaceCountRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = NetworkInterfaceCountRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type NetworkInterfaceCountRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut max: Option<::Value<u32>> = None;
                    let mut min: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Max" => {
                                max = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Min" => {
                                min = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(NetworkInterfaceCountRequest {
                        max: max,
                        min: min,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::EC2Fleet.OnDemandOptionsRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html) property type.
    #[derive(Debug, Default)]
    pub struct OnDemandOptionsRequest {
        /// Property [`AllocationStrategy`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-allocationstrategy).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub allocation_strategy: Option<::Value<String>>,
        /// Property [`CapacityReservationOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-capacityreservationoptions).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub capacity_reservation_options: Option<::Value<CapacityReservationOptionsRequest>>,
        /// Property [`MaxTotalPrice`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-maxtotalprice).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub max_total_price: Option<::Value<String>>,
        /// Property [`MinTargetCapacity`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-mintargetcapacity).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub min_target_capacity: Option<::Value<u32>>,
        /// Property [`SingleAvailabilityZone`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-singleavailabilityzone).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub single_availability_zone: Option<::Value<bool>>,
        /// Property [`SingleInstanceType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-singleinstancetype).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub single_instance_type: Option<::Value<bool>>,
    }

    impl ::codec::SerializeValue for OnDemandOptionsRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref allocation_strategy) = self.allocation_strategy {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AllocationStrategy", allocation_strategy)?;
            }
            if let Some(ref capacity_reservation_options) = self.capacity_reservation_options {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "CapacityReservationOptions", capacity_reservation_options)?;
            }
            if let Some(ref max_total_price) = self.max_total_price {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "MaxTotalPrice", max_total_price)?;
            }
            if let Some(ref min_target_capacity) = self.min_target_capacity {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "MinTargetCapacity", min_target_capacity)?;
            }
            if let Some(ref single_availability_zone) = self.single_availability_zone {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SingleAvailabilityZone", single_availability_zone)?;
            }
            if let Some(ref single_instance_type) = self.single_instance_type {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SingleInstanceType", single_instance_type)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for OnDemandOptionsRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<OnDemandOptionsRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = OnDemandOptionsRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type OnDemandOptionsRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut allocation_strategy: Option<::Value<String>> = None;
                    let mut capacity_reservation_options: Option<::Value<CapacityReservationOptionsRequest>> = None;
                    let mut max_total_price: Option<::Value<String>> = None;
                    let mut min_target_capacity: Option<::Value<u32>> = None;
                    let mut single_availability_zone: Option<::Value<bool>> = None;
                    let mut single_instance_type: Option<::Value<bool>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "AllocationStrategy" => {
                                allocation_strategy = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "CapacityReservationOptions" => {
                                capacity_reservation_options = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "MaxTotalPrice" => {
                                max_total_price = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "MinTargetCapacity" => {
                                min_target_capacity = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SingleAvailabilityZone" => {
                                single_availability_zone = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SingleInstanceType" => {
                                single_instance_type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(OnDemandOptionsRequest {
                        allocation_strategy: allocation_strategy,
                        capacity_reservation_options: capacity_reservation_options,
                        max_total_price: max_total_price,
                        min_target_capacity: min_target_capacity,
                        single_availability_zone: single_availability_zone,
                        single_instance_type: single_instance_type,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::EC2Fleet.Placement`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html) property type.
    #[derive(Debug, Default)]
    pub struct Placement {
        /// Property [`Affinity`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-affinity).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub affinity: Option<::Value<String>>,
        /// Property [`AvailabilityZone`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-availabilityzone).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub availability_zone: Option<::Value<String>>,
        /// Property [`GroupName`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-groupname).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub group_name: Option<::Value<String>>,
        /// Property [`HostId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-hostid).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub host_id: Option<::Value<String>>,
        /// Property [`HostResourceGroupArn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-hostresourcegrouparn).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub host_resource_group_arn: Option<::Value<String>>,
        /// Property [`PartitionNumber`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-partitionnumber).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub partition_number: Option<::Value<u32>>,
        /// Property [`SpreadDomain`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-spreaddomain).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub spread_domain: Option<::Value<String>>,
        /// Property [`Tenancy`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-tenancy).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub tenancy: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for Placement {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref affinity) = self.affinity {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Affinity", affinity)?;
            }
            if let Some(ref availability_zone) = self.availability_zone {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AvailabilityZone", availability_zone)?;
            }
            if let Some(ref group_name) = self.group_name {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "GroupName", group_name)?;
            }
            if let Some(ref host_id) = self.host_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "HostId", host_id)?;
            }
            if let Some(ref host_resource_group_arn) = self.host_resource_group_arn {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "HostResourceGroupArn", host_resource_group_arn)?;
            }
            if let Some(ref partition_number) = self.partition_number {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "PartitionNumber", partition_number)?;
            }
            if let Some(ref spread_domain) = self.spread_domain {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SpreadDomain", spread_domain)?;
            }
            if let Some(ref tenancy) = self.tenancy {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tenancy", tenancy)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for Placement {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<Placement, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = Placement;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type Placement")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut affinity: Option<::Value<String>> = None;
                    let mut availability_zone: Option<::Value<String>> = None;
                    let mut group_name: Option<::Value<String>> = None;
                    let mut host_id: Option<::Value<String>> = None;
                    let mut host_resource_group_arn: Option<::Value<String>> = None;
                    let mut partition_number: Option<::Value<u32>> = None;
                    let mut spread_domain: Option<::Value<String>> = None;
                    let mut tenancy: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Affinity" => {
                                affinity = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "AvailabilityZone" => {
                                availability_zone = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "GroupName" => {
                                group_name = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "HostId" => {
                                host_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "HostResourceGroupArn" => {
                                host_resource_group_arn = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "PartitionNumber" => {
                                partition_number = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SpreadDomain" => {
                                spread_domain = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Tenancy" => {
                                tenancy = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(Placement {
                        affinity: affinity,
                        availability_zone: availability_zone,
                        group_name: group_name,
                        host_id: host_id,
                        host_resource_group_arn: host_resource_group_arn,
                        partition_number: partition_number,
                        spread_domain: spread_domain,
                        tenancy: tenancy,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::EC2Fleet.SpotOptionsRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html) property type.
    #[derive(Debug, Default)]
    pub struct SpotOptionsRequest {
        /// Property [`AllocationStrategy`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-allocationstrategy).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub allocation_strategy: Option<::Value<String>>,
        /// Property [`InstanceInterruptionBehavior`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-instanceinterruptionbehavior).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub instance_interruption_behavior: Option<::Value<String>>,
        /// Property [`InstancePoolsToUseCount`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-instancepoolstousecount).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub instance_pools_to_use_count: Option<::Value<u32>>,
        /// Property [`MaintenanceStrategies`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-maintenancestrategies).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub maintenance_strategies: Option<::Value<MaintenanceStrategies>>,
        /// Property [`MaxTotalPrice`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-maxtotalprice).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub max_total_price: Option<::Value<String>>,
        /// Property [`MinTargetCapacity`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-mintargetcapacity).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub min_target_capacity: Option<::Value<u32>>,
        /// Property [`SingleAvailabilityZone`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-singleavailabilityzone).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub single_availability_zone: Option<::Value<bool>>,
        /// Property [`SingleInstanceType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-singleinstancetype).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub single_instance_type: Option<::Value<bool>>,
    }

    impl ::codec::SerializeValue for SpotOptionsRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref allocation_strategy) = self.allocation_strategy {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AllocationStrategy", allocation_strategy)?;
            }
            if let Some(ref instance_interruption_behavior) = self.instance_interruption_behavior {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstanceInterruptionBehavior", instance_interruption_behavior)?;
            }
            if let Some(ref instance_pools_to_use_count) = self.instance_pools_to_use_count {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstancePoolsToUseCount", instance_pools_to_use_count)?;
            }
            if let Some(ref maintenance_strategies) = self.maintenance_strategies {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "MaintenanceStrategies", maintenance_strategies)?;
            }
            if let Some(ref max_total_price) = self.max_total_price {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "MaxTotalPrice", max_total_price)?;
            }
            if let Some(ref min_target_capacity) = self.min_target_capacity {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "MinTargetCapacity", min_target_capacity)?;
            }
            if let Some(ref single_availability_zone) = self.single_availability_zone {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SingleAvailabilityZone", single_availability_zone)?;
            }
            if let Some(ref single_instance_type) = self.single_instance_type {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SingleInstanceType", single_instance_type)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for SpotOptionsRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<SpotOptionsRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = SpotOptionsRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type SpotOptionsRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut allocation_strategy: Option<::Value<String>> = None;
                    let mut instance_interruption_behavior: Option<::Value<String>> = None;
                    let mut instance_pools_to_use_count: Option<::Value<u32>> = None;
                    let mut maintenance_strategies: Option<::Value<MaintenanceStrategies>> = None;
                    let mut max_total_price: Option<::Value<String>> = None;
                    let mut min_target_capacity: Option<::Value<u32>> = None;
                    let mut single_availability_zone: Option<::Value<bool>> = None;
                    let mut single_instance_type: Option<::Value<bool>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "AllocationStrategy" => {
                                allocation_strategy = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "InstanceInterruptionBehavior" => {
                                instance_interruption_behavior = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "InstancePoolsToUseCount" => {
                                instance_pools_to_use_count = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "MaintenanceStrategies" => {
                                maintenance_strategies = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "MaxTotalPrice" => {
                                max_total_price = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "MinTargetCapacity" => {
                                min_target_capacity = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SingleAvailabilityZone" => {
                                single_availability_zone = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SingleInstanceType" => {
                                single_instance_type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(SpotOptionsRequest {
                        allocation_strategy: allocation_strategy,
                        instance_interruption_behavior: instance_interruption_behavior,
                        instance_pools_to_use_count: instance_pools_to_use_count,
                        maintenance_strategies: maintenance_strategies,
                        max_total_price: max_total_price,
                        min_target_capacity: min_target_capacity,
                        single_availability_zone: single_availability_zone,
                        single_instance_type: single_instance_type,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::EC2Fleet.TagSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-tagspecification.html) property type.
    #[derive(Debug, Default)]
    pub struct TagSpecification {
        /// Property [`ResourceType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-tagspecification.html#cfn-ec2-ec2fleet-tagspecification-resourcetype).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub resource_type: Option<::Value<String>>,
        /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-tagspecification.html#cfn-ec2-ec2fleet-tagspecification-tags).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub tags: Option<::ValueList<::Tag>>,
    }

    impl ::codec::SerializeValue for TagSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref resource_type) = self.resource_type {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ResourceType", resource_type)?;
            }
            if let Some(ref tags) = self.tags {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for TagSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<TagSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = TagSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type TagSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut resource_type: Option<::Value<String>> = None;
                    let mut tags: Option<::ValueList<::Tag>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "ResourceType" => {
                                resource_type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Tags" => {
                                tags = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(TagSpecification {
                        resource_type: resource_type,
                        tags: tags,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::EC2Fleet.TargetCapacitySpecificationRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html) property type.
    #[derive(Debug, Default)]
    pub struct TargetCapacitySpecificationRequest {
        /// Property [`DefaultTargetCapacityType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-defaulttargetcapacitytype).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub default_target_capacity_type: Option<::Value<String>>,
        /// Property [`OnDemandTargetCapacity`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-ondemandtargetcapacity).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub on_demand_target_capacity: Option<::Value<u32>>,
        /// Property [`SpotTargetCapacity`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-spottargetcapacity).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub spot_target_capacity: Option<::Value<u32>>,
        /// Property [`TargetCapacityUnitType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-targetcapacityunittype).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub target_capacity_unit_type: Option<::Value<String>>,
        /// Property [`TotalTargetCapacity`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-totaltargetcapacity).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub total_target_capacity: ::Value<u32>,
    }

    impl ::codec::SerializeValue for TargetCapacitySpecificationRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref default_target_capacity_type) = self.default_target_capacity_type {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "DefaultTargetCapacityType", default_target_capacity_type)?;
            }
            if let Some(ref on_demand_target_capacity) = self.on_demand_target_capacity {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "OnDemandTargetCapacity", on_demand_target_capacity)?;
            }
            if let Some(ref spot_target_capacity) = self.spot_target_capacity {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SpotTargetCapacity", spot_target_capacity)?;
            }
            if let Some(ref target_capacity_unit_type) = self.target_capacity_unit_type {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "TargetCapacityUnitType", target_capacity_unit_type)?;
            }
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "TotalTargetCapacity", &self.total_target_capacity)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for TargetCapacitySpecificationRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<TargetCapacitySpecificationRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = TargetCapacitySpecificationRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type TargetCapacitySpecificationRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut default_target_capacity_type: Option<::Value<String>> = None;
                    let mut on_demand_target_capacity: Option<::Value<u32>> = None;
                    let mut spot_target_capacity: Option<::Value<u32>> = None;
                    let mut target_capacity_unit_type: Option<::Value<String>> = None;
                    let mut total_target_capacity: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "DefaultTargetCapacityType" => {
                                default_target_capacity_type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "OnDemandTargetCapacity" => {
                                on_demand_target_capacity = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SpotTargetCapacity" => {
                                spot_target_capacity = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "TargetCapacityUnitType" => {
                                target_capacity_unit_type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "TotalTargetCapacity" => {
                                total_target_capacity = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(TargetCapacitySpecificationRequest {
                        default_target_capacity_type: default_target_capacity_type,
                        on_demand_target_capacity: on_demand_target_capacity,
                        spot_target_capacity: spot_target_capacity,
                        target_capacity_unit_type: target_capacity_unit_type,
                        total_target_capacity: total_target_capacity.ok_or(::serde::de::Error::missing_field("TotalTargetCapacity"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::EC2Fleet.TotalLocalStorageGBRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-totallocalstoragegbrequest.html) property type.
    #[derive(Debug, Default)]
    pub struct TotalLocalStorageGBRequest {
        /// Property [`Max`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-totallocalstoragegbrequest.html#cfn-ec2-ec2fleet-totallocalstoragegbrequest-max).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub max: Option<::Value<f64>>,
        /// Property [`Min`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-totallocalstoragegbrequest.html#cfn-ec2-ec2fleet-totallocalstoragegbrequest-min).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub min: Option<::Value<f64>>,
    }

    impl ::codec::SerializeValue for TotalLocalStorageGBRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref max) = self.max {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Max", max)?;
            }
            if let Some(ref min) = self.min {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Min", min)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for TotalLocalStorageGBRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<TotalLocalStorageGBRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = TotalLocalStorageGBRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type TotalLocalStorageGBRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut max: Option<::Value<f64>> = None;
                    let mut min: Option<::Value<f64>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Max" => {
                                max = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Min" => {
                                min = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(TotalLocalStorageGBRequest {
                        max: max,
                        min: min,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::EC2Fleet.VCpuCountRangeRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-vcpucountrangerequest.html) property type.
    #[derive(Debug, Default)]
    pub struct VCpuCountRangeRequest {
        /// Property [`Max`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-vcpucountrangerequest.html#cfn-ec2-ec2fleet-vcpucountrangerequest-max).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub max: Option<::Value<u32>>,
        /// Property [`Min`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-vcpucountrangerequest.html#cfn-ec2-ec2fleet-vcpucountrangerequest-min).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub min: Option<::Value<u32>>,
    }

    impl ::codec::SerializeValue for VCpuCountRangeRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref max) = self.max {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Max", max)?;
            }
            if let Some(ref min) = self.min {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Min", min)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for VCpuCountRangeRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<VCpuCountRangeRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = VCpuCountRangeRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type VCpuCountRangeRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut max: Option<::Value<u32>> = None;
                    let mut min: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Max" => {
                                max = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Min" => {
                                min = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(VCpuCountRangeRequest {
                        max: max,
                        min: min,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }
}

pub mod flow_log {
    //! Property types for the `FlowLog` resource.

    /// The [`AWS::EC2::FlowLog.DestinationOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-flowlog-destinationoptions.html) property type.
    #[derive(Debug, Default)]
    pub struct DestinationOptions {
        /// Property [`FileFormat`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-flowlog-destinationoptions.html#cfn-ec2-flowlog-destinationoptions-fileformat).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub file_format: ::Value<String>,
        /// Property [`HiveCompatiblePartitions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-flowlog-destinationoptions.html#cfn-ec2-flowlog-destinationoptions-hivecompatiblepartitions).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub hive_compatible_partitions: ::Value<bool>,
        /// Property [`PerHourPartition`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-flowlog-destinationoptions.html#cfn-ec2-flowlog-destinationoptions-perhourpartition).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub per_hour_partition: ::Value<bool>,
    }

    impl ::codec::SerializeValue for DestinationOptions {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "FileFormat", &self.file_format)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "HiveCompatiblePartitions", &self.hive_compatible_partitions)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "PerHourPartition", &self.per_hour_partition)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for DestinationOptions {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<DestinationOptions, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = DestinationOptions;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type DestinationOptions")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut file_format: Option<::Value<String>> = None;
                    let mut hive_compatible_partitions: Option<::Value<bool>> = None;
                    let mut per_hour_partition: Option<::Value<bool>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "FileFormat" => {
                                file_format = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "HiveCompatiblePartitions" => {
                                hive_compatible_partitions = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "PerHourPartition" => {
                                per_hour_partition = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(DestinationOptions {
                        file_format: file_format.ok_or(::serde::de::Error::missing_field("FileFormat"))?,
                        hive_compatible_partitions: hive_compatible_partitions.ok_or(::serde::de::Error::missing_field("HiveCompatiblePartitions"))?,
                        per_hour_partition: per_hour_partition.ok_or(::serde::de::Error::missing_field("PerHourPartition"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }
}

pub mod ipam {
    //! Property types for the `IPAM` resource.

    /// The [`AWS::EC2::IPAM.IpamOperatingRegion`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipam-ipamoperatingregion.html) property type.
    #[derive(Debug, Default)]
    pub struct IpamOperatingRegion {
        /// Property [`RegionName`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipam-ipamoperatingregion.html#cfn-ec2-ipam-ipamoperatingregion-regionname).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub region_name: ::Value<String>,
    }

    impl ::codec::SerializeValue for IpamOperatingRegion {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "RegionName", &self.region_name)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for IpamOperatingRegion {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<IpamOperatingRegion, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = IpamOperatingRegion;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type IpamOperatingRegion")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut region_name: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "RegionName" => {
                                region_name = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(IpamOperatingRegion {
                        region_name: region_name.ok_or(::serde::de::Error::missing_field("RegionName"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }
}

pub mod ipam_pool {
    //! Property types for the `IPAMPool` resource.

    /// The [`AWS::EC2::IPAMPool.ProvisionedCidr`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-provisionedcidr.html) property type.
    #[derive(Debug, Default)]
    pub struct ProvisionedCidr {
        /// Property [`Cidr`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-provisionedcidr.html#cfn-ec2-ipampool-provisionedcidr-cidr).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub cidr: ::Value<String>,
    }

    impl ::codec::SerializeValue for ProvisionedCidr {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Cidr", &self.cidr)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for ProvisionedCidr {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<ProvisionedCidr, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = ProvisionedCidr;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type ProvisionedCidr")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut cidr: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Cidr" => {
                                cidr = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(ProvisionedCidr {
                        cidr: cidr.ok_or(::serde::de::Error::missing_field("Cidr"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::IPAMPool.SourceResource`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-sourceresource.html) property type.
    #[derive(Debug, Default)]
    pub struct SourceResource {
        /// Property [`ResourceId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-sourceresource.html#cfn-ec2-ipampool-sourceresource-resourceid).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub resource_id: ::Value<String>,
        /// Property [`ResourceOwner`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-sourceresource.html#cfn-ec2-ipampool-sourceresource-resourceowner).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub resource_owner: ::Value<String>,
        /// Property [`ResourceRegion`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-sourceresource.html#cfn-ec2-ipampool-sourceresource-resourceregion).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub resource_region: ::Value<String>,
        /// Property [`ResourceType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-sourceresource.html#cfn-ec2-ipampool-sourceresource-resourcetype).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub resource_type: ::Value<String>,
    }

    impl ::codec::SerializeValue for SourceResource {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "ResourceId", &self.resource_id)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "ResourceOwner", &self.resource_owner)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "ResourceRegion", &self.resource_region)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "ResourceType", &self.resource_type)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for SourceResource {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<SourceResource, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = SourceResource;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type SourceResource")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut resource_id: Option<::Value<String>> = None;
                    let mut resource_owner: Option<::Value<String>> = None;
                    let mut resource_region: Option<::Value<String>> = None;
                    let mut resource_type: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "ResourceId" => {
                                resource_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ResourceOwner" => {
                                resource_owner = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ResourceRegion" => {
                                resource_region = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ResourceType" => {
                                resource_type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(SourceResource {
                        resource_id: resource_id.ok_or(::serde::de::Error::missing_field("ResourceId"))?,
                        resource_owner: resource_owner.ok_or(::serde::de::Error::missing_field("ResourceOwner"))?,
                        resource_region: resource_region.ok_or(::serde::de::Error::missing_field("ResourceRegion"))?,
                        resource_type: resource_type.ok_or(::serde::de::Error::missing_field("ResourceType"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }
}

pub mod ipam_resource_discovery {
    //! Property types for the `IPAMResourceDiscovery` resource.

    /// The [`AWS::EC2::IPAMResourceDiscovery.IpamOperatingRegion`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipamresourcediscovery-ipamoperatingregion.html) property type.
    #[derive(Debug, Default)]
    pub struct IpamOperatingRegion {
        /// Property [`RegionName`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipamresourcediscovery-ipamoperatingregion.html#cfn-ec2-ipamresourcediscovery-ipamoperatingregion-regionname).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub region_name: ::Value<String>,
    }

    impl ::codec::SerializeValue for IpamOperatingRegion {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "RegionName", &self.region_name)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for IpamOperatingRegion {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<IpamOperatingRegion, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = IpamOperatingRegion;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type IpamOperatingRegion")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut region_name: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "RegionName" => {
                                region_name = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(IpamOperatingRegion {
                        region_name: region_name.ok_or(::serde::de::Error::missing_field("RegionName"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }
}

pub mod instance {
    //! Property types for the `Instance` resource.

    /// The [`AWS::EC2::Instance.AssociationParameter`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociations-associationparameters.html) property type.
    #[derive(Debug, Default)]
    pub struct AssociationParameter {
        /// Property [`Key`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociations-associationparameters.html#cfn-ec2-instance-ssmassociations-associationparameters-key).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub key: ::Value<String>,
        /// Property [`Value`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociations-associationparameters.html#cfn-ec2-instance-ssmassociations-associationparameters-value).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub value: ::ValueList<String>,
    }

    impl ::codec::SerializeValue for AssociationParameter {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Key", &self.key)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Value", &self.value)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for AssociationParameter {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<AssociationParameter, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = AssociationParameter;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type AssociationParameter")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut key: Option<::Value<String>> = None;
                    let mut value: Option<::ValueList<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Key" => {
                                key = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Value" => {
                                value = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(AssociationParameter {
                        key: key.ok_or(::serde::de::Error::missing_field("Key"))?,
                        value: value.ok_or(::serde::de::Error::missing_field("Value"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::Instance.BlockDeviceMapping`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-blockdev-mapping.html) property type.
    #[derive(Debug, Default)]
    pub struct BlockDeviceMapping {
        /// Property [`DeviceName`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-blockdev-mapping.html#cfn-ec2-blockdev-mapping-devicename).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub device_name: ::Value<String>,
        /// Property [`Ebs`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-blockdev-mapping.html#cfn-ec2-blockdev-mapping-ebs).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub ebs: Option<::Value<Ebs>>,
        /// Property [`NoDevice`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-blockdev-mapping.html#cfn-ec2-blockdev-mapping-nodevice).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub no_device: Option<::Value<NoDevice>>,
        /// Property [`VirtualName`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-blockdev-mapping.html#cfn-ec2-blockdev-mapping-virtualname).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub virtual_name: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for BlockDeviceMapping {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "DeviceName", &self.device_name)?;
            if let Some(ref ebs) = self.ebs {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ebs", ebs)?;
            }
            if let Some(ref no_device) = self.no_device {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "NoDevice", no_device)?;
            }
            if let Some(ref virtual_name) = self.virtual_name {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "VirtualName", virtual_name)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for BlockDeviceMapping {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<BlockDeviceMapping, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = BlockDeviceMapping;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type BlockDeviceMapping")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut device_name: Option<::Value<String>> = None;
                    let mut ebs: Option<::Value<Ebs>> = None;
                    let mut no_device: Option<::Value<NoDevice>> = None;
                    let mut virtual_name: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "DeviceName" => {
                                device_name = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Ebs" => {
                                ebs = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "NoDevice" => {
                                no_device = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "VirtualName" => {
                                virtual_name = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(BlockDeviceMapping {
                        device_name: device_name.ok_or(::serde::de::Error::missing_field("DeviceName"))?,
                        ebs: ebs,
                        no_device: no_device,
                        virtual_name: virtual_name,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::Instance.CpuOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html) property type.
    #[derive(Debug, Default)]
    pub struct CpuOptions {
        /// Property [`CoreCount`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-corecount).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub core_count: Option<::Value<u32>>,
        /// Property [`ThreadsPerCore`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-threadspercore).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub threads_per_core: Option<::Value<u32>>,
    }

    impl ::codec::SerializeValue for CpuOptions {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref core_count) = self.core_count {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "CoreCount", core_count)?;
            }
            if let Some(ref threads_per_core) = self.threads_per_core {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ThreadsPerCore", threads_per_core)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for CpuOptions {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<CpuOptions, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = CpuOptions;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type CpuOptions")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut core_count: Option<::Value<u32>> = None;
                    let mut threads_per_core: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "CoreCount" => {
                                core_count = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ThreadsPerCore" => {
                                threads_per_core = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(CpuOptions {
                        core_count: core_count,
                        threads_per_core: threads_per_core,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::Instance.CreditSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html) property type.
    #[derive(Debug, Default)]
    pub struct CreditSpecification {
        /// Property [`CPUCredits`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-cpucredits).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub cpu_credits: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for CreditSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref cpu_credits) = self.cpu_credits {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "CPUCredits", cpu_credits)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for CreditSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<CreditSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = CreditSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type CreditSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut cpu_credits: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "CPUCredits" => {
                                cpu_credits = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(CreditSpecification {
                        cpu_credits: cpu_credits,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::Instance.Ebs`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-blockdev-template.html) property type.
    #[derive(Debug, Default)]
    pub struct Ebs {
        /// Property [`DeleteOnTermination`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-blockdev-template.html#cfn-ec2-blockdev-template-deleteontermination).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub delete_on_termination: Option<::Value<bool>>,
        /// Property [`Encrypted`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-blockdev-template.html#cfn-ec2-blockdev-template-encrypted).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub encrypted: Option<::Value<bool>>,
        /// Property [`Iops`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-blockdev-template.html#cfn-ec2-blockdev-template-iops).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub iops: Option<::Value<u32>>,
        /// Property [`KmsKeyId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-blockdev-template.html#cfn-ec2-instance-ebs-kmskeyid).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub kms_key_id: Option<::Value<String>>,
        /// Property [`SnapshotId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-blockdev-template.html#cfn-ec2-blockdev-template-snapshotid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub snapshot_id: Option<::Value<String>>,
        /// Property [`VolumeSize`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-blockdev-template.html#cfn-ec2-blockdev-template-volumesize).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub volume_size: Option<::Value<u32>>,
        /// Property [`VolumeType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-blockdev-template.html#cfn-ec2-blockdev-template-volumetype).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub volume_type: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for Ebs {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref delete_on_termination) = self.delete_on_termination {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "DeleteOnTermination", delete_on_termination)?;
            }
            if let Some(ref encrypted) = self.encrypted {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Encrypted", encrypted)?;
            }
            if let Some(ref iops) = self.iops {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Iops", iops)?;
            }
            if let Some(ref kms_key_id) = self.kms_key_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "KmsKeyId", kms_key_id)?;
            }
            if let Some(ref snapshot_id) = self.snapshot_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SnapshotId", snapshot_id)?;
            }
            if let Some(ref volume_size) = self.volume_size {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "VolumeSize", volume_size)?;
            }
            if let Some(ref volume_type) = self.volume_type {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "VolumeType", volume_type)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for Ebs {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<Ebs, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = Ebs;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type Ebs")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut delete_on_termination: Option<::Value<bool>> = None;
                    let mut encrypted: Option<::Value<bool>> = None;
                    let mut iops: Option<::Value<u32>> = None;
                    let mut kms_key_id: Option<::Value<String>> = None;
                    let mut snapshot_id: Option<::Value<String>> = None;
                    let mut volume_size: Option<::Value<u32>> = None;
                    let mut volume_type: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "DeleteOnTermination" => {
                                delete_on_termination = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Encrypted" => {
                                encrypted = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Iops" => {
                                iops = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "KmsKeyId" => {
                                kms_key_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SnapshotId" => {
                                snapshot_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "VolumeSize" => {
                                volume_size = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "VolumeType" => {
                                volume_type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(Ebs {
                        delete_on_termination: delete_on_termination,
                        encrypted: encrypted,
                        iops: iops,
                        kms_key_id: kms_key_id,
                        snapshot_id: snapshot_id,
                        volume_size: volume_size,
                        volume_type: volume_type,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::Instance.ElasticGpuSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html) property type.
    #[derive(Debug, Default)]
    pub struct ElasticGpuSpecification {
        /// Property [`Type`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-type).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub r#type: ::Value<String>,
    }

    impl ::codec::SerializeValue for ElasticGpuSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Type", &self.r#type)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for ElasticGpuSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<ElasticGpuSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = ElasticGpuSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type ElasticGpuSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut r#type: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Type" => {
                                r#type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(ElasticGpuSpecification {
                        r#type: r#type.ok_or(::serde::de::Error::missing_field("Type"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::Instance.ElasticInferenceAccelerator`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html) property type.
    #[derive(Debug, Default)]
    pub struct ElasticInferenceAccelerator {
        /// Property [`Count`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-count).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub count: Option<::Value<u32>>,
        /// Property [`Type`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-type).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub r#type: ::Value<String>,
    }

    impl ::codec::SerializeValue for ElasticInferenceAccelerator {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref count) = self.count {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Count", count)?;
            }
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Type", &self.r#type)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for ElasticInferenceAccelerator {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<ElasticInferenceAccelerator, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = ElasticInferenceAccelerator;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type ElasticInferenceAccelerator")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut count: Option<::Value<u32>> = None;
                    let mut r#type: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Count" => {
                                count = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Type" => {
                                r#type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(ElasticInferenceAccelerator {
                        count: count,
                        r#type: r#type.ok_or(::serde::de::Error::missing_field("Type"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::Instance.EnclaveOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html) property type.
    #[derive(Debug, Default)]
    pub struct EnclaveOptions {
        /// Property [`Enabled`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-enabled).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub enabled: Option<::Value<bool>>,
    }

    impl ::codec::SerializeValue for EnclaveOptions {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref enabled) = self.enabled {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Enabled", enabled)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for EnclaveOptions {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<EnclaveOptions, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = EnclaveOptions;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type EnclaveOptions")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut enabled: Option<::Value<bool>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Enabled" => {
                                enabled = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(EnclaveOptions {
                        enabled: enabled,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::Instance.HibernationOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html) property type.
    #[derive(Debug, Default)]
    pub struct HibernationOptions {
        /// Property [`Configured`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-configured).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub configured: Option<::Value<bool>>,
    }

    impl ::codec::SerializeValue for HibernationOptions {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref configured) = self.configured {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Configured", configured)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for HibernationOptions {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<HibernationOptions, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = HibernationOptions;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type HibernationOptions")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut configured: Option<::Value<bool>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Configured" => {
                                configured = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(HibernationOptions {
                        configured: configured,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::Instance.InstanceIpv6Address`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html) property type.
    #[derive(Debug, Default)]
    pub struct InstanceIpv6Address {
        /// Property [`Ipv6Address`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-ipv6address).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub ipv6_address: ::Value<String>,
    }

    impl ::codec::SerializeValue for InstanceIpv6Address {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6Address", &self.ipv6_address)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for InstanceIpv6Address {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<InstanceIpv6Address, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = InstanceIpv6Address;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type InstanceIpv6Address")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut ipv6_address: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Ipv6Address" => {
                                ipv6_address = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(InstanceIpv6Address {
                        ipv6_address: ipv6_address.ok_or(::serde::de::Error::missing_field("Ipv6Address"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::Instance.LaunchTemplateSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html) property type.
    #[derive(Debug, Default)]
    pub struct LaunchTemplateSpecification {
        /// Property [`LaunchTemplateId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-launchtemplateid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub launch_template_id: Option<::Value<String>>,
        /// Property [`LaunchTemplateName`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-launchtemplatename).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub launch_template_name: Option<::Value<String>>,
        /// Property [`Version`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-version).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub version: ::Value<String>,
    }

    impl ::codec::SerializeValue for LaunchTemplateSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref launch_template_id) = self.launch_template_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "LaunchTemplateId", launch_template_id)?;
            }
            if let Some(ref launch_template_name) = self.launch_template_name {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "LaunchTemplateName", launch_template_name)?;
            }
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Version", &self.version)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for LaunchTemplateSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<LaunchTemplateSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = LaunchTemplateSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type LaunchTemplateSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut launch_template_id: Option<::Value<String>> = None;
                    let mut launch_template_name: Option<::Value<String>> = None;
                    let mut version: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "LaunchTemplateId" => {
                                launch_template_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "LaunchTemplateName" => {
                                launch_template_name = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Version" => {
                                version = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(LaunchTemplateSpecification {
                        launch_template_id: launch_template_id,
                        launch_template_name: launch_template_name,
                        version: version.ok_or(::serde::de::Error::missing_field("Version"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::Instance.LicenseSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html) property type.
    #[derive(Debug, Default)]
    pub struct LicenseSpecification {
        /// Property [`LicenseConfigurationArn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-licenseconfigurationarn).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub license_configuration_arn: ::Value<String>,
    }

    impl ::codec::SerializeValue for LicenseSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "LicenseConfigurationArn", &self.license_configuration_arn)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for LicenseSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<LicenseSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = LicenseSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type LicenseSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut license_configuration_arn: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "LicenseConfigurationArn" => {
                                license_configuration_arn = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(LicenseSpecification {
                        license_configuration_arn: license_configuration_arn.ok_or(::serde::de::Error::missing_field("LicenseConfigurationArn"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::Instance.NetworkInterface`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-iface-embedded.html) property type.
    #[derive(Debug, Default)]
    pub struct NetworkInterface {
        /// Property [`AssociateCarrierIpAddress`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-iface-embedded.html#cfn-ec2-instance-networkinterface-associatecarrieripaddress).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub associate_carrier_ip_address: Option<::Value<bool>>,
        /// Property [`AssociatePublicIpAddress`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-iface-embedded.html#aws-properties-ec2-network-iface-embedded-associatepubip).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub associate_public_ip_address: Option<::Value<bool>>,
        /// Property [`DeleteOnTermination`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-iface-embedded.html#aws-properties-ec2-network-iface-embedded-delete).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub delete_on_termination: Option<::Value<bool>>,
        /// Property [`Description`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-iface-embedded.html#aws-properties-ec2-network-iface-embedded-description).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub description: Option<::Value<String>>,
        /// Property [`DeviceIndex`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-iface-embedded.html#aws-properties-ec2-network-iface-embedded-deviceindex).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub device_index: ::Value<String>,
        /// Property [`GroupSet`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-iface-embedded.html#aws-properties-ec2-network-iface-embedded-groupset).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub group_set: Option<::ValueList<String>>,
        /// Property [`Ipv6AddressCount`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-iface-embedded.html#cfn-ec2-instance-networkinterface-ipv6addresscount).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub ipv6_address_count: Option<::Value<u32>>,
        /// Property [`Ipv6Addresses`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-iface-embedded.html#cfn-ec2-instance-networkinterface-ipv6addresses).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub ipv6_addresses: Option<::ValueList<InstanceIpv6Address>>,
        /// Property [`NetworkInterfaceId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-iface-embedded.html#aws-properties-ec2-network-iface-embedded-network-iface).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub network_interface_id: Option<::Value<String>>,
        /// Property [`PrivateIpAddress`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-iface-embedded.html#aws-properties-ec2-network-iface-embedded-privateipaddress).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub private_ip_address: Option<::Value<String>>,
        /// Property [`PrivateIpAddresses`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-iface-embedded.html#aws-properties-ec2-network-iface-embedded-privateipaddresses).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub private_ip_addresses: Option<::ValueList<PrivateIpAddressSpecification>>,
        /// Property [`SecondaryPrivateIpAddressCount`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-iface-embedded.html#aws-properties-ec2-network-iface-embedded-secondprivateip).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub secondary_private_ip_address_count: Option<::Value<u32>>,
        /// Property [`SubnetId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-iface-embedded.html#aws-properties-ec2-network-iface-embedded-subnetid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub subnet_id: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for NetworkInterface {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref associate_carrier_ip_address) = self.associate_carrier_ip_address {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AssociateCarrierIpAddress", associate_carrier_ip_address)?;
            }
            if let Some(ref associate_public_ip_address) = self.associate_public_ip_address {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AssociatePublicIpAddress", associate_public_ip_address)?;
            }
            if let Some(ref delete_on_termination) = self.delete_on_termination {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "DeleteOnTermination", delete_on_termination)?;
            }
            if let Some(ref description) = self.description {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Description", description)?;
            }
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "DeviceIndex", &self.device_index)?;
            if let Some(ref group_set) = self.group_set {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "GroupSet", group_set)?;
            }
            if let Some(ref ipv6_address_count) = self.ipv6_address_count {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6AddressCount", ipv6_address_count)?;
            }
            if let Some(ref ipv6_addresses) = self.ipv6_addresses {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6Addresses", ipv6_addresses)?;
            }
            if let Some(ref network_interface_id) = self.network_interface_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetworkInterfaceId", network_interface_id)?;
            }
            if let Some(ref private_ip_address) = self.private_ip_address {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "PrivateIpAddress", private_ip_address)?;
            }
            if let Some(ref private_ip_addresses) = self.private_ip_addresses {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "PrivateIpAddresses", private_ip_addresses)?;
            }
            if let Some(ref secondary_private_ip_address_count) = self.secondary_private_ip_address_count {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SecondaryPrivateIpAddressCount", secondary_private_ip_address_count)?;
            }
            if let Some(ref subnet_id) = self.subnet_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SubnetId", subnet_id)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for NetworkInterface {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<NetworkInterface, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = NetworkInterface;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type NetworkInterface")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut associate_carrier_ip_address: Option<::Value<bool>> = None;
                    let mut associate_public_ip_address: Option<::Value<bool>> = None;
                    let mut delete_on_termination: Option<::Value<bool>> = None;
                    let mut description: Option<::Value<String>> = None;
                    let mut device_index: Option<::Value<String>> = None;
                    let mut group_set: Option<::ValueList<String>> = None;
                    let mut ipv6_address_count: Option<::Value<u32>> = None;
                    let mut ipv6_addresses: Option<::ValueList<InstanceIpv6Address>> = None;
                    let mut network_interface_id: Option<::Value<String>> = None;
                    let mut private_ip_address: Option<::Value<String>> = None;
                    let mut private_ip_addresses: Option<::ValueList<PrivateIpAddressSpecification>> = None;
                    let mut secondary_private_ip_address_count: Option<::Value<u32>> = None;
                    let mut subnet_id: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "AssociateCarrierIpAddress" => {
                                associate_carrier_ip_address = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "AssociatePublicIpAddress" => {
                                associate_public_ip_address = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "DeleteOnTermination" => {
                                delete_on_termination = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Description" => {
                                description = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "DeviceIndex" => {
                                device_index = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "GroupSet" => {
                                group_set = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Ipv6AddressCount" => {
                                ipv6_address_count = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Ipv6Addresses" => {
                                ipv6_addresses = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "NetworkInterfaceId" => {
                                network_interface_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "PrivateIpAddress" => {
                                private_ip_address = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "PrivateIpAddresses" => {
                                private_ip_addresses = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SecondaryPrivateIpAddressCount" => {
                                secondary_private_ip_address_count = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SubnetId" => {
                                subnet_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(NetworkInterface {
                        associate_carrier_ip_address: associate_carrier_ip_address,
                        associate_public_ip_address: associate_public_ip_address,
                        delete_on_termination: delete_on_termination,
                        description: description,
                        device_index: device_index.ok_or(::serde::de::Error::missing_field("DeviceIndex"))?,
                        group_set: group_set,
                        ipv6_address_count: ipv6_address_count,
                        ipv6_addresses: ipv6_addresses,
                        network_interface_id: network_interface_id,
                        private_ip_address: private_ip_address,
                        private_ip_addresses: private_ip_addresses,
                        secondary_private_ip_address_count: secondary_private_ip_address_count,
                        subnet_id: subnet_id,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::Instance.NoDevice`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-nodevice.html) property type.
    #[derive(Debug, Default)]
    pub struct NoDevice {
    }

    impl ::codec::SerializeValue for NoDevice {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let map = ::serde::Serializer::serialize_map(s, None)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for NoDevice {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<NoDevice, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = NoDevice;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type NoDevice")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, _map: A) -> Result<Self::Value, A::Error> {
                    Ok(NoDevice {})
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::Instance.PrivateDnsNameOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html) property type.
    #[derive(Debug, Default)]
    pub struct PrivateDnsNameOptions {
        /// Property [`EnableResourceNameDnsAAAARecord`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-enableresourcenamednsaaaarecord).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub enable_resource_name_dns_aaaa_record: Option<::Value<bool>>,
        /// Property [`EnableResourceNameDnsARecord`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-enableresourcenamednsarecord).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub enable_resource_name_dns_a_record: Option<::Value<bool>>,
        /// Property [`HostnameType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-hostnametype).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub hostname_type: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for PrivateDnsNameOptions {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref enable_resource_name_dns_aaaa_record) = self.enable_resource_name_dns_aaaa_record {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "EnableResourceNameDnsAAAARecord", enable_resource_name_dns_aaaa_record)?;
            }
            if let Some(ref enable_resource_name_dns_a_record) = self.enable_resource_name_dns_a_record {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "EnableResourceNameDnsARecord", enable_resource_name_dns_a_record)?;
            }
            if let Some(ref hostname_type) = self.hostname_type {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "HostnameType", hostname_type)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for PrivateDnsNameOptions {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<PrivateDnsNameOptions, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = PrivateDnsNameOptions;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type PrivateDnsNameOptions")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut enable_resource_name_dns_aaaa_record: Option<::Value<bool>> = None;
                    let mut enable_resource_name_dns_a_record: Option<::Value<bool>> = None;
                    let mut hostname_type: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "EnableResourceNameDnsAAAARecord" => {
                                enable_resource_name_dns_aaaa_record = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "EnableResourceNameDnsARecord" => {
                                enable_resource_name_dns_a_record = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "HostnameType" => {
                                hostname_type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(PrivateDnsNameOptions {
                        enable_resource_name_dns_aaaa_record: enable_resource_name_dns_aaaa_record,
                        enable_resource_name_dns_a_record: enable_resource_name_dns_a_record,
                        hostname_type: hostname_type,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::Instance.PrivateIpAddressSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-interface-privateipspec.html) property type.
    #[derive(Debug, Default)]
    pub struct PrivateIpAddressSpecification {
        /// Property [`Primary`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-interface-privateipspec.html#cfn-ec2-networkinterface-privateipspecification-primary).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub primary: ::Value<bool>,
        /// Property [`PrivateIpAddress`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-interface-privateipspec.html#cfn-ec2-networkinterface-privateipspecification-privateipaddress).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub private_ip_address: ::Value<String>,
    }

    impl ::codec::SerializeValue for PrivateIpAddressSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Primary", &self.primary)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "PrivateIpAddress", &self.private_ip_address)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for PrivateIpAddressSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<PrivateIpAddressSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = PrivateIpAddressSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type PrivateIpAddressSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut primary: Option<::Value<bool>> = None;
                    let mut private_ip_address: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Primary" => {
                                primary = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "PrivateIpAddress" => {
                                private_ip_address = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(PrivateIpAddressSpecification {
                        primary: primary.ok_or(::serde::de::Error::missing_field("Primary"))?,
                        private_ip_address: private_ip_address.ok_or(::serde::de::Error::missing_field("PrivateIpAddress"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::Instance.SsmAssociation`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociations.html) property type.
    #[derive(Debug, Default)]
    pub struct SsmAssociation {
        /// Property [`AssociationParameters`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociations.html#cfn-ec2-instance-ssmassociations-associationparameters).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub association_parameters: Option<::ValueList<AssociationParameter>>,
        /// Property [`DocumentName`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociations.html#cfn-ec2-instance-ssmassociations-documentname).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub document_name: ::Value<String>,
    }

    impl ::codec::SerializeValue for SsmAssociation {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref association_parameters) = self.association_parameters {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AssociationParameters", association_parameters)?;
            }
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "DocumentName", &self.document_name)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for SsmAssociation {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<SsmAssociation, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = SsmAssociation;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type SsmAssociation")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut association_parameters: Option<::ValueList<AssociationParameter>> = None;
                    let mut document_name: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "AssociationParameters" => {
                                association_parameters = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "DocumentName" => {
                                document_name = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(SsmAssociation {
                        association_parameters: association_parameters,
                        document_name: document_name.ok_or(::serde::de::Error::missing_field("DocumentName"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::Instance.Volume`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-mount-point.html) property type.
    #[derive(Debug, Default)]
    pub struct Volume {
        /// Property [`Device`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-mount-point.html#cfn-ec2-mountpoint-device).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub device: ::Value<String>,
        /// Property [`VolumeId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-mount-point.html#cfn-ec2-mountpoint-volumeid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub volume_id: ::Value<String>,
    }

    impl ::codec::SerializeValue for Volume {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Device", &self.device)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "VolumeId", &self.volume_id)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for Volume {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<Volume, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = Volume;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type Volume")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut device: Option<::Value<String>> = None;
                    let mut volume_id: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Device" => {
                                device = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "VolumeId" => {
                                volume_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(Volume {
                        device: device.ok_or(::serde::de::Error::missing_field("Device"))?,
                        volume_id: volume_id.ok_or(::serde::de::Error::missing_field("VolumeId"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }
}

pub mod launch_template {
    //! Property types for the `LaunchTemplate` resource.

    /// The [`AWS::EC2::LaunchTemplate.AcceleratorCount`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-acceleratorcount.html) property type.
    #[derive(Debug, Default)]
    pub struct AcceleratorCount {
        /// Property [`Max`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-acceleratorcount.html#cfn-ec2-launchtemplate-acceleratorcount-max).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub max: Option<::Value<u32>>,
        /// Property [`Min`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-acceleratorcount.html#cfn-ec2-launchtemplate-acceleratorcount-min).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub min: Option<::Value<u32>>,
    }

    impl ::codec::SerializeValue for AcceleratorCount {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref max) = self.max {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Max", max)?;
            }
            if let Some(ref min) = self.min {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Min", min)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for AcceleratorCount {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<AcceleratorCount, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = AcceleratorCount;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type AcceleratorCount")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut max: Option<::Value<u32>> = None;
                    let mut min: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Max" => {
                                max = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Min" => {
                                min = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(AcceleratorCount {
                        max: max,
                        min: min,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.AcceleratorTotalMemoryMiB`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-acceleratortotalmemorymib.html) property type.
    #[derive(Debug, Default)]
    pub struct AcceleratorTotalMemoryMiB {
        /// Property [`Max`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-acceleratortotalmemorymib.html#cfn-ec2-launchtemplate-acceleratortotalmemorymib-max).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub max: Option<::Value<u32>>,
        /// Property [`Min`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-acceleratortotalmemorymib.html#cfn-ec2-launchtemplate-acceleratortotalmemorymib-min).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub min: Option<::Value<u32>>,
    }

    impl ::codec::SerializeValue for AcceleratorTotalMemoryMiB {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref max) = self.max {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Max", max)?;
            }
            if let Some(ref min) = self.min {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Min", min)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for AcceleratorTotalMemoryMiB {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<AcceleratorTotalMemoryMiB, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = AcceleratorTotalMemoryMiB;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type AcceleratorTotalMemoryMiB")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut max: Option<::Value<u32>> = None;
                    let mut min: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Max" => {
                                max = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Min" => {
                                min = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(AcceleratorTotalMemoryMiB {
                        max: max,
                        min: min,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.BaselineEbsBandwidthMbps`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-baselineebsbandwidthmbps.html) property type.
    #[derive(Debug, Default)]
    pub struct BaselineEbsBandwidthMbps {
        /// Property [`Max`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-baselineebsbandwidthmbps.html#cfn-ec2-launchtemplate-baselineebsbandwidthmbps-max).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub max: Option<::Value<u32>>,
        /// Property [`Min`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-baselineebsbandwidthmbps.html#cfn-ec2-launchtemplate-baselineebsbandwidthmbps-min).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub min: Option<::Value<u32>>,
    }

    impl ::codec::SerializeValue for BaselineEbsBandwidthMbps {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref max) = self.max {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Max", max)?;
            }
            if let Some(ref min) = self.min {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Min", min)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for BaselineEbsBandwidthMbps {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<BaselineEbsBandwidthMbps, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = BaselineEbsBandwidthMbps;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type BaselineEbsBandwidthMbps")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut max: Option<::Value<u32>> = None;
                    let mut min: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Max" => {
                                max = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Min" => {
                                min = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(BaselineEbsBandwidthMbps {
                        max: max,
                        min: min,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.BlockDeviceMapping`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html) property type.
    #[derive(Debug, Default)]
    pub struct BlockDeviceMapping {
        /// Property [`DeviceName`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html#cfn-ec2-launchtemplate-blockdevicemapping-devicename).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub device_name: Option<::Value<String>>,
        /// Property [`Ebs`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html#cfn-ec2-launchtemplate-blockdevicemapping-ebs).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub ebs: Option<::Value<Ebs>>,
        /// Property [`NoDevice`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html#cfn-ec2-launchtemplate-blockdevicemapping-nodevice).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub no_device: Option<::Value<String>>,
        /// Property [`VirtualName`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html#cfn-ec2-launchtemplate-blockdevicemapping-virtualname).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub virtual_name: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for BlockDeviceMapping {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref device_name) = self.device_name {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "DeviceName", device_name)?;
            }
            if let Some(ref ebs) = self.ebs {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ebs", ebs)?;
            }
            if let Some(ref no_device) = self.no_device {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "NoDevice", no_device)?;
            }
            if let Some(ref virtual_name) = self.virtual_name {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "VirtualName", virtual_name)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for BlockDeviceMapping {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<BlockDeviceMapping, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = BlockDeviceMapping;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type BlockDeviceMapping")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut device_name: Option<::Value<String>> = None;
                    let mut ebs: Option<::Value<Ebs>> = None;
                    let mut no_device: Option<::Value<String>> = None;
                    let mut virtual_name: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "DeviceName" => {
                                device_name = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Ebs" => {
                                ebs = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "NoDevice" => {
                                no_device = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "VirtualName" => {
                                virtual_name = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(BlockDeviceMapping {
                        device_name: device_name,
                        ebs: ebs,
                        no_device: no_device,
                        virtual_name: virtual_name,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.CapacityReservationSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-capacityreservationspecification.html) property type.
    #[derive(Debug, Default)]
    pub struct CapacityReservationSpecification {
        /// Property [`CapacityReservationPreference`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-capacityreservationspecification.html#cfn-ec2-launchtemplate-capacityreservationspecification-capacityreservationpreference).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub capacity_reservation_preference: Option<::Value<String>>,
        /// Property [`CapacityReservationTarget`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-capacityreservationspecification.html#cfn-ec2-launchtemplate-capacityreservationspecification-capacityreservationtarget).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub capacity_reservation_target: Option<::Value<CapacityReservationTarget>>,
    }

    impl ::codec::SerializeValue for CapacityReservationSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref capacity_reservation_preference) = self.capacity_reservation_preference {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "CapacityReservationPreference", capacity_reservation_preference)?;
            }
            if let Some(ref capacity_reservation_target) = self.capacity_reservation_target {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "CapacityReservationTarget", capacity_reservation_target)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for CapacityReservationSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<CapacityReservationSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = CapacityReservationSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type CapacityReservationSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut capacity_reservation_preference: Option<::Value<String>> = None;
                    let mut capacity_reservation_target: Option<::Value<CapacityReservationTarget>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "CapacityReservationPreference" => {
                                capacity_reservation_preference = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "CapacityReservationTarget" => {
                                capacity_reservation_target = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(CapacityReservationSpecification {
                        capacity_reservation_preference: capacity_reservation_preference,
                        capacity_reservation_target: capacity_reservation_target,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.CapacityReservationTarget`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-capacityreservationtarget.html) property type.
    #[derive(Debug, Default)]
    pub struct CapacityReservationTarget {
        /// Property [`CapacityReservationId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-capacityreservationtarget.html#cfn-ec2-launchtemplate-capacityreservationtarget-capacityreservationid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub capacity_reservation_id: Option<::Value<String>>,
        /// Property [`CapacityReservationResourceGroupArn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-capacityreservationtarget.html#cfn-ec2-launchtemplate-capacityreservationtarget-capacityreservationresourcegrouparn).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub capacity_reservation_resource_group_arn: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for CapacityReservationTarget {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref capacity_reservation_id) = self.capacity_reservation_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "CapacityReservationId", capacity_reservation_id)?;
            }
            if let Some(ref capacity_reservation_resource_group_arn) = self.capacity_reservation_resource_group_arn {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "CapacityReservationResourceGroupArn", capacity_reservation_resource_group_arn)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for CapacityReservationTarget {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<CapacityReservationTarget, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = CapacityReservationTarget;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type CapacityReservationTarget")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut capacity_reservation_id: Option<::Value<String>> = None;
                    let mut capacity_reservation_resource_group_arn: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "CapacityReservationId" => {
                                capacity_reservation_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "CapacityReservationResourceGroupArn" => {
                                capacity_reservation_resource_group_arn = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(CapacityReservationTarget {
                        capacity_reservation_id: capacity_reservation_id,
                        capacity_reservation_resource_group_arn: capacity_reservation_resource_group_arn,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.ConnectionTrackingSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-connectiontrackingspecification.html) property type.
    #[derive(Debug, Default)]
    pub struct ConnectionTrackingSpecification {
        /// Property [`TcpEstablishedTimeout`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-connectiontrackingspecification.html#cfn-ec2-launchtemplate-connectiontrackingspecification-tcpestablishedtimeout).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub tcp_established_timeout: Option<::Value<u32>>,
        /// Property [`UdpStreamTimeout`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-connectiontrackingspecification.html#cfn-ec2-launchtemplate-connectiontrackingspecification-udpstreamtimeout).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub udp_stream_timeout: Option<::Value<u32>>,
        /// Property [`UdpTimeout`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-connectiontrackingspecification.html#cfn-ec2-launchtemplate-connectiontrackingspecification-udptimeout).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub udp_timeout: Option<::Value<u32>>,
    }

    impl ::codec::SerializeValue for ConnectionTrackingSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref tcp_established_timeout) = self.tcp_established_timeout {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "TcpEstablishedTimeout", tcp_established_timeout)?;
            }
            if let Some(ref udp_stream_timeout) = self.udp_stream_timeout {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "UdpStreamTimeout", udp_stream_timeout)?;
            }
            if let Some(ref udp_timeout) = self.udp_timeout {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "UdpTimeout", udp_timeout)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for ConnectionTrackingSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<ConnectionTrackingSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = ConnectionTrackingSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type ConnectionTrackingSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut tcp_established_timeout: Option<::Value<u32>> = None;
                    let mut udp_stream_timeout: Option<::Value<u32>> = None;
                    let mut udp_timeout: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "TcpEstablishedTimeout" => {
                                tcp_established_timeout = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "UdpStreamTimeout" => {
                                udp_stream_timeout = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "UdpTimeout" => {
                                udp_timeout = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(ConnectionTrackingSpecification {
                        tcp_established_timeout: tcp_established_timeout,
                        udp_stream_timeout: udp_stream_timeout,
                        udp_timeout: udp_timeout,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.CpuOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-cpuoptions.html) property type.
    #[derive(Debug, Default)]
    pub struct CpuOptions {
        /// Property [`AmdSevSnp`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-cpuoptions.html#cfn-ec2-launchtemplate-cpuoptions-amdsevsnp).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub amd_sev_snp: Option<::Value<String>>,
        /// Property [`CoreCount`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-cpuoptions.html#cfn-ec2-launchtemplate-cpuoptions-corecount).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub core_count: Option<::Value<u32>>,
        /// Property [`ThreadsPerCore`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-cpuoptions.html#cfn-ec2-launchtemplate-cpuoptions-threadspercore).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub threads_per_core: Option<::Value<u32>>,
    }

    impl ::codec::SerializeValue for CpuOptions {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref amd_sev_snp) = self.amd_sev_snp {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AmdSevSnp", amd_sev_snp)?;
            }
            if let Some(ref core_count) = self.core_count {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "CoreCount", core_count)?;
            }
            if let Some(ref threads_per_core) = self.threads_per_core {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ThreadsPerCore", threads_per_core)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for CpuOptions {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<CpuOptions, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = CpuOptions;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type CpuOptions")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut amd_sev_snp: Option<::Value<String>> = None;
                    let mut core_count: Option<::Value<u32>> = None;
                    let mut threads_per_core: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "AmdSevSnp" => {
                                amd_sev_snp = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "CoreCount" => {
                                core_count = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ThreadsPerCore" => {
                                threads_per_core = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(CpuOptions {
                        amd_sev_snp: amd_sev_snp,
                        core_count: core_count,
                        threads_per_core: threads_per_core,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.CreditSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-creditspecification.html) property type.
    #[derive(Debug, Default)]
    pub struct CreditSpecification {
        /// Property [`CpuCredits`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-creditspecification.html#cfn-ec2-launchtemplate-creditspecification-cpucredits).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub cpu_credits: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for CreditSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref cpu_credits) = self.cpu_credits {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "CpuCredits", cpu_credits)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for CreditSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<CreditSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = CreditSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type CreditSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut cpu_credits: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "CpuCredits" => {
                                cpu_credits = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(CreditSpecification {
                        cpu_credits: cpu_credits,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.Ebs`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html) property type.
    #[derive(Debug, Default)]
    pub struct Ebs {
        /// Property [`DeleteOnTermination`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html#cfn-ec2-launchtemplate-ebs-deleteontermination).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub delete_on_termination: Option<::Value<bool>>,
        /// Property [`Encrypted`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html#cfn-ec2-launchtemplate-ebs-encrypted).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub encrypted: Option<::Value<bool>>,
        /// Property [`Iops`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html#cfn-ec2-launchtemplate-ebs-iops).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub iops: Option<::Value<u32>>,
        /// Property [`KmsKeyId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html#cfn-ec2-launchtemplate-ebs-kmskeyid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub kms_key_id: Option<::Value<String>>,
        /// Property [`SnapshotId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html#cfn-ec2-launchtemplate-ebs-snapshotid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub snapshot_id: Option<::Value<String>>,
        /// Property [`Throughput`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html#cfn-ec2-launchtemplate-ebs-throughput).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub throughput: Option<::Value<u32>>,
        /// Property [`VolumeSize`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html#cfn-ec2-launchtemplate-ebs-volumesize).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub volume_size: Option<::Value<u32>>,
        /// Property [`VolumeType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ebs.html#cfn-ec2-launchtemplate-ebs-volumetype).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub volume_type: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for Ebs {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref delete_on_termination) = self.delete_on_termination {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "DeleteOnTermination", delete_on_termination)?;
            }
            if let Some(ref encrypted) = self.encrypted {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Encrypted", encrypted)?;
            }
            if let Some(ref iops) = self.iops {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Iops", iops)?;
            }
            if let Some(ref kms_key_id) = self.kms_key_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "KmsKeyId", kms_key_id)?;
            }
            if let Some(ref snapshot_id) = self.snapshot_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SnapshotId", snapshot_id)?;
            }
            if let Some(ref throughput) = self.throughput {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Throughput", throughput)?;
            }
            if let Some(ref volume_size) = self.volume_size {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "VolumeSize", volume_size)?;
            }
            if let Some(ref volume_type) = self.volume_type {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "VolumeType", volume_type)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for Ebs {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<Ebs, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = Ebs;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type Ebs")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut delete_on_termination: Option<::Value<bool>> = None;
                    let mut encrypted: Option<::Value<bool>> = None;
                    let mut iops: Option<::Value<u32>> = None;
                    let mut kms_key_id: Option<::Value<String>> = None;
                    let mut snapshot_id: Option<::Value<String>> = None;
                    let mut throughput: Option<::Value<u32>> = None;
                    let mut volume_size: Option<::Value<u32>> = None;
                    let mut volume_type: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "DeleteOnTermination" => {
                                delete_on_termination = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Encrypted" => {
                                encrypted = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Iops" => {
                                iops = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "KmsKeyId" => {
                                kms_key_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SnapshotId" => {
                                snapshot_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Throughput" => {
                                throughput = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "VolumeSize" => {
                                volume_size = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "VolumeType" => {
                                volume_type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(Ebs {
                        delete_on_termination: delete_on_termination,
                        encrypted: encrypted,
                        iops: iops,
                        kms_key_id: kms_key_id,
                        snapshot_id: snapshot_id,
                        throughput: throughput,
                        volume_size: volume_size,
                        volume_type: volume_type,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.ElasticGpuSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-elasticgpuspecification.html) property type.
    #[derive(Debug, Default)]
    pub struct ElasticGpuSpecification {
        /// Property [`Type`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-elasticgpuspecification.html#cfn-ec2-launchtemplate-elasticgpuspecification-type).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub r#type: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for ElasticGpuSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref r#type) = self.r#type {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Type", r#type)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for ElasticGpuSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<ElasticGpuSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = ElasticGpuSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type ElasticGpuSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut r#type: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Type" => {
                                r#type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(ElasticGpuSpecification {
                        r#type: r#type,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.EnaSrdSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-enasrdspecification.html) property type.
    #[derive(Debug, Default)]
    pub struct EnaSrdSpecification {
        /// Property [`EnaSrdEnabled`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-enasrdspecification.html#cfn-ec2-launchtemplate-enasrdspecification-enasrdenabled).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub ena_srd_enabled: Option<::Value<bool>>,
        /// Property [`EnaSrdUdpSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-enasrdspecification.html#cfn-ec2-launchtemplate-enasrdspecification-enasrdudpspecification).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub ena_srd_udp_specification: Option<::Value<EnaSrdUdpSpecification>>,
    }

    impl ::codec::SerializeValue for EnaSrdSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref ena_srd_enabled) = self.ena_srd_enabled {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "EnaSrdEnabled", ena_srd_enabled)?;
            }
            if let Some(ref ena_srd_udp_specification) = self.ena_srd_udp_specification {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "EnaSrdUdpSpecification", ena_srd_udp_specification)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for EnaSrdSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<EnaSrdSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = EnaSrdSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type EnaSrdSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut ena_srd_enabled: Option<::Value<bool>> = None;
                    let mut ena_srd_udp_specification: Option<::Value<EnaSrdUdpSpecification>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "EnaSrdEnabled" => {
                                ena_srd_enabled = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "EnaSrdUdpSpecification" => {
                                ena_srd_udp_specification = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(EnaSrdSpecification {
                        ena_srd_enabled: ena_srd_enabled,
                        ena_srd_udp_specification: ena_srd_udp_specification,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.EnaSrdUdpSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-enasrdudpspecification.html) property type.
    #[derive(Debug, Default)]
    pub struct EnaSrdUdpSpecification {
        /// Property [`EnaSrdUdpEnabled`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-enasrdudpspecification.html#cfn-ec2-launchtemplate-enasrdudpspecification-enasrdudpenabled).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub ena_srd_udp_enabled: Option<::Value<bool>>,
    }

    impl ::codec::SerializeValue for EnaSrdUdpSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref ena_srd_udp_enabled) = self.ena_srd_udp_enabled {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "EnaSrdUdpEnabled", ena_srd_udp_enabled)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for EnaSrdUdpSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<EnaSrdUdpSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = EnaSrdUdpSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type EnaSrdUdpSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut ena_srd_udp_enabled: Option<::Value<bool>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "EnaSrdUdpEnabled" => {
                                ena_srd_udp_enabled = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(EnaSrdUdpSpecification {
                        ena_srd_udp_enabled: ena_srd_udp_enabled,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.EnclaveOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-enclaveoptions.html) property type.
    #[derive(Debug, Default)]
    pub struct EnclaveOptions {
        /// Property [`Enabled`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-enclaveoptions.html#cfn-ec2-launchtemplate-enclaveoptions-enabled).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub enabled: Option<::Value<bool>>,
    }

    impl ::codec::SerializeValue for EnclaveOptions {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref enabled) = self.enabled {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Enabled", enabled)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for EnclaveOptions {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<EnclaveOptions, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = EnclaveOptions;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type EnclaveOptions")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut enabled: Option<::Value<bool>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Enabled" => {
                                enabled = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(EnclaveOptions {
                        enabled: enabled,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.HibernationOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-hibernationoptions.html) property type.
    #[derive(Debug, Default)]
    pub struct HibernationOptions {
        /// Property [`Configured`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-hibernationoptions.html#cfn-ec2-launchtemplate-hibernationoptions-configured).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub configured: Option<::Value<bool>>,
    }

    impl ::codec::SerializeValue for HibernationOptions {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref configured) = self.configured {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Configured", configured)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for HibernationOptions {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<HibernationOptions, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = HibernationOptions;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type HibernationOptions")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut configured: Option<::Value<bool>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Configured" => {
                                configured = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(HibernationOptions {
                        configured: configured,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.IamInstanceProfile`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-iaminstanceprofile.html) property type.
    #[derive(Debug, Default)]
    pub struct IamInstanceProfile {
        /// Property [`Arn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-iaminstanceprofile.html#cfn-ec2-launchtemplate-iaminstanceprofile-arn).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub arn: Option<::Value<String>>,
        /// Property [`Name`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-iaminstanceprofile.html#cfn-ec2-launchtemplate-iaminstanceprofile-name).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub name: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for IamInstanceProfile {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref arn) = self.arn {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Arn", arn)?;
            }
            if let Some(ref name) = self.name {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Name", name)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for IamInstanceProfile {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<IamInstanceProfile, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = IamInstanceProfile;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type IamInstanceProfile")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut arn: Option<::Value<String>> = None;
                    let mut name: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Arn" => {
                                arn = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Name" => {
                                name = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(IamInstanceProfile {
                        arn: arn,
                        name: name,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.InstanceMarketOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancemarketoptions.html) property type.
    #[derive(Debug, Default)]
    pub struct InstanceMarketOptions {
        /// Property [`MarketType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancemarketoptions.html#cfn-ec2-launchtemplate-instancemarketoptions-markettype).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub market_type: Option<::Value<String>>,
        /// Property [`SpotOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancemarketoptions.html#cfn-ec2-launchtemplate-instancemarketoptions-spotoptions).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub spot_options: Option<::Value<SpotOptions>>,
    }

    impl ::codec::SerializeValue for InstanceMarketOptions {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref market_type) = self.market_type {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "MarketType", market_type)?;
            }
            if let Some(ref spot_options) = self.spot_options {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SpotOptions", spot_options)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for InstanceMarketOptions {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<InstanceMarketOptions, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = InstanceMarketOptions;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type InstanceMarketOptions")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut market_type: Option<::Value<String>> = None;
                    let mut spot_options: Option<::Value<SpotOptions>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "MarketType" => {
                                market_type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SpotOptions" => {
                                spot_options = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(InstanceMarketOptions {
                        market_type: market_type,
                        spot_options: spot_options,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.InstanceRequirements`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html) property type.
    #[derive(Debug, Default)]
    pub struct InstanceRequirements {
        /// Property [`AcceleratorCount`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-acceleratorcount).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub accelerator_count: Option<::Value<AcceleratorCount>>,
        /// Property [`AcceleratorManufacturers`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-acceleratormanufacturers).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub accelerator_manufacturers: Option<::ValueList<String>>,
        /// Property [`AcceleratorNames`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-acceleratornames).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub accelerator_names: Option<::ValueList<String>>,
        /// Property [`AcceleratorTotalMemoryMiB`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-acceleratortotalmemorymib).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub accelerator_total_memory_mi_b: Option<::Value<AcceleratorTotalMemoryMiB>>,
        /// Property [`AcceleratorTypes`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-acceleratortypes).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub accelerator_types: Option<::ValueList<String>>,
        /// Property [`AllowedInstanceTypes`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-allowedinstancetypes).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub allowed_instance_types: Option<::ValueList<String>>,
        /// Property [`BareMetal`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-baremetal).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub bare_metal: Option<::Value<String>>,
        /// Property [`BaselineEbsBandwidthMbps`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-baselineebsbandwidthmbps).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub baseline_ebs_bandwidth_mbps: Option<::Value<BaselineEbsBandwidthMbps>>,
        /// Property [`BurstablePerformance`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-burstableperformance).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub burstable_performance: Option<::Value<String>>,
        /// Property [`CpuManufacturers`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-cpumanufacturers).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub cpu_manufacturers: Option<::ValueList<String>>,
        /// Property [`ExcludedInstanceTypes`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-excludedinstancetypes).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub excluded_instance_types: Option<::ValueList<String>>,
        /// Property [`InstanceGenerations`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-instancegenerations).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub instance_generations: Option<::ValueList<String>>,
        /// Property [`LocalStorage`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-localstorage).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub local_storage: Option<::Value<String>>,
        /// Property [`LocalStorageTypes`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-localstoragetypes).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub local_storage_types: Option<::ValueList<String>>,
        /// Property [`MaxSpotPriceAsPercentageOfOptimalOnDemandPrice`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-maxspotpriceaspercentageofoptimalondemandprice).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub max_spot_price_as_percentage_of_optimal_on_demand_price: Option<::Value<u32>>,
        /// Property [`MemoryGiBPerVCpu`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-memorygibpervcpu).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub memory_gi_b_per_v_cpu: Option<::Value<MemoryGiBPerVCpu>>,
        /// Property [`MemoryMiB`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-memorymib).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub memory_mi_b: Option<::Value<MemoryMiB>>,
        /// Property [`NetworkBandwidthGbps`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-networkbandwidthgbps).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub network_bandwidth_gbps: Option<::Value<NetworkBandwidthGbps>>,
        /// Property [`NetworkInterfaceCount`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-networkinterfacecount).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub network_interface_count: Option<::Value<NetworkInterfaceCount>>,
        /// Property [`OnDemandMaxPricePercentageOverLowestPrice`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-ondemandmaxpricepercentageoverlowestprice).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub on_demand_max_price_percentage_over_lowest_price: Option<::Value<u32>>,
        /// Property [`RequireHibernateSupport`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-requirehibernatesupport).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub require_hibernate_support: Option<::Value<bool>>,
        /// Property [`SpotMaxPricePercentageOverLowestPrice`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-spotmaxpricepercentageoverlowestprice).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub spot_max_price_percentage_over_lowest_price: Option<::Value<u32>>,
        /// Property [`TotalLocalStorageGB`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-totallocalstoragegb).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub total_local_storage_gb: Option<::Value<TotalLocalStorageGB>>,
        /// Property [`VCpuCount`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-instancerequirements.html#cfn-ec2-launchtemplate-instancerequirements-vcpucount).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub v_cpu_count: Option<::Value<VCpuCount>>,
    }

    impl ::codec::SerializeValue for InstanceRequirements {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref accelerator_count) = self.accelerator_count {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AcceleratorCount", accelerator_count)?;
            }
            if let Some(ref accelerator_manufacturers) = self.accelerator_manufacturers {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AcceleratorManufacturers", accelerator_manufacturers)?;
            }
            if let Some(ref accelerator_names) = self.accelerator_names {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AcceleratorNames", accelerator_names)?;
            }
            if let Some(ref accelerator_total_memory_mi_b) = self.accelerator_total_memory_mi_b {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AcceleratorTotalMemoryMiB", accelerator_total_memory_mi_b)?;
            }
            if let Some(ref accelerator_types) = self.accelerator_types {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AcceleratorTypes", accelerator_types)?;
            }
            if let Some(ref allowed_instance_types) = self.allowed_instance_types {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AllowedInstanceTypes", allowed_instance_types)?;
            }
            if let Some(ref bare_metal) = self.bare_metal {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "BareMetal", bare_metal)?;
            }
            if let Some(ref baseline_ebs_bandwidth_mbps) = self.baseline_ebs_bandwidth_mbps {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "BaselineEbsBandwidthMbps", baseline_ebs_bandwidth_mbps)?;
            }
            if let Some(ref burstable_performance) = self.burstable_performance {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "BurstablePerformance", burstable_performance)?;
            }
            if let Some(ref cpu_manufacturers) = self.cpu_manufacturers {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "CpuManufacturers", cpu_manufacturers)?;
            }
            if let Some(ref excluded_instance_types) = self.excluded_instance_types {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ExcludedInstanceTypes", excluded_instance_types)?;
            }
            if let Some(ref instance_generations) = self.instance_generations {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstanceGenerations", instance_generations)?;
            }
            if let Some(ref local_storage) = self.local_storage {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "LocalStorage", local_storage)?;
            }
            if let Some(ref local_storage_types) = self.local_storage_types {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "LocalStorageTypes", local_storage_types)?;
            }
            if let Some(ref max_spot_price_as_percentage_of_optimal_on_demand_price) = self.max_spot_price_as_percentage_of_optimal_on_demand_price {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "MaxSpotPriceAsPercentageOfOptimalOnDemandPrice", max_spot_price_as_percentage_of_optimal_on_demand_price)?;
            }
            if let Some(ref memory_gi_b_per_v_cpu) = self.memory_gi_b_per_v_cpu {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "MemoryGiBPerVCpu", memory_gi_b_per_v_cpu)?;
            }
            if let Some(ref memory_mi_b) = self.memory_mi_b {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "MemoryMiB", memory_mi_b)?;
            }
            if let Some(ref network_bandwidth_gbps) = self.network_bandwidth_gbps {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetworkBandwidthGbps", network_bandwidth_gbps)?;
            }
            if let Some(ref network_interface_count) = self.network_interface_count {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetworkInterfaceCount", network_interface_count)?;
            }
            if let Some(ref on_demand_max_price_percentage_over_lowest_price) = self.on_demand_max_price_percentage_over_lowest_price {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "OnDemandMaxPricePercentageOverLowestPrice", on_demand_max_price_percentage_over_lowest_price)?;
            }
            if let Some(ref require_hibernate_support) = self.require_hibernate_support {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "RequireHibernateSupport", require_hibernate_support)?;
            }
            if let Some(ref spot_max_price_percentage_over_lowest_price) = self.spot_max_price_percentage_over_lowest_price {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SpotMaxPricePercentageOverLowestPrice", spot_max_price_percentage_over_lowest_price)?;
            }
            if let Some(ref total_local_storage_gb) = self.total_local_storage_gb {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "TotalLocalStorageGB", total_local_storage_gb)?;
            }
            if let Some(ref v_cpu_count) = self.v_cpu_count {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "VCpuCount", v_cpu_count)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for InstanceRequirements {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<InstanceRequirements, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = InstanceRequirements;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type InstanceRequirements")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut accelerator_count: Option<::Value<AcceleratorCount>> = None;
                    let mut accelerator_manufacturers: Option<::ValueList<String>> = None;
                    let mut accelerator_names: Option<::ValueList<String>> = None;
                    let mut accelerator_total_memory_mi_b: Option<::Value<AcceleratorTotalMemoryMiB>> = None;
                    let mut accelerator_types: Option<::ValueList<String>> = None;
                    let mut allowed_instance_types: Option<::ValueList<String>> = None;
                    let mut bare_metal: Option<::Value<String>> = None;
                    let mut baseline_ebs_bandwidth_mbps: Option<::Value<BaselineEbsBandwidthMbps>> = None;
                    let mut burstable_performance: Option<::Value<String>> = None;
                    let mut cpu_manufacturers: Option<::ValueList<String>> = None;
                    let mut excluded_instance_types: Option<::ValueList<String>> = None;
                    let mut instance_generations: Option<::ValueList<String>> = None;
                    let mut local_storage: Option<::Value<String>> = None;
                    let mut local_storage_types: Option<::ValueList<String>> = None;
                    let mut max_spot_price_as_percentage_of_optimal_on_demand_price: Option<::Value<u32>> = None;
                    let mut memory_gi_b_per_v_cpu: Option<::Value<MemoryGiBPerVCpu>> = None;
                    let mut memory_mi_b: Option<::Value<MemoryMiB>> = None;
                    let mut network_bandwidth_gbps: Option<::Value<NetworkBandwidthGbps>> = None;
                    let mut network_interface_count: Option<::Value<NetworkInterfaceCount>> = None;
                    let mut on_demand_max_price_percentage_over_lowest_price: Option<::Value<u32>> = None;
                    let mut require_hibernate_support: Option<::Value<bool>> = None;
                    let mut spot_max_price_percentage_over_lowest_price: Option<::Value<u32>> = None;
                    let mut total_local_storage_gb: Option<::Value<TotalLocalStorageGB>> = None;
                    let mut v_cpu_count: Option<::Value<VCpuCount>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "AcceleratorCount" => {
                                accelerator_count = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "AcceleratorManufacturers" => {
                                accelerator_manufacturers = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "AcceleratorNames" => {
                                accelerator_names = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "AcceleratorTotalMemoryMiB" => {
                                accelerator_total_memory_mi_b = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "AcceleratorTypes" => {
                                accelerator_types = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "AllowedInstanceTypes" => {
                                allowed_instance_types = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "BareMetal" => {
                                bare_metal = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "BaselineEbsBandwidthMbps" => {
                                baseline_ebs_bandwidth_mbps = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "BurstablePerformance" => {
                                burstable_performance = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "CpuManufacturers" => {
                                cpu_manufacturers = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ExcludedInstanceTypes" => {
                                excluded_instance_types = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "InstanceGenerations" => {
                                instance_generations = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "LocalStorage" => {
                                local_storage = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "LocalStorageTypes" => {
                                local_storage_types = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "MaxSpotPriceAsPercentageOfOptimalOnDemandPrice" => {
                                max_spot_price_as_percentage_of_optimal_on_demand_price = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "MemoryGiBPerVCpu" => {
                                memory_gi_b_per_v_cpu = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "MemoryMiB" => {
                                memory_mi_b = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "NetworkBandwidthGbps" => {
                                network_bandwidth_gbps = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "NetworkInterfaceCount" => {
                                network_interface_count = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "OnDemandMaxPricePercentageOverLowestPrice" => {
                                on_demand_max_price_percentage_over_lowest_price = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "RequireHibernateSupport" => {
                                require_hibernate_support = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SpotMaxPricePercentageOverLowestPrice" => {
                                spot_max_price_percentage_over_lowest_price = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "TotalLocalStorageGB" => {
                                total_local_storage_gb = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "VCpuCount" => {
                                v_cpu_count = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(InstanceRequirements {
                        accelerator_count: accelerator_count,
                        accelerator_manufacturers: accelerator_manufacturers,
                        accelerator_names: accelerator_names,
                        accelerator_total_memory_mi_b: accelerator_total_memory_mi_b,
                        accelerator_types: accelerator_types,
                        allowed_instance_types: allowed_instance_types,
                        bare_metal: bare_metal,
                        baseline_ebs_bandwidth_mbps: baseline_ebs_bandwidth_mbps,
                        burstable_performance: burstable_performance,
                        cpu_manufacturers: cpu_manufacturers,
                        excluded_instance_types: excluded_instance_types,
                        instance_generations: instance_generations,
                        local_storage: local_storage,
                        local_storage_types: local_storage_types,
                        max_spot_price_as_percentage_of_optimal_on_demand_price: max_spot_price_as_percentage_of_optimal_on_demand_price,
                        memory_gi_b_per_v_cpu: memory_gi_b_per_v_cpu,
                        memory_mi_b: memory_mi_b,
                        network_bandwidth_gbps: network_bandwidth_gbps,
                        network_interface_count: network_interface_count,
                        on_demand_max_price_percentage_over_lowest_price: on_demand_max_price_percentage_over_lowest_price,
                        require_hibernate_support: require_hibernate_support,
                        spot_max_price_percentage_over_lowest_price: spot_max_price_percentage_over_lowest_price,
                        total_local_storage_gb: total_local_storage_gb,
                        v_cpu_count: v_cpu_count,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.Ipv4PrefixSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ipv4prefixspecification.html) property type.
    #[derive(Debug, Default)]
    pub struct Ipv4PrefixSpecification {
        /// Property [`Ipv4Prefix`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ipv4prefixspecification.html#cfn-ec2-launchtemplate-ipv4prefixspecification-ipv4prefix).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub ipv4_prefix: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for Ipv4PrefixSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref ipv4_prefix) = self.ipv4_prefix {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv4Prefix", ipv4_prefix)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for Ipv4PrefixSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<Ipv4PrefixSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = Ipv4PrefixSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type Ipv4PrefixSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut ipv4_prefix: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Ipv4Prefix" => {
                                ipv4_prefix = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(Ipv4PrefixSpecification {
                        ipv4_prefix: ipv4_prefix,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.Ipv6Add`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ipv6add.html) property type.
    #[derive(Debug, Default)]
    pub struct Ipv6Add {
        /// Property [`Ipv6Address`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ipv6add.html#cfn-ec2-launchtemplate-ipv6add-ipv6address).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub ipv6_address: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for Ipv6Add {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref ipv6_address) = self.ipv6_address {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6Address", ipv6_address)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for Ipv6Add {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<Ipv6Add, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = Ipv6Add;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type Ipv6Add")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut ipv6_address: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Ipv6Address" => {
                                ipv6_address = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(Ipv6Add {
                        ipv6_address: ipv6_address,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.Ipv6PrefixSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ipv6prefixspecification.html) property type.
    #[derive(Debug, Default)]
    pub struct Ipv6PrefixSpecification {
        /// Property [`Ipv6Prefix`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ipv6prefixspecification.html#cfn-ec2-launchtemplate-ipv6prefixspecification-ipv6prefix).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub ipv6_prefix: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for Ipv6PrefixSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref ipv6_prefix) = self.ipv6_prefix {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6Prefix", ipv6_prefix)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for Ipv6PrefixSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<Ipv6PrefixSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = Ipv6PrefixSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type Ipv6PrefixSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut ipv6_prefix: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Ipv6Prefix" => {
                                ipv6_prefix = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(Ipv6PrefixSpecification {
                        ipv6_prefix: ipv6_prefix,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.LaunchTemplateData`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) property type.
    #[derive(Debug, Default)]
    pub struct LaunchTemplateData {
        /// Property [`BlockDeviceMappings`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-blockdevicemappings).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub block_device_mappings: Option<::ValueList<BlockDeviceMapping>>,
        /// Property [`CapacityReservationSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-capacityreservationspecification).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub capacity_reservation_specification: Option<::Value<CapacityReservationSpecification>>,
        /// Property [`CpuOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-cpuoptions).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub cpu_options: Option<::Value<CpuOptions>>,
        /// Property [`CreditSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-creditspecification).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub credit_specification: Option<::Value<CreditSpecification>>,
        /// Property [`DisableApiStop`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-disableapistop).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub disable_api_stop: Option<::Value<bool>>,
        /// Property [`DisableApiTermination`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-disableapitermination).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub disable_api_termination: Option<::Value<bool>>,
        /// Property [`EbsOptimized`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-ebsoptimized).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub ebs_optimized: Option<::Value<bool>>,
        /// Property [`ElasticGpuSpecifications`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-elasticgpuspecifications).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub elastic_gpu_specifications: Option<::ValueList<ElasticGpuSpecification>>,
        /// Property [`ElasticInferenceAccelerators`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-elasticinferenceaccelerators).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub elastic_inference_accelerators: Option<::ValueList<LaunchTemplateElasticInferenceAccelerator>>,
        /// Property [`EnclaveOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-enclaveoptions).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub enclave_options: Option<::Value<EnclaveOptions>>,
        /// Property [`HibernationOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-hibernationoptions).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub hibernation_options: Option<::Value<HibernationOptions>>,
        /// Property [`IamInstanceProfile`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-iaminstanceprofile).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub iam_instance_profile: Option<::Value<IamInstanceProfile>>,
        /// Property [`ImageId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-imageid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub image_id: Option<::Value<String>>,
        /// Property [`InstanceInitiatedShutdownBehavior`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-instanceinitiatedshutdownbehavior).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub instance_initiated_shutdown_behavior: Option<::Value<String>>,
        /// Property [`InstanceMarketOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-instancemarketoptions).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub instance_market_options: Option<::Value<InstanceMarketOptions>>,
        /// Property [`InstanceRequirements`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-instancerequirements).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub instance_requirements: Option<::Value<InstanceRequirements>>,
        /// Property [`InstanceType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-instancetype).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub instance_type: Option<::Value<String>>,
        /// Property [`KernelId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-kernelid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub kernel_id: Option<::Value<String>>,
        /// Property [`KeyName`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-keyname).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub key_name: Option<::Value<String>>,
        /// Property [`LicenseSpecifications`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-licensespecifications).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub license_specifications: Option<::ValueList<LicenseSpecification>>,
        /// Property [`MaintenanceOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-maintenanceoptions).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub maintenance_options: Option<::Value<MaintenanceOptions>>,
        /// Property [`MetadataOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-metadataoptions).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub metadata_options: Option<::Value<MetadataOptions>>,
        /// Property [`Monitoring`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-monitoring).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub monitoring: Option<::Value<Monitoring>>,
        /// Property [`NetworkInterfaces`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-networkinterfaces).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub network_interfaces: Option<::ValueList<NetworkInterface>>,
        /// Property [`Placement`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-placement).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub placement: Option<::Value<Placement>>,
        /// Property [`PrivateDnsNameOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-privatednsnameoptions).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub private_dns_name_options: Option<::Value<PrivateDnsNameOptions>>,
        /// Property [`RamDiskId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-ramdiskid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub ram_disk_id: Option<::Value<String>>,
        /// Property [`SecurityGroupIds`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-securitygroupids).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub security_group_ids: Option<::ValueList<String>>,
        /// Property [`SecurityGroups`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-securitygroups).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub security_groups: Option<::ValueList<String>>,
        /// Property [`TagSpecifications`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-tagspecifications).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub tag_specifications: Option<::ValueList<TagSpecification>>,
        /// Property [`UserData`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-userdata).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub user_data: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for LaunchTemplateData {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref block_device_mappings) = self.block_device_mappings {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "BlockDeviceMappings", block_device_mappings)?;
            }
            if let Some(ref capacity_reservation_specification) = self.capacity_reservation_specification {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "CapacityReservationSpecification", capacity_reservation_specification)?;
            }
            if let Some(ref cpu_options) = self.cpu_options {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "CpuOptions", cpu_options)?;
            }
            if let Some(ref credit_specification) = self.credit_specification {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "CreditSpecification", credit_specification)?;
            }
            if let Some(ref disable_api_stop) = self.disable_api_stop {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "DisableApiStop", disable_api_stop)?;
            }
            if let Some(ref disable_api_termination) = self.disable_api_termination {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "DisableApiTermination", disable_api_termination)?;
            }
            if let Some(ref ebs_optimized) = self.ebs_optimized {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "EbsOptimized", ebs_optimized)?;
            }
            if let Some(ref elastic_gpu_specifications) = self.elastic_gpu_specifications {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ElasticGpuSpecifications", elastic_gpu_specifications)?;
            }
            if let Some(ref elastic_inference_accelerators) = self.elastic_inference_accelerators {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ElasticInferenceAccelerators", elastic_inference_accelerators)?;
            }
            if let Some(ref enclave_options) = self.enclave_options {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "EnclaveOptions", enclave_options)?;
            }
            if let Some(ref hibernation_options) = self.hibernation_options {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "HibernationOptions", hibernation_options)?;
            }
            if let Some(ref iam_instance_profile) = self.iam_instance_profile {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "IamInstanceProfile", iam_instance_profile)?;
            }
            if let Some(ref image_id) = self.image_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ImageId", image_id)?;
            }
            if let Some(ref instance_initiated_shutdown_behavior) = self.instance_initiated_shutdown_behavior {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstanceInitiatedShutdownBehavior", instance_initiated_shutdown_behavior)?;
            }
            if let Some(ref instance_market_options) = self.instance_market_options {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstanceMarketOptions", instance_market_options)?;
            }
            if let Some(ref instance_requirements) = self.instance_requirements {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstanceRequirements", instance_requirements)?;
            }
            if let Some(ref instance_type) = self.instance_type {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstanceType", instance_type)?;
            }
            if let Some(ref kernel_id) = self.kernel_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "KernelId", kernel_id)?;
            }
            if let Some(ref key_name) = self.key_name {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "KeyName", key_name)?;
            }
            if let Some(ref license_specifications) = self.license_specifications {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "LicenseSpecifications", license_specifications)?;
            }
            if let Some(ref maintenance_options) = self.maintenance_options {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "MaintenanceOptions", maintenance_options)?;
            }
            if let Some(ref metadata_options) = self.metadata_options {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "MetadataOptions", metadata_options)?;
            }
            if let Some(ref monitoring) = self.monitoring {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Monitoring", monitoring)?;
            }
            if let Some(ref network_interfaces) = self.network_interfaces {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetworkInterfaces", network_interfaces)?;
            }
            if let Some(ref placement) = self.placement {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Placement", placement)?;
            }
            if let Some(ref private_dns_name_options) = self.private_dns_name_options {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "PrivateDnsNameOptions", private_dns_name_options)?;
            }
            if let Some(ref ram_disk_id) = self.ram_disk_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "RamDiskId", ram_disk_id)?;
            }
            if let Some(ref security_group_ids) = self.security_group_ids {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SecurityGroupIds", security_group_ids)?;
            }
            if let Some(ref security_groups) = self.security_groups {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SecurityGroups", security_groups)?;
            }
            if let Some(ref tag_specifications) = self.tag_specifications {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "TagSpecifications", tag_specifications)?;
            }
            if let Some(ref user_data) = self.user_data {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "UserData", user_data)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for LaunchTemplateData {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<LaunchTemplateData, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = LaunchTemplateData;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type LaunchTemplateData")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut block_device_mappings: Option<::ValueList<BlockDeviceMapping>> = None;
                    let mut capacity_reservation_specification: Option<::Value<CapacityReservationSpecification>> = None;
                    let mut cpu_options: Option<::Value<CpuOptions>> = None;
                    let mut credit_specification: Option<::Value<CreditSpecification>> = None;
                    let mut disable_api_stop: Option<::Value<bool>> = None;
                    let mut disable_api_termination: Option<::Value<bool>> = None;
                    let mut ebs_optimized: Option<::Value<bool>> = None;
                    let mut elastic_gpu_specifications: Option<::ValueList<ElasticGpuSpecification>> = None;
                    let mut elastic_inference_accelerators: Option<::ValueList<LaunchTemplateElasticInferenceAccelerator>> = None;
                    let mut enclave_options: Option<::Value<EnclaveOptions>> = None;
                    let mut hibernation_options: Option<::Value<HibernationOptions>> = None;
                    let mut iam_instance_profile: Option<::Value<IamInstanceProfile>> = None;
                    let mut image_id: Option<::Value<String>> = None;
                    let mut instance_initiated_shutdown_behavior: Option<::Value<String>> = None;
                    let mut instance_market_options: Option<::Value<InstanceMarketOptions>> = None;
                    let mut instance_requirements: Option<::Value<InstanceRequirements>> = None;
                    let mut instance_type: Option<::Value<String>> = None;
                    let mut kernel_id: Option<::Value<String>> = None;
                    let mut key_name: Option<::Value<String>> = None;
                    let mut license_specifications: Option<::ValueList<LicenseSpecification>> = None;
                    let mut maintenance_options: Option<::Value<MaintenanceOptions>> = None;
                    let mut metadata_options: Option<::Value<MetadataOptions>> = None;
                    let mut monitoring: Option<::Value<Monitoring>> = None;
                    let mut network_interfaces: Option<::ValueList<NetworkInterface>> = None;
                    let mut placement: Option<::Value<Placement>> = None;
                    let mut private_dns_name_options: Option<::Value<PrivateDnsNameOptions>> = None;
                    let mut ram_disk_id: Option<::Value<String>> = None;
                    let mut security_group_ids: Option<::ValueList<String>> = None;
                    let mut security_groups: Option<::ValueList<String>> = None;
                    let mut tag_specifications: Option<::ValueList<TagSpecification>> = None;
                    let mut user_data: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "BlockDeviceMappings" => {
                                block_device_mappings = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "CapacityReservationSpecification" => {
                                capacity_reservation_specification = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "CpuOptions" => {
                                cpu_options = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "CreditSpecification" => {
                                credit_specification = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "DisableApiStop" => {
                                disable_api_stop = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "DisableApiTermination" => {
                                disable_api_termination = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "EbsOptimized" => {
                                ebs_optimized = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ElasticGpuSpecifications" => {
                                elastic_gpu_specifications = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ElasticInferenceAccelerators" => {
                                elastic_inference_accelerators = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "EnclaveOptions" => {
                                enclave_options = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "HibernationOptions" => {
                                hibernation_options = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "IamInstanceProfile" => {
                                iam_instance_profile = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ImageId" => {
                                image_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "InstanceInitiatedShutdownBehavior" => {
                                instance_initiated_shutdown_behavior = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "InstanceMarketOptions" => {
                                instance_market_options = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "InstanceRequirements" => {
                                instance_requirements = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "InstanceType" => {
                                instance_type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "KernelId" => {
                                kernel_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "KeyName" => {
                                key_name = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "LicenseSpecifications" => {
                                license_specifications = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "MaintenanceOptions" => {
                                maintenance_options = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "MetadataOptions" => {
                                metadata_options = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Monitoring" => {
                                monitoring = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "NetworkInterfaces" => {
                                network_interfaces = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Placement" => {
                                placement = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "PrivateDnsNameOptions" => {
                                private_dns_name_options = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "RamDiskId" => {
                                ram_disk_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SecurityGroupIds" => {
                                security_group_ids = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SecurityGroups" => {
                                security_groups = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "TagSpecifications" => {
                                tag_specifications = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "UserData" => {
                                user_data = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(LaunchTemplateData {
                        block_device_mappings: block_device_mappings,
                        capacity_reservation_specification: capacity_reservation_specification,
                        cpu_options: cpu_options,
                        credit_specification: credit_specification,
                        disable_api_stop: disable_api_stop,
                        disable_api_termination: disable_api_termination,
                        ebs_optimized: ebs_optimized,
                        elastic_gpu_specifications: elastic_gpu_specifications,
                        elastic_inference_accelerators: elastic_inference_accelerators,
                        enclave_options: enclave_options,
                        hibernation_options: hibernation_options,
                        iam_instance_profile: iam_instance_profile,
                        image_id: image_id,
                        instance_initiated_shutdown_behavior: instance_initiated_shutdown_behavior,
                        instance_market_options: instance_market_options,
                        instance_requirements: instance_requirements,
                        instance_type: instance_type,
                        kernel_id: kernel_id,
                        key_name: key_name,
                        license_specifications: license_specifications,
                        maintenance_options: maintenance_options,
                        metadata_options: metadata_options,
                        monitoring: monitoring,
                        network_interfaces: network_interfaces,
                        placement: placement,
                        private_dns_name_options: private_dns_name_options,
                        ram_disk_id: ram_disk_id,
                        security_group_ids: security_group_ids,
                        security_groups: security_groups,
                        tag_specifications: tag_specifications,
                        user_data: user_data,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.LaunchTemplateElasticInferenceAccelerator`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplateelasticinferenceaccelerator.html) property type.
    #[derive(Debug, Default)]
    pub struct LaunchTemplateElasticInferenceAccelerator {
        /// Property [`Count`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplateelasticinferenceaccelerator.html#cfn-ec2-launchtemplate-launchtemplateelasticinferenceaccelerator-count).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub count: Option<::Value<u32>>,
        /// Property [`Type`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplateelasticinferenceaccelerator.html#cfn-ec2-launchtemplate-launchtemplateelasticinferenceaccelerator-type).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub r#type: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for LaunchTemplateElasticInferenceAccelerator {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref count) = self.count {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Count", count)?;
            }
            if let Some(ref r#type) = self.r#type {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Type", r#type)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for LaunchTemplateElasticInferenceAccelerator {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<LaunchTemplateElasticInferenceAccelerator, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = LaunchTemplateElasticInferenceAccelerator;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type LaunchTemplateElasticInferenceAccelerator")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut count: Option<::Value<u32>> = None;
                    let mut r#type: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Count" => {
                                count = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Type" => {
                                r#type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(LaunchTemplateElasticInferenceAccelerator {
                        count: count,
                        r#type: r#type,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.LaunchTemplateTagSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatetagspecification.html) property type.
    #[derive(Debug, Default)]
    pub struct LaunchTemplateTagSpecification {
        /// Property [`ResourceType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatetagspecification.html#cfn-ec2-launchtemplate-launchtemplatetagspecification-resourcetype).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub resource_type: Option<::Value<String>>,
        /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatetagspecification.html#cfn-ec2-launchtemplate-launchtemplatetagspecification-tags).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub tags: Option<::ValueList<::Tag>>,
    }

    impl ::codec::SerializeValue for LaunchTemplateTagSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref resource_type) = self.resource_type {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ResourceType", resource_type)?;
            }
            if let Some(ref tags) = self.tags {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for LaunchTemplateTagSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<LaunchTemplateTagSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = LaunchTemplateTagSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type LaunchTemplateTagSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut resource_type: Option<::Value<String>> = None;
                    let mut tags: Option<::ValueList<::Tag>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "ResourceType" => {
                                resource_type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Tags" => {
                                tags = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(LaunchTemplateTagSpecification {
                        resource_type: resource_type,
                        tags: tags,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.LicenseSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-licensespecification.html) property type.
    #[derive(Debug, Default)]
    pub struct LicenseSpecification {
        /// Property [`LicenseConfigurationArn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-licensespecification.html#cfn-ec2-launchtemplate-licensespecification-licenseconfigurationarn).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub license_configuration_arn: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for LicenseSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref license_configuration_arn) = self.license_configuration_arn {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "LicenseConfigurationArn", license_configuration_arn)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for LicenseSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<LicenseSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = LicenseSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type LicenseSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut license_configuration_arn: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "LicenseConfigurationArn" => {
                                license_configuration_arn = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(LicenseSpecification {
                        license_configuration_arn: license_configuration_arn,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.MaintenanceOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-maintenanceoptions.html) property type.
    #[derive(Debug, Default)]
    pub struct MaintenanceOptions {
        /// Property [`AutoRecovery`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-maintenanceoptions.html#cfn-ec2-launchtemplate-maintenanceoptions-autorecovery).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub auto_recovery: Option<::Value<String>>,
        /// Property [`RebootMigration`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-maintenanceoptions.html#cfn-ec2-launchtemplate-maintenanceoptions-rebootmigration).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub reboot_migration: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for MaintenanceOptions {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref auto_recovery) = self.auto_recovery {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AutoRecovery", auto_recovery)?;
            }
            if let Some(ref reboot_migration) = self.reboot_migration {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "RebootMigration", reboot_migration)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for MaintenanceOptions {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<MaintenanceOptions, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = MaintenanceOptions;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type MaintenanceOptions")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut auto_recovery: Option<::Value<String>> = None;
                    let mut reboot_migration: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "AutoRecovery" => {
                                auto_recovery = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "RebootMigration" => {
                                reboot_migration = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(MaintenanceOptions {
                        auto_recovery: auto_recovery,
                        reboot_migration: reboot_migration,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.MemoryGiBPerVCpu`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-memorygibpervcpu.html) property type.
    #[derive(Debug, Default)]
    pub struct MemoryGiBPerVCpu {
        /// Property [`Max`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-memorygibpervcpu.html#cfn-ec2-launchtemplate-memorygibpervcpu-max).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub max: Option<::Value<f64>>,
        /// Property [`Min`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-memorygibpervcpu.html#cfn-ec2-launchtemplate-memorygibpervcpu-min).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub min: Option<::Value<f64>>,
    }

    impl ::codec::SerializeValue for MemoryGiBPerVCpu {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref max) = self.max {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Max", max)?;
            }
            if let Some(ref min) = self.min {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Min", min)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for MemoryGiBPerVCpu {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<MemoryGiBPerVCpu, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = MemoryGiBPerVCpu;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type MemoryGiBPerVCpu")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut max: Option<::Value<f64>> = None;
                    let mut min: Option<::Value<f64>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Max" => {
                                max = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Min" => {
                                min = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(MemoryGiBPerVCpu {
                        max: max,
                        min: min,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.MemoryMiB`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-memorymib.html) property type.
    #[derive(Debug, Default)]
    pub struct MemoryMiB {
        /// Property [`Max`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-memorymib.html#cfn-ec2-launchtemplate-memorymib-max).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub max: Option<::Value<u32>>,
        /// Property [`Min`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-memorymib.html#cfn-ec2-launchtemplate-memorymib-min).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub min: Option<::Value<u32>>,
    }

    impl ::codec::SerializeValue for MemoryMiB {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref max) = self.max {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Max", max)?;
            }
            if let Some(ref min) = self.min {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Min", min)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for MemoryMiB {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<MemoryMiB, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = MemoryMiB;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type MemoryMiB")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut max: Option<::Value<u32>> = None;
                    let mut min: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Max" => {
                                max = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Min" => {
                                min = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(MemoryMiB {
                        max: max,
                        min: min,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.MetadataOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-metadataoptions.html) property type.
    #[derive(Debug, Default)]
    pub struct MetadataOptions {
        /// Property [`HttpEndpoint`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-metadataoptions.html#cfn-ec2-launchtemplate-metadataoptions-httpendpoint).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub http_endpoint: Option<::Value<String>>,
        /// Property [`HttpProtocolIpv6`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-metadataoptions.html#cfn-ec2-launchtemplate-metadataoptions-httpprotocolipv6).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub http_protocol_ipv6: Option<::Value<String>>,
        /// Property [`HttpPutResponseHopLimit`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-metadataoptions.html#cfn-ec2-launchtemplate-metadataoptions-httpputresponsehoplimit).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub http_put_response_hop_limit: Option<::Value<u32>>,
        /// Property [`HttpTokens`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-metadataoptions.html#cfn-ec2-launchtemplate-metadataoptions-httptokens).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub http_tokens: Option<::Value<String>>,
        /// Property [`InstanceMetadataTags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-metadataoptions.html#cfn-ec2-launchtemplate-metadataoptions-instancemetadatatags).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub instance_metadata_tags: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for MetadataOptions {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref http_endpoint) = self.http_endpoint {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "HttpEndpoint", http_endpoint)?;
            }
            if let Some(ref http_protocol_ipv6) = self.http_protocol_ipv6 {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "HttpProtocolIpv6", http_protocol_ipv6)?;
            }
            if let Some(ref http_put_response_hop_limit) = self.http_put_response_hop_limit {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "HttpPutResponseHopLimit", http_put_response_hop_limit)?;
            }
            if let Some(ref http_tokens) = self.http_tokens {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "HttpTokens", http_tokens)?;
            }
            if let Some(ref instance_metadata_tags) = self.instance_metadata_tags {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstanceMetadataTags", instance_metadata_tags)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for MetadataOptions {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<MetadataOptions, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = MetadataOptions;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type MetadataOptions")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut http_endpoint: Option<::Value<String>> = None;
                    let mut http_protocol_ipv6: Option<::Value<String>> = None;
                    let mut http_put_response_hop_limit: Option<::Value<u32>> = None;
                    let mut http_tokens: Option<::Value<String>> = None;
                    let mut instance_metadata_tags: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "HttpEndpoint" => {
                                http_endpoint = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "HttpProtocolIpv6" => {
                                http_protocol_ipv6 = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "HttpPutResponseHopLimit" => {
                                http_put_response_hop_limit = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "HttpTokens" => {
                                http_tokens = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "InstanceMetadataTags" => {
                                instance_metadata_tags = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(MetadataOptions {
                        http_endpoint: http_endpoint,
                        http_protocol_ipv6: http_protocol_ipv6,
                        http_put_response_hop_limit: http_put_response_hop_limit,
                        http_tokens: http_tokens,
                        instance_metadata_tags: instance_metadata_tags,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.Monitoring`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-monitoring.html) property type.
    #[derive(Debug, Default)]
    pub struct Monitoring {
        /// Property [`Enabled`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-monitoring.html#cfn-ec2-launchtemplate-monitoring-enabled).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub enabled: Option<::Value<bool>>,
    }

    impl ::codec::SerializeValue for Monitoring {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref enabled) = self.enabled {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Enabled", enabled)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for Monitoring {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<Monitoring, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = Monitoring;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type Monitoring")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut enabled: Option<::Value<bool>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Enabled" => {
                                enabled = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(Monitoring {
                        enabled: enabled,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.NetworkBandwidthGbps`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkbandwidthgbps.html) property type.
    #[derive(Debug, Default)]
    pub struct NetworkBandwidthGbps {
        /// Property [`Max`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkbandwidthgbps.html#cfn-ec2-launchtemplate-networkbandwidthgbps-max).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub max: Option<::Value<f64>>,
        /// Property [`Min`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkbandwidthgbps.html#cfn-ec2-launchtemplate-networkbandwidthgbps-min).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub min: Option<::Value<f64>>,
    }

    impl ::codec::SerializeValue for NetworkBandwidthGbps {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref max) = self.max {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Max", max)?;
            }
            if let Some(ref min) = self.min {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Min", min)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for NetworkBandwidthGbps {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<NetworkBandwidthGbps, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = NetworkBandwidthGbps;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type NetworkBandwidthGbps")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut max: Option<::Value<f64>> = None;
                    let mut min: Option<::Value<f64>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Max" => {
                                max = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Min" => {
                                min = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(NetworkBandwidthGbps {
                        max: max,
                        min: min,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.NetworkInterface`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html) property type.
    #[derive(Debug, Default)]
    pub struct NetworkInterface {
        /// Property [`AssociateCarrierIpAddress`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-associatecarrieripaddress).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub associate_carrier_ip_address: Option<::Value<bool>>,
        /// Property [`AssociatePublicIpAddress`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-associatepublicipaddress).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub associate_public_ip_address: Option<::Value<bool>>,
        /// Property [`ConnectionTrackingSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-connectiontrackingspecification).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub connection_tracking_specification: Option<::Value<ConnectionTrackingSpecification>>,
        /// Property [`DeleteOnTermination`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-deleteontermination).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub delete_on_termination: Option<::Value<bool>>,
        /// Property [`Description`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-description).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub description: Option<::Value<String>>,
        /// Property [`DeviceIndex`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-deviceindex).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub device_index: Option<::Value<u32>>,
        /// Property [`EnaSrdSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-enasrdspecification).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub ena_srd_specification: Option<::Value<EnaSrdSpecification>>,
        /// Property [`Groups`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-groups).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub groups: Option<::ValueList<String>>,
        /// Property [`InterfaceType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-interfacetype).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub interface_type: Option<::Value<String>>,
        /// Property [`Ipv4PrefixCount`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-ipv4prefixcount).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub ipv4_prefix_count: Option<::Value<u32>>,
        /// Property [`Ipv4Prefixes`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-ipv4prefixes).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub ipv4_prefixes: Option<::ValueList<Ipv4PrefixSpecification>>,
        /// Property [`Ipv6AddressCount`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-ipv6addresscount).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub ipv6_address_count: Option<::Value<u32>>,
        /// Property [`Ipv6Addresses`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-ipv6addresses).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub ipv6_addresses: Option<::ValueList<Ipv6Add>>,
        /// Property [`Ipv6PrefixCount`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-ipv6prefixcount).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub ipv6_prefix_count: Option<::Value<u32>>,
        /// Property [`Ipv6Prefixes`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-ipv6prefixes).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub ipv6_prefixes: Option<::ValueList<Ipv6PrefixSpecification>>,
        /// Property [`NetworkCardIndex`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-networkcardindex).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub network_card_index: Option<::Value<u32>>,
        /// Property [`NetworkInterfaceId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-networkinterfaceid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub network_interface_id: Option<::Value<String>>,
        /// Property [`PrimaryIpv6`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-primaryipv6).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub primary_ipv6: Option<::Value<bool>>,
        /// Property [`PrivateIpAddress`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-privateipaddress).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub private_ip_address: Option<::Value<String>>,
        /// Property [`PrivateIpAddresses`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-privateipaddresses).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub private_ip_addresses: Option<::ValueList<PrivateIpAdd>>,
        /// Property [`SecondaryPrivateIpAddressCount`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-secondaryprivateipaddresscount).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub secondary_private_ip_address_count: Option<::Value<u32>>,
        /// Property [`SubnetId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-subnetid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub subnet_id: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for NetworkInterface {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref associate_carrier_ip_address) = self.associate_carrier_ip_address {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AssociateCarrierIpAddress", associate_carrier_ip_address)?;
            }
            if let Some(ref associate_public_ip_address) = self.associate_public_ip_address {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AssociatePublicIpAddress", associate_public_ip_address)?;
            }
            if let Some(ref connection_tracking_specification) = self.connection_tracking_specification {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ConnectionTrackingSpecification", connection_tracking_specification)?;
            }
            if let Some(ref delete_on_termination) = self.delete_on_termination {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "DeleteOnTermination", delete_on_termination)?;
            }
            if let Some(ref description) = self.description {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Description", description)?;
            }
            if let Some(ref device_index) = self.device_index {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "DeviceIndex", device_index)?;
            }
            if let Some(ref ena_srd_specification) = self.ena_srd_specification {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "EnaSrdSpecification", ena_srd_specification)?;
            }
            if let Some(ref groups) = self.groups {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Groups", groups)?;
            }
            if let Some(ref interface_type) = self.interface_type {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "InterfaceType", interface_type)?;
            }
            if let Some(ref ipv4_prefix_count) = self.ipv4_prefix_count {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv4PrefixCount", ipv4_prefix_count)?;
            }
            if let Some(ref ipv4_prefixes) = self.ipv4_prefixes {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv4Prefixes", ipv4_prefixes)?;
            }
            if let Some(ref ipv6_address_count) = self.ipv6_address_count {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6AddressCount", ipv6_address_count)?;
            }
            if let Some(ref ipv6_addresses) = self.ipv6_addresses {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6Addresses", ipv6_addresses)?;
            }
            if let Some(ref ipv6_prefix_count) = self.ipv6_prefix_count {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6PrefixCount", ipv6_prefix_count)?;
            }
            if let Some(ref ipv6_prefixes) = self.ipv6_prefixes {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6Prefixes", ipv6_prefixes)?;
            }
            if let Some(ref network_card_index) = self.network_card_index {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetworkCardIndex", network_card_index)?;
            }
            if let Some(ref network_interface_id) = self.network_interface_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetworkInterfaceId", network_interface_id)?;
            }
            if let Some(ref primary_ipv6) = self.primary_ipv6 {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "PrimaryIpv6", primary_ipv6)?;
            }
            if let Some(ref private_ip_address) = self.private_ip_address {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "PrivateIpAddress", private_ip_address)?;
            }
            if let Some(ref private_ip_addresses) = self.private_ip_addresses {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "PrivateIpAddresses", private_ip_addresses)?;
            }
            if let Some(ref secondary_private_ip_address_count) = self.secondary_private_ip_address_count {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SecondaryPrivateIpAddressCount", secondary_private_ip_address_count)?;
            }
            if let Some(ref subnet_id) = self.subnet_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SubnetId", subnet_id)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for NetworkInterface {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<NetworkInterface, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = NetworkInterface;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type NetworkInterface")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut associate_carrier_ip_address: Option<::Value<bool>> = None;
                    let mut associate_public_ip_address: Option<::Value<bool>> = None;
                    let mut connection_tracking_specification: Option<::Value<ConnectionTrackingSpecification>> = None;
                    let mut delete_on_termination: Option<::Value<bool>> = None;
                    let mut description: Option<::Value<String>> = None;
                    let mut device_index: Option<::Value<u32>> = None;
                    let mut ena_srd_specification: Option<::Value<EnaSrdSpecification>> = None;
                    let mut groups: Option<::ValueList<String>> = None;
                    let mut interface_type: Option<::Value<String>> = None;
                    let mut ipv4_prefix_count: Option<::Value<u32>> = None;
                    let mut ipv4_prefixes: Option<::ValueList<Ipv4PrefixSpecification>> = None;
                    let mut ipv6_address_count: Option<::Value<u32>> = None;
                    let mut ipv6_addresses: Option<::ValueList<Ipv6Add>> = None;
                    let mut ipv6_prefix_count: Option<::Value<u32>> = None;
                    let mut ipv6_prefixes: Option<::ValueList<Ipv6PrefixSpecification>> = None;
                    let mut network_card_index: Option<::Value<u32>> = None;
                    let mut network_interface_id: Option<::Value<String>> = None;
                    let mut primary_ipv6: Option<::Value<bool>> = None;
                    let mut private_ip_address: Option<::Value<String>> = None;
                    let mut private_ip_addresses: Option<::ValueList<PrivateIpAdd>> = None;
                    let mut secondary_private_ip_address_count: Option<::Value<u32>> = None;
                    let mut subnet_id: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "AssociateCarrierIpAddress" => {
                                associate_carrier_ip_address = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "AssociatePublicIpAddress" => {
                                associate_public_ip_address = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ConnectionTrackingSpecification" => {
                                connection_tracking_specification = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "DeleteOnTermination" => {
                                delete_on_termination = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Description" => {
                                description = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "DeviceIndex" => {
                                device_index = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "EnaSrdSpecification" => {
                                ena_srd_specification = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Groups" => {
                                groups = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "InterfaceType" => {
                                interface_type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Ipv4PrefixCount" => {
                                ipv4_prefix_count = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Ipv4Prefixes" => {
                                ipv4_prefixes = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Ipv6AddressCount" => {
                                ipv6_address_count = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Ipv6Addresses" => {
                                ipv6_addresses = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Ipv6PrefixCount" => {
                                ipv6_prefix_count = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Ipv6Prefixes" => {
                                ipv6_prefixes = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "NetworkCardIndex" => {
                                network_card_index = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "NetworkInterfaceId" => {
                                network_interface_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "PrimaryIpv6" => {
                                primary_ipv6 = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "PrivateIpAddress" => {
                                private_ip_address = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "PrivateIpAddresses" => {
                                private_ip_addresses = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SecondaryPrivateIpAddressCount" => {
                                secondary_private_ip_address_count = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SubnetId" => {
                                subnet_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(NetworkInterface {
                        associate_carrier_ip_address: associate_carrier_ip_address,
                        associate_public_ip_address: associate_public_ip_address,
                        connection_tracking_specification: connection_tracking_specification,
                        delete_on_termination: delete_on_termination,
                        description: description,
                        device_index: device_index,
                        ena_srd_specification: ena_srd_specification,
                        groups: groups,
                        interface_type: interface_type,
                        ipv4_prefix_count: ipv4_prefix_count,
                        ipv4_prefixes: ipv4_prefixes,
                        ipv6_address_count: ipv6_address_count,
                        ipv6_addresses: ipv6_addresses,
                        ipv6_prefix_count: ipv6_prefix_count,
                        ipv6_prefixes: ipv6_prefixes,
                        network_card_index: network_card_index,
                        network_interface_id: network_interface_id,
                        primary_ipv6: primary_ipv6,
                        private_ip_address: private_ip_address,
                        private_ip_addresses: private_ip_addresses,
                        secondary_private_ip_address_count: secondary_private_ip_address_count,
                        subnet_id: subnet_id,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.NetworkInterfaceCount`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterfacecount.html) property type.
    #[derive(Debug, Default)]
    pub struct NetworkInterfaceCount {
        /// Property [`Max`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterfacecount.html#cfn-ec2-launchtemplate-networkinterfacecount-max).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub max: Option<::Value<u32>>,
        /// Property [`Min`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterfacecount.html#cfn-ec2-launchtemplate-networkinterfacecount-min).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub min: Option<::Value<u32>>,
    }

    impl ::codec::SerializeValue for NetworkInterfaceCount {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref max) = self.max {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Max", max)?;
            }
            if let Some(ref min) = self.min {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Min", min)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for NetworkInterfaceCount {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<NetworkInterfaceCount, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = NetworkInterfaceCount;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type NetworkInterfaceCount")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut max: Option<::Value<u32>> = None;
                    let mut min: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Max" => {
                                max = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Min" => {
                                min = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(NetworkInterfaceCount {
                        max: max,
                        min: min,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.Placement`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html) property type.
    #[derive(Debug, Default)]
    pub struct Placement {
        /// Property [`Affinity`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-affinity).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub affinity: Option<::Value<String>>,
        /// Property [`AvailabilityZone`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-availabilityzone).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub availability_zone: Option<::Value<String>>,
        /// Property [`GroupId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-groupid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub group_id: Option<::Value<String>>,
        /// Property [`GroupName`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-groupname).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub group_name: Option<::Value<String>>,
        /// Property [`HostId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-hostid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub host_id: Option<::Value<String>>,
        /// Property [`HostResourceGroupArn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-hostresourcegrouparn).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub host_resource_group_arn: Option<::Value<String>>,
        /// Property [`PartitionNumber`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-partitionnumber).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub partition_number: Option<::Value<u32>>,
        /// Property [`SpreadDomain`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-spreaddomain).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub spread_domain: Option<::Value<String>>,
        /// Property [`Tenancy`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-placement.html#cfn-ec2-launchtemplate-placement-tenancy).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub tenancy: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for Placement {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref affinity) = self.affinity {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Affinity", affinity)?;
            }
            if let Some(ref availability_zone) = self.availability_zone {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AvailabilityZone", availability_zone)?;
            }
            if let Some(ref group_id) = self.group_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "GroupId", group_id)?;
            }
            if let Some(ref group_name) = self.group_name {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "GroupName", group_name)?;
            }
            if let Some(ref host_id) = self.host_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "HostId", host_id)?;
            }
            if let Some(ref host_resource_group_arn) = self.host_resource_group_arn {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "HostResourceGroupArn", host_resource_group_arn)?;
            }
            if let Some(ref partition_number) = self.partition_number {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "PartitionNumber", partition_number)?;
            }
            if let Some(ref spread_domain) = self.spread_domain {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SpreadDomain", spread_domain)?;
            }
            if let Some(ref tenancy) = self.tenancy {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tenancy", tenancy)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for Placement {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<Placement, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = Placement;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type Placement")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut affinity: Option<::Value<String>> = None;
                    let mut availability_zone: Option<::Value<String>> = None;
                    let mut group_id: Option<::Value<String>> = None;
                    let mut group_name: Option<::Value<String>> = None;
                    let mut host_id: Option<::Value<String>> = None;
                    let mut host_resource_group_arn: Option<::Value<String>> = None;
                    let mut partition_number: Option<::Value<u32>> = None;
                    let mut spread_domain: Option<::Value<String>> = None;
                    let mut tenancy: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Affinity" => {
                                affinity = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "AvailabilityZone" => {
                                availability_zone = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "GroupId" => {
                                group_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "GroupName" => {
                                group_name = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "HostId" => {
                                host_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "HostResourceGroupArn" => {
                                host_resource_group_arn = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "PartitionNumber" => {
                                partition_number = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SpreadDomain" => {
                                spread_domain = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Tenancy" => {
                                tenancy = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(Placement {
                        affinity: affinity,
                        availability_zone: availability_zone,
                        group_id: group_id,
                        group_name: group_name,
                        host_id: host_id,
                        host_resource_group_arn: host_resource_group_arn,
                        partition_number: partition_number,
                        spread_domain: spread_domain,
                        tenancy: tenancy,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.PrivateDnsNameOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-privatednsnameoptions.html) property type.
    #[derive(Debug, Default)]
    pub struct PrivateDnsNameOptions {
        /// Property [`EnableResourceNameDnsAAAARecord`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-privatednsnameoptions.html#cfn-ec2-launchtemplate-privatednsnameoptions-enableresourcenamednsaaaarecord).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub enable_resource_name_dns_aaaa_record: Option<::Value<bool>>,
        /// Property [`EnableResourceNameDnsARecord`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-privatednsnameoptions.html#cfn-ec2-launchtemplate-privatednsnameoptions-enableresourcenamednsarecord).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub enable_resource_name_dns_a_record: Option<::Value<bool>>,
        /// Property [`HostnameType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-privatednsnameoptions.html#cfn-ec2-launchtemplate-privatednsnameoptions-hostnametype).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub hostname_type: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for PrivateDnsNameOptions {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref enable_resource_name_dns_aaaa_record) = self.enable_resource_name_dns_aaaa_record {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "EnableResourceNameDnsAAAARecord", enable_resource_name_dns_aaaa_record)?;
            }
            if let Some(ref enable_resource_name_dns_a_record) = self.enable_resource_name_dns_a_record {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "EnableResourceNameDnsARecord", enable_resource_name_dns_a_record)?;
            }
            if let Some(ref hostname_type) = self.hostname_type {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "HostnameType", hostname_type)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for PrivateDnsNameOptions {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<PrivateDnsNameOptions, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = PrivateDnsNameOptions;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type PrivateDnsNameOptions")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut enable_resource_name_dns_aaaa_record: Option<::Value<bool>> = None;
                    let mut enable_resource_name_dns_a_record: Option<::Value<bool>> = None;
                    let mut hostname_type: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "EnableResourceNameDnsAAAARecord" => {
                                enable_resource_name_dns_aaaa_record = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "EnableResourceNameDnsARecord" => {
                                enable_resource_name_dns_a_record = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "HostnameType" => {
                                hostname_type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(PrivateDnsNameOptions {
                        enable_resource_name_dns_aaaa_record: enable_resource_name_dns_aaaa_record,
                        enable_resource_name_dns_a_record: enable_resource_name_dns_a_record,
                        hostname_type: hostname_type,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.PrivateIpAdd`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-privateipadd.html) property type.
    #[derive(Debug, Default)]
    pub struct PrivateIpAdd {
        /// Property [`Primary`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-privateipadd.html#cfn-ec2-launchtemplate-privateipadd-primary).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub primary: Option<::Value<bool>>,
        /// Property [`PrivateIpAddress`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-privateipadd.html#cfn-ec2-launchtemplate-privateipadd-privateipaddress).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub private_ip_address: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for PrivateIpAdd {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref primary) = self.primary {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Primary", primary)?;
            }
            if let Some(ref private_ip_address) = self.private_ip_address {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "PrivateIpAddress", private_ip_address)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for PrivateIpAdd {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<PrivateIpAdd, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = PrivateIpAdd;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type PrivateIpAdd")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut primary: Option<::Value<bool>> = None;
                    let mut private_ip_address: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Primary" => {
                                primary = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "PrivateIpAddress" => {
                                private_ip_address = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(PrivateIpAdd {
                        primary: primary,
                        private_ip_address: private_ip_address,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.SpotOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-spotoptions.html) property type.
    #[derive(Debug, Default)]
    pub struct SpotOptions {
        /// Property [`BlockDurationMinutes`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-spotoptions.html#cfn-ec2-launchtemplate-spotoptions-blockdurationminutes).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub block_duration_minutes: Option<::Value<u32>>,
        /// Property [`InstanceInterruptionBehavior`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-spotoptions.html#cfn-ec2-launchtemplate-spotoptions-instanceinterruptionbehavior).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub instance_interruption_behavior: Option<::Value<String>>,
        /// Property [`MaxPrice`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-spotoptions.html#cfn-ec2-launchtemplate-spotoptions-maxprice).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub max_price: Option<::Value<String>>,
        /// Property [`SpotInstanceType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-spotoptions.html#cfn-ec2-launchtemplate-spotoptions-spotinstancetype).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub spot_instance_type: Option<::Value<String>>,
        /// Property [`ValidUntil`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-spotoptions.html#cfn-ec2-launchtemplate-spotoptions-validuntil).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub valid_until: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for SpotOptions {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref block_duration_minutes) = self.block_duration_minutes {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "BlockDurationMinutes", block_duration_minutes)?;
            }
            if let Some(ref instance_interruption_behavior) = self.instance_interruption_behavior {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstanceInterruptionBehavior", instance_interruption_behavior)?;
            }
            if let Some(ref max_price) = self.max_price {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "MaxPrice", max_price)?;
            }
            if let Some(ref spot_instance_type) = self.spot_instance_type {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SpotInstanceType", spot_instance_type)?;
            }
            if let Some(ref valid_until) = self.valid_until {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ValidUntil", valid_until)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for SpotOptions {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<SpotOptions, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = SpotOptions;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type SpotOptions")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut block_duration_minutes: Option<::Value<u32>> = None;
                    let mut instance_interruption_behavior: Option<::Value<String>> = None;
                    let mut max_price: Option<::Value<String>> = None;
                    let mut spot_instance_type: Option<::Value<String>> = None;
                    let mut valid_until: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "BlockDurationMinutes" => {
                                block_duration_minutes = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "InstanceInterruptionBehavior" => {
                                instance_interruption_behavior = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "MaxPrice" => {
                                max_price = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SpotInstanceType" => {
                                spot_instance_type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ValidUntil" => {
                                valid_until = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(SpotOptions {
                        block_duration_minutes: block_duration_minutes,
                        instance_interruption_behavior: instance_interruption_behavior,
                        max_price: max_price,
                        spot_instance_type: spot_instance_type,
                        valid_until: valid_until,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.TagSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-tagspecification.html) property type.
    #[derive(Debug, Default)]
    pub struct TagSpecification {
        /// Property [`ResourceType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-tagspecification.html#cfn-ec2-launchtemplate-tagspecification-resourcetype).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub resource_type: Option<::Value<String>>,
        /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-tagspecification.html#cfn-ec2-launchtemplate-tagspecification-tags).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub tags: Option<::ValueList<::Tag>>,
    }

    impl ::codec::SerializeValue for TagSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref resource_type) = self.resource_type {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ResourceType", resource_type)?;
            }
            if let Some(ref tags) = self.tags {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for TagSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<TagSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = TagSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type TagSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut resource_type: Option<::Value<String>> = None;
                    let mut tags: Option<::ValueList<::Tag>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "ResourceType" => {
                                resource_type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Tags" => {
                                tags = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(TagSpecification {
                        resource_type: resource_type,
                        tags: tags,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.TotalLocalStorageGB`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-totallocalstoragegb.html) property type.
    #[derive(Debug, Default)]
    pub struct TotalLocalStorageGB {
        /// Property [`Max`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-totallocalstoragegb.html#cfn-ec2-launchtemplate-totallocalstoragegb-max).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub max: Option<::Value<f64>>,
        /// Property [`Min`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-totallocalstoragegb.html#cfn-ec2-launchtemplate-totallocalstoragegb-min).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub min: Option<::Value<f64>>,
    }

    impl ::codec::SerializeValue for TotalLocalStorageGB {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref max) = self.max {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Max", max)?;
            }
            if let Some(ref min) = self.min {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Min", min)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for TotalLocalStorageGB {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<TotalLocalStorageGB, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = TotalLocalStorageGB;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type TotalLocalStorageGB")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut max: Option<::Value<f64>> = None;
                    let mut min: Option<::Value<f64>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Max" => {
                                max = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Min" => {
                                min = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(TotalLocalStorageGB {
                        max: max,
                        min: min,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::LaunchTemplate.VCpuCount`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-vcpucount.html) property type.
    #[derive(Debug, Default)]
    pub struct VCpuCount {
        /// Property [`Max`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-vcpucount.html#cfn-ec2-launchtemplate-vcpucount-max).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub max: Option<::Value<u32>>,
        /// Property [`Min`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-vcpucount.html#cfn-ec2-launchtemplate-vcpucount-min).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub min: Option<::Value<u32>>,
    }

    impl ::codec::SerializeValue for VCpuCount {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref max) = self.max {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Max", max)?;
            }
            if let Some(ref min) = self.min {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Min", min)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for VCpuCount {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<VCpuCount, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = VCpuCount;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type VCpuCount")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut max: Option<::Value<u32>> = None;
                    let mut min: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Max" => {
                                max = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Min" => {
                                min = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(VCpuCount {
                        max: max,
                        min: min,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }
}

pub mod network_acl_entry {
    //! Property types for the `NetworkAclEntry` resource.

    /// The [`AWS::EC2::NetworkAclEntry.Icmp`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-icmp.html) property type.
    #[derive(Debug, Default)]
    pub struct Icmp {
        /// Property [`Code`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-icmp.html#cfn-ec2-networkaclentry-icmp-code).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub code: Option<::Value<u32>>,
        /// Property [`Type`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-icmp.html#cfn-ec2-networkaclentry-icmp-type).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub r#type: Option<::Value<u32>>,
    }

    impl ::codec::SerializeValue for Icmp {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref code) = self.code {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Code", code)?;
            }
            if let Some(ref r#type) = self.r#type {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Type", r#type)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for Icmp {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<Icmp, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = Icmp;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type Icmp")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut code: Option<::Value<u32>> = None;
                    let mut r#type: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Code" => {
                                code = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Type" => {
                                r#type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(Icmp {
                        code: code,
                        r#type: r#type,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::NetworkAclEntry.PortRange`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-portrange.html) property type.
    #[derive(Debug, Default)]
    pub struct PortRange {
        /// Property [`From`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-portrange.html#cfn-ec2-networkaclentry-portrange-from).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub from: Option<::Value<u32>>,
        /// Property [`To`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-portrange.html#cfn-ec2-networkaclentry-portrange-to).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub to: Option<::Value<u32>>,
    }

    impl ::codec::SerializeValue for PortRange {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref from) = self.from {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "From", from)?;
            }
            if let Some(ref to) = self.to {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "To", to)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for PortRange {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<PortRange, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = PortRange;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type PortRange")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut from: Option<::Value<u32>> = None;
                    let mut to: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "From" => {
                                from = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "To" => {
                                to = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(PortRange {
                        from: from,
                        to: to,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }
}

pub mod network_insights_access_scope {
    //! Property types for the `NetworkInsightsAccessScope` resource.

    /// The [`AWS::EC2::NetworkInsightsAccessScope.AccessScopePathRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-accessscopepathrequest.html) property type.
    #[derive(Debug, Default)]
    pub struct AccessScopePathRequest {
        /// Property [`Destination`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-accessscopepathrequest.html#cfn-ec2-networkinsightsaccessscope-accessscopepathrequest-destination).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub destination: Option<::Value<PathStatementRequest>>,
        /// Property [`Source`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-accessscopepathrequest.html#cfn-ec2-networkinsightsaccessscope-accessscopepathrequest-source).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub source: Option<::Value<PathStatementRequest>>,
        /// Property [`ThroughResources`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-accessscopepathrequest.html#cfn-ec2-networkinsightsaccessscope-accessscopepathrequest-throughresources).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub through_resources: Option<::ValueList<ThroughResourcesStatementRequest>>,
    }

    impl ::codec::SerializeValue for AccessScopePathRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref destination) = self.destination {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Destination", destination)?;
            }
            if let Some(ref source) = self.source {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Source", source)?;
            }
            if let Some(ref through_resources) = self.through_resources {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ThroughResources", through_resources)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for AccessScopePathRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<AccessScopePathRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = AccessScopePathRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type AccessScopePathRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut destination: Option<::Value<PathStatementRequest>> = None;
                    let mut source: Option<::Value<PathStatementRequest>> = None;
                    let mut through_resources: Option<::ValueList<ThroughResourcesStatementRequest>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Destination" => {
                                destination = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Source" => {
                                source = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ThroughResources" => {
                                through_resources = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(AccessScopePathRequest {
                        destination: destination,
                        source: source,
                        through_resources: through_resources,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::NetworkInsightsAccessScope.PacketHeaderStatementRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html) property type.
    #[derive(Debug, Default)]
    pub struct PacketHeaderStatementRequest {
        /// Property [`DestinationAddresses`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-destinationaddresses).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub destination_addresses: Option<::ValueList<String>>,
        /// Property [`DestinationPorts`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-destinationports).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub destination_ports: Option<::ValueList<String>>,
        /// Property [`DestinationPrefixLists`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-destinationprefixlists).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub destination_prefix_lists: Option<::ValueList<String>>,
        /// Property [`Protocols`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-protocols).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub protocols: Option<::ValueList<String>>,
        /// Property [`SourceAddresses`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-sourceaddresses).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub source_addresses: Option<::ValueList<String>>,
        /// Property [`SourcePorts`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-sourceports).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub source_ports: Option<::ValueList<String>>,
        /// Property [`SourcePrefixLists`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-sourceprefixlists).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub source_prefix_lists: Option<::ValueList<String>>,
    }

    impl ::codec::SerializeValue for PacketHeaderStatementRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref destination_addresses) = self.destination_addresses {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "DestinationAddresses", destination_addresses)?;
            }
            if let Some(ref destination_ports) = self.destination_ports {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "DestinationPorts", destination_ports)?;
            }
            if let Some(ref destination_prefix_lists) = self.destination_prefix_lists {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "DestinationPrefixLists", destination_prefix_lists)?;
            }
            if let Some(ref protocols) = self.protocols {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Protocols", protocols)?;
            }
            if let Some(ref source_addresses) = self.source_addresses {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SourceAddresses", source_addresses)?;
            }
            if let Some(ref source_ports) = self.source_ports {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SourcePorts", source_ports)?;
            }
            if let Some(ref source_prefix_lists) = self.source_prefix_lists {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SourcePrefixLists", source_prefix_lists)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for PacketHeaderStatementRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<PacketHeaderStatementRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = PacketHeaderStatementRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type PacketHeaderStatementRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut destination_addresses: Option<::ValueList<String>> = None;
                    let mut destination_ports: Option<::ValueList<String>> = None;
                    let mut destination_prefix_lists: Option<::ValueList<String>> = None;
                    let mut protocols: Option<::ValueList<String>> = None;
                    let mut source_addresses: Option<::ValueList<String>> = None;
                    let mut source_ports: Option<::ValueList<String>> = None;
                    let mut source_prefix_lists: Option<::ValueList<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "DestinationAddresses" => {
                                destination_addresses = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "DestinationPorts" => {
                                destination_ports = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "DestinationPrefixLists" => {
                                destination_prefix_lists = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Protocols" => {
                                protocols = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SourceAddresses" => {
                                source_addresses = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SourcePorts" => {
                                source_ports = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SourcePrefixLists" => {
                                source_prefix_lists = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(PacketHeaderStatementRequest {
                        destination_addresses: destination_addresses,
                        destination_ports: destination_ports,
                        destination_prefix_lists: destination_prefix_lists,
                        protocols: protocols,
                        source_addresses: source_addresses,
                        source_ports: source_ports,
                        source_prefix_lists: source_prefix_lists,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::NetworkInsightsAccessScope.PathStatementRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-pathstatementrequest.html) property type.
    #[derive(Debug, Default)]
    pub struct PathStatementRequest {
        /// Property [`PacketHeaderStatement`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-pathstatementrequest.html#cfn-ec2-networkinsightsaccessscope-pathstatementrequest-packetheaderstatement).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub packet_header_statement: Option<::Value<PacketHeaderStatementRequest>>,
        /// Property [`ResourceStatement`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-pathstatementrequest.html#cfn-ec2-networkinsightsaccessscope-pathstatementrequest-resourcestatement).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub resource_statement: Option<::Value<ResourceStatementRequest>>,
    }

    impl ::codec::SerializeValue for PathStatementRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref packet_header_statement) = self.packet_header_statement {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "PacketHeaderStatement", packet_header_statement)?;
            }
            if let Some(ref resource_statement) = self.resource_statement {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ResourceStatement", resource_statement)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for PathStatementRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<PathStatementRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = PathStatementRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type PathStatementRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut packet_header_statement: Option<::Value<PacketHeaderStatementRequest>> = None;
                    let mut resource_statement: Option<::Value<ResourceStatementRequest>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "PacketHeaderStatement" => {
                                packet_header_statement = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ResourceStatement" => {
                                resource_statement = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(PathStatementRequest {
                        packet_header_statement: packet_header_statement,
                        resource_statement: resource_statement,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::NetworkInsightsAccessScope.ResourceStatementRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-resourcestatementrequest.html) property type.
    #[derive(Debug, Default)]
    pub struct ResourceStatementRequest {
        /// Property [`ResourceTypes`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-resourcestatementrequest.html#cfn-ec2-networkinsightsaccessscope-resourcestatementrequest-resourcetypes).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub resource_types: Option<::ValueList<String>>,
        /// Property [`Resources`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-resourcestatementrequest.html#cfn-ec2-networkinsightsaccessscope-resourcestatementrequest-resources).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub resources: Option<::ValueList<String>>,
    }

    impl ::codec::SerializeValue for ResourceStatementRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref resource_types) = self.resource_types {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ResourceTypes", resource_types)?;
            }
            if let Some(ref resources) = self.resources {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Resources", resources)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for ResourceStatementRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<ResourceStatementRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = ResourceStatementRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type ResourceStatementRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut resource_types: Option<::ValueList<String>> = None;
                    let mut resources: Option<::ValueList<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "ResourceTypes" => {
                                resource_types = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Resources" => {
                                resources = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(ResourceStatementRequest {
                        resource_types: resource_types,
                        resources: resources,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::NetworkInsightsAccessScope.ThroughResourcesStatementRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-throughresourcesstatementrequest.html) property type.
    #[derive(Debug, Default)]
    pub struct ThroughResourcesStatementRequest {
        /// Property [`ResourceStatement`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-throughresourcesstatementrequest.html#cfn-ec2-networkinsightsaccessscope-throughresourcesstatementrequest-resourcestatement).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub resource_statement: Option<::Value<ResourceStatementRequest>>,
    }

    impl ::codec::SerializeValue for ThroughResourcesStatementRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref resource_statement) = self.resource_statement {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ResourceStatement", resource_statement)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for ThroughResourcesStatementRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<ThroughResourcesStatementRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = ThroughResourcesStatementRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type ThroughResourcesStatementRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut resource_statement: Option<::Value<ResourceStatementRequest>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "ResourceStatement" => {
                                resource_statement = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(ThroughResourcesStatementRequest {
                        resource_statement: resource_statement,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }
}

pub mod network_insights_analysis {
    //! Property types for the `NetworkInsightsAnalysis` resource.

    /// The [`AWS::EC2::NetworkInsightsAnalysis.AdditionalDetail`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-additionaldetail.html) property type.
    #[derive(Debug, Default)]
    pub struct AdditionalDetail {
        /// Property [`AdditionalDetailType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-additionaldetail.html#cfn-ec2-networkinsightsanalysis-additionaldetail-additionaldetailtype).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub additional_detail_type: Option<::Value<String>>,
        /// Property [`Component`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-additionaldetail.html#cfn-ec2-networkinsightsanalysis-additionaldetail-component).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub component: Option<::Value<AnalysisComponent>>,
        /// Property [`LoadBalancers`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-additionaldetail.html#cfn-ec2-networkinsightsanalysis-additionaldetail-loadbalancers).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub load_balancers: Option<::ValueList<AnalysisComponent>>,
        /// Property [`ServiceName`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-additionaldetail.html#cfn-ec2-networkinsightsanalysis-additionaldetail-servicename).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub service_name: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for AdditionalDetail {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref additional_detail_type) = self.additional_detail_type {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AdditionalDetailType", additional_detail_type)?;
            }
            if let Some(ref component) = self.component {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Component", component)?;
            }
            if let Some(ref load_balancers) = self.load_balancers {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "LoadBalancers", load_balancers)?;
            }
            if let Some(ref service_name) = self.service_name {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ServiceName", service_name)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for AdditionalDetail {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<AdditionalDetail, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = AdditionalDetail;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type AdditionalDetail")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut additional_detail_type: Option<::Value<String>> = None;
                    let mut component: Option<::Value<AnalysisComponent>> = None;
                    let mut load_balancers: Option<::ValueList<AnalysisComponent>> = None;
                    let mut service_name: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "AdditionalDetailType" => {
                                additional_detail_type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Component" => {
                                component = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "LoadBalancers" => {
                                load_balancers = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ServiceName" => {
                                service_name = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(AdditionalDetail {
                        additional_detail_type: additional_detail_type,
                        component: component,
                        load_balancers: load_balancers,
                        service_name: service_name,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::NetworkInsightsAnalysis.AlternatePathHint`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-alternatepathhint.html) property type.
    #[derive(Debug, Default)]
    pub struct AlternatePathHint {
        /// Property [`ComponentArn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-alternatepathhint.html#cfn-ec2-networkinsightsanalysis-alternatepathhint-componentarn).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub component_arn: Option<::Value<String>>,
        /// Property [`ComponentId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-alternatepathhint.html#cfn-ec2-networkinsightsanalysis-alternatepathhint-componentid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub component_id: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for AlternatePathHint {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref component_arn) = self.component_arn {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ComponentArn", component_arn)?;
            }
            if let Some(ref component_id) = self.component_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ComponentId", component_id)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for AlternatePathHint {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<AlternatePathHint, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = AlternatePathHint;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type AlternatePathHint")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut component_arn: Option<::Value<String>> = None;
                    let mut component_id: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "ComponentArn" => {
                                component_arn = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ComponentId" => {
                                component_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(AlternatePathHint {
                        component_arn: component_arn,
                        component_id: component_id,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::NetworkInsightsAnalysis.AnalysisAclRule`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html) property type.
    #[derive(Debug, Default)]
    pub struct AnalysisAclRule {
        /// Property [`Cidr`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html#cfn-ec2-networkinsightsanalysis-analysisaclrule-cidr).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub cidr: Option<::Value<String>>,
        /// Property [`Egress`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html#cfn-ec2-networkinsightsanalysis-analysisaclrule-egress).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub egress: Option<::Value<bool>>,
        /// Property [`PortRange`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html#cfn-ec2-networkinsightsanalysis-analysisaclrule-portrange).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub port_range: Option<::Value<PortRange>>,
        /// Property [`Protocol`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html#cfn-ec2-networkinsightsanalysis-analysisaclrule-protocol).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub protocol: Option<::Value<String>>,
        /// Property [`RuleAction`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html#cfn-ec2-networkinsightsanalysis-analysisaclrule-ruleaction).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub rule_action: Option<::Value<String>>,
        /// Property [`RuleNumber`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html#cfn-ec2-networkinsightsanalysis-analysisaclrule-rulenumber).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub rule_number: Option<::Value<u32>>,
    }

    impl ::codec::SerializeValue for AnalysisAclRule {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref cidr) = self.cidr {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Cidr", cidr)?;
            }
            if let Some(ref egress) = self.egress {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Egress", egress)?;
            }
            if let Some(ref port_range) = self.port_range {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "PortRange", port_range)?;
            }
            if let Some(ref protocol) = self.protocol {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Protocol", protocol)?;
            }
            if let Some(ref rule_action) = self.rule_action {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "RuleAction", rule_action)?;
            }
            if let Some(ref rule_number) = self.rule_number {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "RuleNumber", rule_number)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for AnalysisAclRule {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<AnalysisAclRule, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = AnalysisAclRule;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type AnalysisAclRule")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut cidr: Option<::Value<String>> = None;
                    let mut egress: Option<::Value<bool>> = None;
                    let mut port_range: Option<::Value<PortRange>> = None;
                    let mut protocol: Option<::Value<String>> = None;
                    let mut rule_action: Option<::Value<String>> = None;
                    let mut rule_number: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Cidr" => {
                                cidr = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Egress" => {
                                egress = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "PortRange" => {
                                port_range = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Protocol" => {
                                protocol = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "RuleAction" => {
                                rule_action = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "RuleNumber" => {
                                rule_number = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(AnalysisAclRule {
                        cidr: cidr,
                        egress: egress,
                        port_range: port_range,
                        protocol: protocol,
                        rule_action: rule_action,
                        rule_number: rule_number,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::NetworkInsightsAnalysis.AnalysisComponent`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysiscomponent.html) property type.
    #[derive(Debug, Default)]
    pub struct AnalysisComponent {
        /// Property [`Arn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysiscomponent.html#cfn-ec2-networkinsightsanalysis-analysiscomponent-arn).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub arn: Option<::Value<String>>,
        /// Property [`Id`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysiscomponent.html#cfn-ec2-networkinsightsanalysis-analysiscomponent-id).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub id: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for AnalysisComponent {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref arn) = self.arn {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Arn", arn)?;
            }
            if let Some(ref id) = self.id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Id", id)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for AnalysisComponent {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<AnalysisComponent, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = AnalysisComponent;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type AnalysisComponent")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut arn: Option<::Value<String>> = None;
                    let mut id: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Arn" => {
                                arn = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Id" => {
                                id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(AnalysisComponent {
                        arn: arn,
                        id: id,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::NetworkInsightsAnalysis.AnalysisLoadBalancerListener`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancerlistener.html) property type.
    #[derive(Debug, Default)]
    pub struct AnalysisLoadBalancerListener {
        /// Property [`InstancePort`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancerlistener.html#cfn-ec2-networkinsightsanalysis-analysisloadbalancerlistener-instanceport).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub instance_port: Option<::Value<u32>>,
        /// Property [`LoadBalancerPort`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancerlistener.html#cfn-ec2-networkinsightsanalysis-analysisloadbalancerlistener-loadbalancerport).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub load_balancer_port: Option<::Value<u32>>,
    }

    impl ::codec::SerializeValue for AnalysisLoadBalancerListener {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref instance_port) = self.instance_port {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstancePort", instance_port)?;
            }
            if let Some(ref load_balancer_port) = self.load_balancer_port {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "LoadBalancerPort", load_balancer_port)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for AnalysisLoadBalancerListener {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<AnalysisLoadBalancerListener, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = AnalysisLoadBalancerListener;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type AnalysisLoadBalancerListener")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut instance_port: Option<::Value<u32>> = None;
                    let mut load_balancer_port: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "InstancePort" => {
                                instance_port = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "LoadBalancerPort" => {
                                load_balancer_port = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(AnalysisLoadBalancerListener {
                        instance_port: instance_port,
                        load_balancer_port: load_balancer_port,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::NetworkInsightsAnalysis.AnalysisLoadBalancerTarget`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancertarget.html) property type.
    #[derive(Debug, Default)]
    pub struct AnalysisLoadBalancerTarget {
        /// Property [`Address`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancertarget.html#cfn-ec2-networkinsightsanalysis-analysisloadbalancertarget-address).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub address: Option<::Value<String>>,
        /// Property [`AvailabilityZone`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancertarget.html#cfn-ec2-networkinsightsanalysis-analysisloadbalancertarget-availabilityzone).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub availability_zone: Option<::Value<String>>,
        /// Property [`Instance`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancertarget.html#cfn-ec2-networkinsightsanalysis-analysisloadbalancertarget-instance).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub instance: Option<::Value<AnalysisComponent>>,
        /// Property [`Port`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancertarget.html#cfn-ec2-networkinsightsanalysis-analysisloadbalancertarget-port).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub port: Option<::Value<u32>>,
    }

    impl ::codec::SerializeValue for AnalysisLoadBalancerTarget {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref address) = self.address {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Address", address)?;
            }
            if let Some(ref availability_zone) = self.availability_zone {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AvailabilityZone", availability_zone)?;
            }
            if let Some(ref instance) = self.instance {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Instance", instance)?;
            }
            if let Some(ref port) = self.port {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Port", port)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for AnalysisLoadBalancerTarget {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<AnalysisLoadBalancerTarget, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = AnalysisLoadBalancerTarget;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type AnalysisLoadBalancerTarget")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut address: Option<::Value<String>> = None;
                    let mut availability_zone: Option<::Value<String>> = None;
                    let mut instance: Option<::Value<AnalysisComponent>> = None;
                    let mut port: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Address" => {
                                address = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "AvailabilityZone" => {
                                availability_zone = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Instance" => {
                                instance = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Port" => {
                                port = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(AnalysisLoadBalancerTarget {
                        address: address,
                        availability_zone: availability_zone,
                        instance: instance,
                        port: port,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::NetworkInsightsAnalysis.AnalysisPacketHeader`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysispacketheader.html) property type.
    #[derive(Debug, Default)]
    pub struct AnalysisPacketHeader {
        /// Property [`DestinationAddresses`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysispacketheader.html#cfn-ec2-networkinsightsanalysis-analysispacketheader-destinationaddresses).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub destination_addresses: Option<::ValueList<String>>,
        /// Property [`DestinationPortRanges`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysispacketheader.html#cfn-ec2-networkinsightsanalysis-analysispacketheader-destinationportranges).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub destination_port_ranges: Option<::ValueList<PortRange>>,
        /// Property [`Protocol`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysispacketheader.html#cfn-ec2-networkinsightsanalysis-analysispacketheader-protocol).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub protocol: Option<::Value<String>>,
        /// Property [`SourceAddresses`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysispacketheader.html#cfn-ec2-networkinsightsanalysis-analysispacketheader-sourceaddresses).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub source_addresses: Option<::ValueList<String>>,
        /// Property [`SourcePortRanges`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysispacketheader.html#cfn-ec2-networkinsightsanalysis-analysispacketheader-sourceportranges).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub source_port_ranges: Option<::ValueList<PortRange>>,
    }

    impl ::codec::SerializeValue for AnalysisPacketHeader {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref destination_addresses) = self.destination_addresses {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "DestinationAddresses", destination_addresses)?;
            }
            if let Some(ref destination_port_ranges) = self.destination_port_ranges {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "DestinationPortRanges", destination_port_ranges)?;
            }
            if let Some(ref protocol) = self.protocol {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Protocol", protocol)?;
            }
            if let Some(ref source_addresses) = self.source_addresses {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SourceAddresses", source_addresses)?;
            }
            if let Some(ref source_port_ranges) = self.source_port_ranges {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SourcePortRanges", source_port_ranges)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for AnalysisPacketHeader {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<AnalysisPacketHeader, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = AnalysisPacketHeader;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type AnalysisPacketHeader")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut destination_addresses: Option<::ValueList<String>> = None;
                    let mut destination_port_ranges: Option<::ValueList<PortRange>> = None;
                    let mut protocol: Option<::Value<String>> = None;
                    let mut source_addresses: Option<::ValueList<String>> = None;
                    let mut source_port_ranges: Option<::ValueList<PortRange>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "DestinationAddresses" => {
                                destination_addresses = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "DestinationPortRanges" => {
                                destination_port_ranges = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Protocol" => {
                                protocol = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SourceAddresses" => {
                                source_addresses = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SourcePortRanges" => {
                                source_port_ranges = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(AnalysisPacketHeader {
                        destination_addresses: destination_addresses,
                        destination_port_ranges: destination_port_ranges,
                        protocol: protocol,
                        source_addresses: source_addresses,
                        source_port_ranges: source_port_ranges,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::NetworkInsightsAnalysis.AnalysisRouteTableRoute`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html) property type.
    #[derive(Debug, Default)]
    pub struct AnalysisRouteTableRoute {
        /// Property [`NatGatewayId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-natgatewayid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub nat_gateway_id: Option<::Value<String>>,
        /// Property [`NetworkInterfaceId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-networkinterfaceid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub network_interface_id: Option<::Value<String>>,
        /// Property [`Origin`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-origin).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub origin: Option<::Value<String>>,
        /// Property [`State`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-state).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub state: Option<::Value<String>>,
        /// Property [`TransitGatewayId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-transitgatewayid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub transit_gateway_id: Option<::Value<String>>,
        /// Property [`VpcPeeringConnectionId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-vpcpeeringconnectionid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub vpc_peering_connection_id: Option<::Value<String>>,
        /// Property [`destinationCidr`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-destinationcidr).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub destination_cidr: Option<::Value<String>>,
        /// Property [`destinationPrefixListId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-destinationprefixlistid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub destination_prefix_list_id: Option<::Value<String>>,
        /// Property [`egressOnlyInternetGatewayId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-egressonlyinternetgatewayid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub egress_only_internet_gateway_id: Option<::Value<String>>,
        /// Property [`gatewayId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-gatewayid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub gateway_id: Option<::Value<String>>,
        /// Property [`instanceId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-instanceid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub instance_id: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for AnalysisRouteTableRoute {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref nat_gateway_id) = self.nat_gateway_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "NatGatewayId", nat_gateway_id)?;
            }
            if let Some(ref network_interface_id) = self.network_interface_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetworkInterfaceId", network_interface_id)?;
            }
            if let Some(ref origin) = self.origin {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Origin", origin)?;
            }
            if let Some(ref state) = self.state {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "State", state)?;
            }
            if let Some(ref transit_gateway_id) = self.transit_gateway_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "TransitGatewayId", transit_gateway_id)?;
            }
            if let Some(ref vpc_peering_connection_id) = self.vpc_peering_connection_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "VpcPeeringConnectionId", vpc_peering_connection_id)?;
            }
            if let Some(ref destination_cidr) = self.destination_cidr {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "destinationCidr", destination_cidr)?;
            }
            if let Some(ref destination_prefix_list_id) = self.destination_prefix_list_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "destinationPrefixListId", destination_prefix_list_id)?;
            }
            if let Some(ref egress_only_internet_gateway_id) = self.egress_only_internet_gateway_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "egressOnlyInternetGatewayId", egress_only_internet_gateway_id)?;
            }
            if let Some(ref gateway_id) = self.gateway_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "gatewayId", gateway_id)?;
            }
            if let Some(ref instance_id) = self.instance_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "instanceId", instance_id)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for AnalysisRouteTableRoute {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<AnalysisRouteTableRoute, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = AnalysisRouteTableRoute;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type AnalysisRouteTableRoute")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut nat_gateway_id: Option<::Value<String>> = None;
                    let mut network_interface_id: Option<::Value<String>> = None;
                    let mut origin: Option<::Value<String>> = None;
                    let mut state: Option<::Value<String>> = None;
                    let mut transit_gateway_id: Option<::Value<String>> = None;
                    let mut vpc_peering_connection_id: Option<::Value<String>> = None;
                    let mut destination_cidr: Option<::Value<String>> = None;
                    let mut destination_prefix_list_id: Option<::Value<String>> = None;
                    let mut egress_only_internet_gateway_id: Option<::Value<String>> = None;
                    let mut gateway_id: Option<::Value<String>> = None;
                    let mut instance_id: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "NatGatewayId" => {
                                nat_gateway_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "NetworkInterfaceId" => {
                                network_interface_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Origin" => {
                                origin = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "State" => {
                                state = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "TransitGatewayId" => {
                                transit_gateway_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "VpcPeeringConnectionId" => {
                                vpc_peering_connection_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "destinationCidr" => {
                                destination_cidr = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "destinationPrefixListId" => {
                                destination_prefix_list_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "egressOnlyInternetGatewayId" => {
                                egress_only_internet_gateway_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "gatewayId" => {
                                gateway_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "instanceId" => {
                                instance_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(AnalysisRouteTableRoute {
                        nat_gateway_id: nat_gateway_id,
                        network_interface_id: network_interface_id,
                        origin: origin,
                        state: state,
                        transit_gateway_id: transit_gateway_id,
                        vpc_peering_connection_id: vpc_peering_connection_id,
                        destination_cidr: destination_cidr,
                        destination_prefix_list_id: destination_prefix_list_id,
                        egress_only_internet_gateway_id: egress_only_internet_gateway_id,
                        gateway_id: gateway_id,
                        instance_id: instance_id,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::NetworkInsightsAnalysis.AnalysisSecurityGroupRule`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html) property type.
    #[derive(Debug, Default)]
    pub struct AnalysisSecurityGroupRule {
        /// Property [`Cidr`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html#cfn-ec2-networkinsightsanalysis-analysissecuritygrouprule-cidr).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub cidr: Option<::Value<String>>,
        /// Property [`Direction`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html#cfn-ec2-networkinsightsanalysis-analysissecuritygrouprule-direction).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub direction: Option<::Value<String>>,
        /// Property [`PortRange`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html#cfn-ec2-networkinsightsanalysis-analysissecuritygrouprule-portrange).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub port_range: Option<::Value<PortRange>>,
        /// Property [`PrefixListId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html#cfn-ec2-networkinsightsanalysis-analysissecuritygrouprule-prefixlistid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub prefix_list_id: Option<::Value<String>>,
        /// Property [`Protocol`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html#cfn-ec2-networkinsightsanalysis-analysissecuritygrouprule-protocol).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub protocol: Option<::Value<String>>,
        /// Property [`SecurityGroupId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html#cfn-ec2-networkinsightsanalysis-analysissecuritygrouprule-securitygroupid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub security_group_id: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for AnalysisSecurityGroupRule {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref cidr) = self.cidr {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Cidr", cidr)?;
            }
            if let Some(ref direction) = self.direction {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Direction", direction)?;
            }
            if let Some(ref port_range) = self.port_range {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "PortRange", port_range)?;
            }
            if let Some(ref prefix_list_id) = self.prefix_list_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "PrefixListId", prefix_list_id)?;
            }
            if let Some(ref protocol) = self.protocol {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Protocol", protocol)?;
            }
            if let Some(ref security_group_id) = self.security_group_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SecurityGroupId", security_group_id)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for AnalysisSecurityGroupRule {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<AnalysisSecurityGroupRule, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = AnalysisSecurityGroupRule;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type AnalysisSecurityGroupRule")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut cidr: Option<::Value<String>> = None;
                    let mut direction: Option<::Value<String>> = None;
                    let mut port_range: Option<::Value<PortRange>> = None;
                    let mut prefix_list_id: Option<::Value<String>> = None;
                    let mut protocol: Option<::Value<String>> = None;
                    let mut security_group_id: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Cidr" => {
                                cidr = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Direction" => {
                                direction = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "PortRange" => {
                                port_range = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "PrefixListId" => {
                                prefix_list_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Protocol" => {
                                protocol = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SecurityGroupId" => {
                                security_group_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(AnalysisSecurityGroupRule {
                        cidr: cidr,
                        direction: direction,
                        port_range: port_range,
                        prefix_list_id: prefix_list_id,
                        protocol: protocol,
                        security_group_id: security_group_id,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::NetworkInsightsAnalysis.Explanation`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html) property type.
    #[derive(Debug, Default)]
    pub struct Explanation {
        /// Property [`Acl`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-acl).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub acl: Option<::Value<AnalysisComponent>>,
        /// Property [`AclRule`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-aclrule).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub acl_rule: Option<::Value<AnalysisAclRule>>,
        /// Property [`Address`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-address).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub address: Option<::Value<String>>,
        /// Property [`Addresses`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-addresses).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub addresses: Option<::ValueList<String>>,
        /// Property [`AttachedTo`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-attachedto).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub attached_to: Option<::Value<AnalysisComponent>>,
        /// Property [`AvailabilityZones`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-availabilityzones).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub availability_zones: Option<::ValueList<String>>,
        /// Property [`Cidrs`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-cidrs).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub cidrs: Option<::ValueList<String>>,
        /// Property [`ClassicLoadBalancerListener`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-classicloadbalancerlistener).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub classic_load_balancer_listener: Option<::Value<AnalysisLoadBalancerListener>>,
        /// Property [`Component`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-component).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub component: Option<::Value<AnalysisComponent>>,
        /// Property [`ComponentAccount`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-componentaccount).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub component_account: Option<::Value<String>>,
        /// Property [`ComponentRegion`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-componentregion).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub component_region: Option<::Value<String>>,
        /// Property [`CustomerGateway`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-customergateway).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub customer_gateway: Option<::Value<AnalysisComponent>>,
        /// Property [`Destination`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-destination).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub destination: Option<::Value<AnalysisComponent>>,
        /// Property [`DestinationVpc`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-destinationvpc).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub destination_vpc: Option<::Value<AnalysisComponent>>,
        /// Property [`Direction`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-direction).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub direction: Option<::Value<String>>,
        /// Property [`ElasticLoadBalancerListener`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-elasticloadbalancerlistener).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub elastic_load_balancer_listener: Option<::Value<AnalysisComponent>>,
        /// Property [`ExplanationCode`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-explanationcode).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub explanation_code: Option<::Value<String>>,
        /// Property [`IngressRouteTable`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-ingressroutetable).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub ingress_route_table: Option<::Value<AnalysisComponent>>,
        /// Property [`InternetGateway`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-internetgateway).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub internet_gateway: Option<::Value<AnalysisComponent>>,
        /// Property [`LoadBalancerArn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-loadbalancerarn).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub load_balancer_arn: Option<::Value<String>>,
        /// Property [`LoadBalancerListenerPort`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-loadbalancerlistenerport).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub load_balancer_listener_port: Option<::Value<u32>>,
        /// Property [`LoadBalancerTarget`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-loadbalancertarget).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub load_balancer_target: Option<::Value<AnalysisLoadBalancerTarget>>,
        /// Property [`LoadBalancerTargetGroup`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-loadbalancertargetgroup).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub load_balancer_target_group: Option<::Value<AnalysisComponent>>,
        /// Property [`LoadBalancerTargetGroups`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-loadbalancertargetgroups).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub load_balancer_target_groups: Option<::ValueList<AnalysisComponent>>,
        /// Property [`LoadBalancerTargetPort`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-loadbalancertargetport).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub load_balancer_target_port: Option<::Value<u32>>,
        /// Property [`MissingComponent`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-missingcomponent).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub missing_component: Option<::Value<String>>,
        /// Property [`NatGateway`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-natgateway).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub nat_gateway: Option<::Value<AnalysisComponent>>,
        /// Property [`NetworkInterface`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-networkinterface).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub network_interface: Option<::Value<AnalysisComponent>>,
        /// Property [`PacketField`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-packetfield).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub packet_field: Option<::Value<String>>,
        /// Property [`Port`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-port).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub port: Option<::Value<u32>>,
        /// Property [`PortRanges`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-portranges).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub port_ranges: Option<::ValueList<PortRange>>,
        /// Property [`PrefixList`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-prefixlist).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub prefix_list: Option<::Value<AnalysisComponent>>,
        /// Property [`Protocols`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-protocols).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub protocols: Option<::ValueList<String>>,
        /// Property [`RouteTable`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-routetable).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub route_table: Option<::Value<AnalysisComponent>>,
        /// Property [`RouteTableRoute`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-routetableroute).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub route_table_route: Option<::Value<AnalysisRouteTableRoute>>,
        /// Property [`SecurityGroup`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-securitygroup).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub security_group: Option<::Value<AnalysisComponent>>,
        /// Property [`SecurityGroupRule`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-securitygrouprule).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub security_group_rule: Option<::Value<AnalysisSecurityGroupRule>>,
        /// Property [`SecurityGroups`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-securitygroups).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub security_groups: Option<::ValueList<AnalysisComponent>>,
        /// Property [`SourceVpc`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-sourcevpc).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub source_vpc: Option<::Value<AnalysisComponent>>,
        /// Property [`State`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-state).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub state: Option<::Value<String>>,
        /// Property [`Subnet`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-subnet).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub subnet: Option<::Value<AnalysisComponent>>,
        /// Property [`SubnetRouteTable`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-subnetroutetable).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub subnet_route_table: Option<::Value<AnalysisComponent>>,
        /// Property [`TransitGateway`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-transitgateway).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub transit_gateway: Option<::Value<AnalysisComponent>>,
        /// Property [`TransitGatewayAttachment`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-transitgatewayattachment).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub transit_gateway_attachment: Option<::Value<AnalysisComponent>>,
        /// Property [`TransitGatewayRouteTable`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-transitgatewayroutetable).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub transit_gateway_route_table: Option<::Value<AnalysisComponent>>,
        /// Property [`TransitGatewayRouteTableRoute`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-transitgatewayroutetableroute).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub transit_gateway_route_table_route: Option<::Value<TransitGatewayRouteTableRoute>>,
        /// Property [`Vpc`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-vpc).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub vpc: Option<::Value<AnalysisComponent>>,
        /// Property [`VpcPeeringConnection`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-vpcpeeringconnection).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub vpc_peering_connection: Option<::Value<AnalysisComponent>>,
        /// Property [`VpnConnection`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-vpnconnection).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub vpn_connection: Option<::Value<AnalysisComponent>>,
        /// Property [`VpnGateway`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-vpngateway).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub vpn_gateway: Option<::Value<AnalysisComponent>>,
        /// Property [`vpcEndpoint`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-vpcendpoint).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub vpc_endpoint: Option<::Value<AnalysisComponent>>,
    }

    impl ::codec::SerializeValue for Explanation {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref acl) = self.acl {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Acl", acl)?;
            }
            if let Some(ref acl_rule) = self.acl_rule {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AclRule", acl_rule)?;
            }
            if let Some(ref address) = self.address {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Address", address)?;
            }
            if let Some(ref addresses) = self.addresses {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Addresses", addresses)?;
            }
            if let Some(ref attached_to) = self.attached_to {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AttachedTo", attached_to)?;
            }
            if let Some(ref availability_zones) = self.availability_zones {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AvailabilityZones", availability_zones)?;
            }
            if let Some(ref cidrs) = self.cidrs {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Cidrs", cidrs)?;
            }
            if let Some(ref classic_load_balancer_listener) = self.classic_load_balancer_listener {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ClassicLoadBalancerListener", classic_load_balancer_listener)?;
            }
            if let Some(ref component) = self.component {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Component", component)?;
            }
            if let Some(ref component_account) = self.component_account {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ComponentAccount", component_account)?;
            }
            if let Some(ref component_region) = self.component_region {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ComponentRegion", component_region)?;
            }
            if let Some(ref customer_gateway) = self.customer_gateway {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "CustomerGateway", customer_gateway)?;
            }
            if let Some(ref destination) = self.destination {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Destination", destination)?;
            }
            if let Some(ref destination_vpc) = self.destination_vpc {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "DestinationVpc", destination_vpc)?;
            }
            if let Some(ref direction) = self.direction {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Direction", direction)?;
            }
            if let Some(ref elastic_load_balancer_listener) = self.elastic_load_balancer_listener {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ElasticLoadBalancerListener", elastic_load_balancer_listener)?;
            }
            if let Some(ref explanation_code) = self.explanation_code {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ExplanationCode", explanation_code)?;
            }
            if let Some(ref ingress_route_table) = self.ingress_route_table {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "IngressRouteTable", ingress_route_table)?;
            }
            if let Some(ref internet_gateway) = self.internet_gateway {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "InternetGateway", internet_gateway)?;
            }
            if let Some(ref load_balancer_arn) = self.load_balancer_arn {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "LoadBalancerArn", load_balancer_arn)?;
            }
            if let Some(ref load_balancer_listener_port) = self.load_balancer_listener_port {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "LoadBalancerListenerPort", load_balancer_listener_port)?;
            }
            if let Some(ref load_balancer_target) = self.load_balancer_target {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "LoadBalancerTarget", load_balancer_target)?;
            }
            if let Some(ref load_balancer_target_group) = self.load_balancer_target_group {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "LoadBalancerTargetGroup", load_balancer_target_group)?;
            }
            if let Some(ref load_balancer_target_groups) = self.load_balancer_target_groups {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "LoadBalancerTargetGroups", load_balancer_target_groups)?;
            }
            if let Some(ref load_balancer_target_port) = self.load_balancer_target_port {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "LoadBalancerTargetPort", load_balancer_target_port)?;
            }
            if let Some(ref missing_component) = self.missing_component {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "MissingComponent", missing_component)?;
            }
            if let Some(ref nat_gateway) = self.nat_gateway {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "NatGateway", nat_gateway)?;
            }
            if let Some(ref network_interface) = self.network_interface {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetworkInterface", network_interface)?;
            }
            if let Some(ref packet_field) = self.packet_field {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "PacketField", packet_field)?;
            }
            if let Some(ref port) = self.port {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Port", port)?;
            }
            if let Some(ref port_ranges) = self.port_ranges {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "PortRanges", port_ranges)?;
            }
            if let Some(ref prefix_list) = self.prefix_list {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "PrefixList", prefix_list)?;
            }
            if let Some(ref protocols) = self.protocols {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Protocols", protocols)?;
            }
            if let Some(ref route_table) = self.route_table {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "RouteTable", route_table)?;
            }
            if let Some(ref route_table_route) = self.route_table_route {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "RouteTableRoute", route_table_route)?;
            }
            if let Some(ref security_group) = self.security_group {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SecurityGroup", security_group)?;
            }
            if let Some(ref security_group_rule) = self.security_group_rule {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SecurityGroupRule", security_group_rule)?;
            }
            if let Some(ref security_groups) = self.security_groups {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SecurityGroups", security_groups)?;
            }
            if let Some(ref source_vpc) = self.source_vpc {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SourceVpc", source_vpc)?;
            }
            if let Some(ref state) = self.state {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "State", state)?;
            }
            if let Some(ref subnet) = self.subnet {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Subnet", subnet)?;
            }
            if let Some(ref subnet_route_table) = self.subnet_route_table {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SubnetRouteTable", subnet_route_table)?;
            }
            if let Some(ref transit_gateway) = self.transit_gateway {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "TransitGateway", transit_gateway)?;
            }
            if let Some(ref transit_gateway_attachment) = self.transit_gateway_attachment {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "TransitGatewayAttachment", transit_gateway_attachment)?;
            }
            if let Some(ref transit_gateway_route_table) = self.transit_gateway_route_table {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "TransitGatewayRouteTable", transit_gateway_route_table)?;
            }
            if let Some(ref transit_gateway_route_table_route) = self.transit_gateway_route_table_route {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "TransitGatewayRouteTableRoute", transit_gateway_route_table_route)?;
            }
            if let Some(ref vpc) = self.vpc {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Vpc", vpc)?;
            }
            if let Some(ref vpc_peering_connection) = self.vpc_peering_connection {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "VpcPeeringConnection", vpc_peering_connection)?;
            }
            if let Some(ref vpn_connection) = self.vpn_connection {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "VpnConnection", vpn_connection)?;
            }
            if let Some(ref vpn_gateway) = self.vpn_gateway {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "VpnGateway", vpn_gateway)?;
            }
            if let Some(ref vpc_endpoint) = self.vpc_endpoint {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "vpcEndpoint", vpc_endpoint)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for Explanation {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<Explanation, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = Explanation;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type Explanation")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut acl: Option<::Value<AnalysisComponent>> = None;
                    let mut acl_rule: Option<::Value<AnalysisAclRule>> = None;
                    let mut address: Option<::Value<String>> = None;
                    let mut addresses: Option<::ValueList<String>> = None;
                    let mut attached_to: Option<::Value<AnalysisComponent>> = None;
                    let mut availability_zones: Option<::ValueList<String>> = None;
                    let mut cidrs: Option<::ValueList<String>> = None;
                    let mut classic_load_balancer_listener: Option<::Value<AnalysisLoadBalancerListener>> = None;
                    let mut component: Option<::Value<AnalysisComponent>> = None;
                    let mut component_account: Option<::Value<String>> = None;
                    let mut component_region: Option<::Value<String>> = None;
                    let mut customer_gateway: Option<::Value<AnalysisComponent>> = None;
                    let mut destination: Option<::Value<AnalysisComponent>> = None;
                    let mut destination_vpc: Option<::Value<AnalysisComponent>> = None;
                    let mut direction: Option<::Value<String>> = None;
                    let mut elastic_load_balancer_listener: Option<::Value<AnalysisComponent>> = None;
                    let mut explanation_code: Option<::Value<String>> = None;
                    let mut ingress_route_table: Option<::Value<AnalysisComponent>> = None;
                    let mut internet_gateway: Option<::Value<AnalysisComponent>> = None;
                    let mut load_balancer_arn: Option<::Value<String>> = None;
                    let mut load_balancer_listener_port: Option<::Value<u32>> = None;
                    let mut load_balancer_target: Option<::Value<AnalysisLoadBalancerTarget>> = None;
                    let mut load_balancer_target_group: Option<::Value<AnalysisComponent>> = None;
                    let mut load_balancer_target_groups: Option<::ValueList<AnalysisComponent>> = None;
                    let mut load_balancer_target_port: Option<::Value<u32>> = None;
                    let mut missing_component: Option<::Value<String>> = None;
                    let mut nat_gateway: Option<::Value<AnalysisComponent>> = None;
                    let mut network_interface: Option<::Value<AnalysisComponent>> = None;
                    let mut packet_field: Option<::Value<String>> = None;
                    let mut port: Option<::Value<u32>> = None;
                    let mut port_ranges: Option<::ValueList<PortRange>> = None;
                    let mut prefix_list: Option<::Value<AnalysisComponent>> = None;
                    let mut protocols: Option<::ValueList<String>> = None;
                    let mut route_table: Option<::Value<AnalysisComponent>> = None;
                    let mut route_table_route: Option<::Value<AnalysisRouteTableRoute>> = None;
                    let mut security_group: Option<::Value<AnalysisComponent>> = None;
                    let mut security_group_rule: Option<::Value<AnalysisSecurityGroupRule>> = None;
                    let mut security_groups: Option<::ValueList<AnalysisComponent>> = None;
                    let mut source_vpc: Option<::Value<AnalysisComponent>> = None;
                    let mut state: Option<::Value<String>> = None;
                    let mut subnet: Option<::Value<AnalysisComponent>> = None;
                    let mut subnet_route_table: Option<::Value<AnalysisComponent>> = None;
                    let mut transit_gateway: Option<::Value<AnalysisComponent>> = None;
                    let mut transit_gateway_attachment: Option<::Value<AnalysisComponent>> = None;
                    let mut transit_gateway_route_table: Option<::Value<AnalysisComponent>> = None;
                    let mut transit_gateway_route_table_route: Option<::Value<TransitGatewayRouteTableRoute>> = None;
                    let mut vpc: Option<::Value<AnalysisComponent>> = None;
                    let mut vpc_peering_connection: Option<::Value<AnalysisComponent>> = None;
                    let mut vpn_connection: Option<::Value<AnalysisComponent>> = None;
                    let mut vpn_gateway: Option<::Value<AnalysisComponent>> = None;
                    let mut vpc_endpoint: Option<::Value<AnalysisComponent>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Acl" => {
                                acl = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "AclRule" => {
                                acl_rule = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Address" => {
                                address = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Addresses" => {
                                addresses = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "AttachedTo" => {
                                attached_to = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "AvailabilityZones" => {
                                availability_zones = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Cidrs" => {
                                cidrs = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ClassicLoadBalancerListener" => {
                                classic_load_balancer_listener = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Component" => {
                                component = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ComponentAccount" => {
                                component_account = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ComponentRegion" => {
                                component_region = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "CustomerGateway" => {
                                customer_gateway = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Destination" => {
                                destination = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "DestinationVpc" => {
                                destination_vpc = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Direction" => {
                                direction = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ElasticLoadBalancerListener" => {
                                elastic_load_balancer_listener = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ExplanationCode" => {
                                explanation_code = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "IngressRouteTable" => {
                                ingress_route_table = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "InternetGateway" => {
                                internet_gateway = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "LoadBalancerArn" => {
                                load_balancer_arn = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "LoadBalancerListenerPort" => {
                                load_balancer_listener_port = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "LoadBalancerTarget" => {
                                load_balancer_target = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "LoadBalancerTargetGroup" => {
                                load_balancer_target_group = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "LoadBalancerTargetGroups" => {
                                load_balancer_target_groups = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "LoadBalancerTargetPort" => {
                                load_balancer_target_port = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "MissingComponent" => {
                                missing_component = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "NatGateway" => {
                                nat_gateway = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "NetworkInterface" => {
                                network_interface = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "PacketField" => {
                                packet_field = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Port" => {
                                port = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "PortRanges" => {
                                port_ranges = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "PrefixList" => {
                                prefix_list = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Protocols" => {
                                protocols = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "RouteTable" => {
                                route_table = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "RouteTableRoute" => {
                                route_table_route = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SecurityGroup" => {
                                security_group = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SecurityGroupRule" => {
                                security_group_rule = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SecurityGroups" => {
                                security_groups = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SourceVpc" => {
                                source_vpc = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "State" => {
                                state = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Subnet" => {
                                subnet = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SubnetRouteTable" => {
                                subnet_route_table = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "TransitGateway" => {
                                transit_gateway = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "TransitGatewayAttachment" => {
                                transit_gateway_attachment = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "TransitGatewayRouteTable" => {
                                transit_gateway_route_table = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "TransitGatewayRouteTableRoute" => {
                                transit_gateway_route_table_route = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Vpc" => {
                                vpc = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "VpcPeeringConnection" => {
                                vpc_peering_connection = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "VpnConnection" => {
                                vpn_connection = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "VpnGateway" => {
                                vpn_gateway = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "vpcEndpoint" => {
                                vpc_endpoint = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(Explanation {
                        acl: acl,
                        acl_rule: acl_rule,
                        address: address,
                        addresses: addresses,
                        attached_to: attached_to,
                        availability_zones: availability_zones,
                        cidrs: cidrs,
                        classic_load_balancer_listener: classic_load_balancer_listener,
                        component: component,
                        component_account: component_account,
                        component_region: component_region,
                        customer_gateway: customer_gateway,
                        destination: destination,
                        destination_vpc: destination_vpc,
                        direction: direction,
                        elastic_load_balancer_listener: elastic_load_balancer_listener,
                        explanation_code: explanation_code,
                        ingress_route_table: ingress_route_table,
                        internet_gateway: internet_gateway,
                        load_balancer_arn: load_balancer_arn,
                        load_balancer_listener_port: load_balancer_listener_port,
                        load_balancer_target: load_balancer_target,
                        load_balancer_target_group: load_balancer_target_group,
                        load_balancer_target_groups: load_balancer_target_groups,
                        load_balancer_target_port: load_balancer_target_port,
                        missing_component: missing_component,
                        nat_gateway: nat_gateway,
                        network_interface: network_interface,
                        packet_field: packet_field,
                        port: port,
                        port_ranges: port_ranges,
                        prefix_list: prefix_list,
                        protocols: protocols,
                        route_table: route_table,
                        route_table_route: route_table_route,
                        security_group: security_group,
                        security_group_rule: security_group_rule,
                        security_groups: security_groups,
                        source_vpc: source_vpc,
                        state: state,
                        subnet: subnet,
                        subnet_route_table: subnet_route_table,
                        transit_gateway: transit_gateway,
                        transit_gateway_attachment: transit_gateway_attachment,
                        transit_gateway_route_table: transit_gateway_route_table,
                        transit_gateway_route_table_route: transit_gateway_route_table_route,
                        vpc: vpc,
                        vpc_peering_connection: vpc_peering_connection,
                        vpn_connection: vpn_connection,
                        vpn_gateway: vpn_gateway,
                        vpc_endpoint: vpc_endpoint,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::NetworkInsightsAnalysis.PathComponent`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html) property type.
    #[derive(Debug, Default)]
    pub struct PathComponent {
        /// Property [`AclRule`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-aclrule).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub acl_rule: Option<::Value<AnalysisAclRule>>,
        /// Property [`AdditionalDetails`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-additionaldetails).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub additional_details: Option<::ValueList<AdditionalDetail>>,
        /// Property [`Component`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-component).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub component: Option<::Value<AnalysisComponent>>,
        /// Property [`DestinationVpc`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-destinationvpc).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub destination_vpc: Option<::Value<AnalysisComponent>>,
        /// Property [`ElasticLoadBalancerListener`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-elasticloadbalancerlistener).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub elastic_load_balancer_listener: Option<::Value<AnalysisComponent>>,
        /// Property [`Explanations`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-explanations).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub explanations: Option<::ValueList<Explanation>>,
        /// Property [`InboundHeader`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-inboundheader).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub inbound_header: Option<::Value<AnalysisPacketHeader>>,
        /// Property [`OutboundHeader`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-outboundheader).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub outbound_header: Option<::Value<AnalysisPacketHeader>>,
        /// Property [`RouteTableRoute`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-routetableroute).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub route_table_route: Option<::Value<AnalysisRouteTableRoute>>,
        /// Property [`SecurityGroupRule`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-securitygrouprule).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub security_group_rule: Option<::Value<AnalysisSecurityGroupRule>>,
        /// Property [`SequenceNumber`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-sequencenumber).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub sequence_number: Option<::Value<u32>>,
        /// Property [`ServiceName`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-servicename).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub service_name: Option<::Value<String>>,
        /// Property [`SourceVpc`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-sourcevpc).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub source_vpc: Option<::Value<AnalysisComponent>>,
        /// Property [`Subnet`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-subnet).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub subnet: Option<::Value<AnalysisComponent>>,
        /// Property [`TransitGateway`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-transitgateway).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub transit_gateway: Option<::Value<AnalysisComponent>>,
        /// Property [`TransitGatewayRouteTableRoute`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-transitgatewayroutetableroute).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub transit_gateway_route_table_route: Option<::Value<TransitGatewayRouteTableRoute>>,
        /// Property [`Vpc`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-vpc).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub vpc: Option<::Value<AnalysisComponent>>,
    }

    impl ::codec::SerializeValue for PathComponent {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref acl_rule) = self.acl_rule {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AclRule", acl_rule)?;
            }
            if let Some(ref additional_details) = self.additional_details {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AdditionalDetails", additional_details)?;
            }
            if let Some(ref component) = self.component {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Component", component)?;
            }
            if let Some(ref destination_vpc) = self.destination_vpc {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "DestinationVpc", destination_vpc)?;
            }
            if let Some(ref elastic_load_balancer_listener) = self.elastic_load_balancer_listener {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ElasticLoadBalancerListener", elastic_load_balancer_listener)?;
            }
            if let Some(ref explanations) = self.explanations {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Explanations", explanations)?;
            }
            if let Some(ref inbound_header) = self.inbound_header {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "InboundHeader", inbound_header)?;
            }
            if let Some(ref outbound_header) = self.outbound_header {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "OutboundHeader", outbound_header)?;
            }
            if let Some(ref route_table_route) = self.route_table_route {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "RouteTableRoute", route_table_route)?;
            }
            if let Some(ref security_group_rule) = self.security_group_rule {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SecurityGroupRule", security_group_rule)?;
            }
            if let Some(ref sequence_number) = self.sequence_number {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SequenceNumber", sequence_number)?;
            }
            if let Some(ref service_name) = self.service_name {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ServiceName", service_name)?;
            }
            if let Some(ref source_vpc) = self.source_vpc {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SourceVpc", source_vpc)?;
            }
            if let Some(ref subnet) = self.subnet {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Subnet", subnet)?;
            }
            if let Some(ref transit_gateway) = self.transit_gateway {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "TransitGateway", transit_gateway)?;
            }
            if let Some(ref transit_gateway_route_table_route) = self.transit_gateway_route_table_route {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "TransitGatewayRouteTableRoute", transit_gateway_route_table_route)?;
            }
            if let Some(ref vpc) = self.vpc {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Vpc", vpc)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for PathComponent {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<PathComponent, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = PathComponent;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type PathComponent")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut acl_rule: Option<::Value<AnalysisAclRule>> = None;
                    let mut additional_details: Option<::ValueList<AdditionalDetail>> = None;
                    let mut component: Option<::Value<AnalysisComponent>> = None;
                    let mut destination_vpc: Option<::Value<AnalysisComponent>> = None;
                    let mut elastic_load_balancer_listener: Option<::Value<AnalysisComponent>> = None;
                    let mut explanations: Option<::ValueList<Explanation>> = None;
                    let mut inbound_header: Option<::Value<AnalysisPacketHeader>> = None;
                    let mut outbound_header: Option<::Value<AnalysisPacketHeader>> = None;
                    let mut route_table_route: Option<::Value<AnalysisRouteTableRoute>> = None;
                    let mut security_group_rule: Option<::Value<AnalysisSecurityGroupRule>> = None;
                    let mut sequence_number: Option<::Value<u32>> = None;
                    let mut service_name: Option<::Value<String>> = None;
                    let mut source_vpc: Option<::Value<AnalysisComponent>> = None;
                    let mut subnet: Option<::Value<AnalysisComponent>> = None;
                    let mut transit_gateway: Option<::Value<AnalysisComponent>> = None;
                    let mut transit_gateway_route_table_route: Option<::Value<TransitGatewayRouteTableRoute>> = None;
                    let mut vpc: Option<::Value<AnalysisComponent>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "AclRule" => {
                                acl_rule = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "AdditionalDetails" => {
                                additional_details = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Component" => {
                                component = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "DestinationVpc" => {
                                destination_vpc = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ElasticLoadBalancerListener" => {
                                elastic_load_balancer_listener = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Explanations" => {
                                explanations = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "InboundHeader" => {
                                inbound_header = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "OutboundHeader" => {
                                outbound_header = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "RouteTableRoute" => {
                                route_table_route = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SecurityGroupRule" => {
                                security_group_rule = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SequenceNumber" => {
                                sequence_number = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ServiceName" => {
                                service_name = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SourceVpc" => {
                                source_vpc = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Subnet" => {
                                subnet = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "TransitGateway" => {
                                transit_gateway = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "TransitGatewayRouteTableRoute" => {
                                transit_gateway_route_table_route = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Vpc" => {
                                vpc = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(PathComponent {
                        acl_rule: acl_rule,
                        additional_details: additional_details,
                        component: component,
                        destination_vpc: destination_vpc,
                        elastic_load_balancer_listener: elastic_load_balancer_listener,
                        explanations: explanations,
                        inbound_header: inbound_header,
                        outbound_header: outbound_header,
                        route_table_route: route_table_route,
                        security_group_rule: security_group_rule,
                        sequence_number: sequence_number,
                        service_name: service_name,
                        source_vpc: source_vpc,
                        subnet: subnet,
                        transit_gateway: transit_gateway,
                        transit_gateway_route_table_route: transit_gateway_route_table_route,
                        vpc: vpc,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::NetworkInsightsAnalysis.PortRange`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-portrange.html) property type.
    #[derive(Debug, Default)]
    pub struct PortRange {
        /// Property [`From`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-portrange.html#cfn-ec2-networkinsightsanalysis-portrange-from).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub from: Option<::Value<u32>>,
        /// Property [`To`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-portrange.html#cfn-ec2-networkinsightsanalysis-portrange-to).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub to: Option<::Value<u32>>,
    }

    impl ::codec::SerializeValue for PortRange {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref from) = self.from {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "From", from)?;
            }
            if let Some(ref to) = self.to {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "To", to)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for PortRange {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<PortRange, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = PortRange;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type PortRange")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut from: Option<::Value<u32>> = None;
                    let mut to: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "From" => {
                                from = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "To" => {
                                to = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(PortRange {
                        from: from,
                        to: to,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::NetworkInsightsAnalysis.TransitGatewayRouteTableRoute`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-transitgatewayroutetableroute.html) property type.
    #[derive(Debug, Default)]
    pub struct TransitGatewayRouteTableRoute {
        /// Property [`AttachmentId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-transitgatewayroutetableroute.html#cfn-ec2-networkinsightsanalysis-transitgatewayroutetableroute-attachmentid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub attachment_id: Option<::Value<String>>,
        /// Property [`DestinationCidr`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-transitgatewayroutetableroute.html#cfn-ec2-networkinsightsanalysis-transitgatewayroutetableroute-destinationcidr).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub destination_cidr: Option<::Value<String>>,
        /// Property [`PrefixListId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-transitgatewayroutetableroute.html#cfn-ec2-networkinsightsanalysis-transitgatewayroutetableroute-prefixlistid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub prefix_list_id: Option<::Value<String>>,
        /// Property [`ResourceId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-transitgatewayroutetableroute.html#cfn-ec2-networkinsightsanalysis-transitgatewayroutetableroute-resourceid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub resource_id: Option<::Value<String>>,
        /// Property [`ResourceType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-transitgatewayroutetableroute.html#cfn-ec2-networkinsightsanalysis-transitgatewayroutetableroute-resourcetype).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub resource_type: Option<::Value<String>>,
        /// Property [`RouteOrigin`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-transitgatewayroutetableroute.html#cfn-ec2-networkinsightsanalysis-transitgatewayroutetableroute-routeorigin).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub route_origin: Option<::Value<String>>,
        /// Property [`State`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-transitgatewayroutetableroute.html#cfn-ec2-networkinsightsanalysis-transitgatewayroutetableroute-state).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub state: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for TransitGatewayRouteTableRoute {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref attachment_id) = self.attachment_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AttachmentId", attachment_id)?;
            }
            if let Some(ref destination_cidr) = self.destination_cidr {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "DestinationCidr", destination_cidr)?;
            }
            if let Some(ref prefix_list_id) = self.prefix_list_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "PrefixListId", prefix_list_id)?;
            }
            if let Some(ref resource_id) = self.resource_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ResourceId", resource_id)?;
            }
            if let Some(ref resource_type) = self.resource_type {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ResourceType", resource_type)?;
            }
            if let Some(ref route_origin) = self.route_origin {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "RouteOrigin", route_origin)?;
            }
            if let Some(ref state) = self.state {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "State", state)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for TransitGatewayRouteTableRoute {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<TransitGatewayRouteTableRoute, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = TransitGatewayRouteTableRoute;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type TransitGatewayRouteTableRoute")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut attachment_id: Option<::Value<String>> = None;
                    let mut destination_cidr: Option<::Value<String>> = None;
                    let mut prefix_list_id: Option<::Value<String>> = None;
                    let mut resource_id: Option<::Value<String>> = None;
                    let mut resource_type: Option<::Value<String>> = None;
                    let mut route_origin: Option<::Value<String>> = None;
                    let mut state: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "AttachmentId" => {
                                attachment_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "DestinationCidr" => {
                                destination_cidr = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "PrefixListId" => {
                                prefix_list_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ResourceId" => {
                                resource_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ResourceType" => {
                                resource_type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "RouteOrigin" => {
                                route_origin = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "State" => {
                                state = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(TransitGatewayRouteTableRoute {
                        attachment_id: attachment_id,
                        destination_cidr: destination_cidr,
                        prefix_list_id: prefix_list_id,
                        resource_id: resource_id,
                        resource_type: resource_type,
                        route_origin: route_origin,
                        state: state,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }
}

pub mod network_insights_path {
    //! Property types for the `NetworkInsightsPath` resource.

    /// The [`AWS::EC2::NetworkInsightsPath.FilterPortRange`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-filterportrange.html) property type.
    #[derive(Debug, Default)]
    pub struct FilterPortRange {
        /// Property [`FromPort`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-filterportrange.html#cfn-ec2-networkinsightspath-filterportrange-fromport).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub from_port: Option<::Value<u32>>,
        /// Property [`ToPort`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-filterportrange.html#cfn-ec2-networkinsightspath-filterportrange-toport).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub to_port: Option<::Value<u32>>,
    }

    impl ::codec::SerializeValue for FilterPortRange {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref from_port) = self.from_port {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "FromPort", from_port)?;
            }
            if let Some(ref to_port) = self.to_port {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ToPort", to_port)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for FilterPortRange {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<FilterPortRange, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = FilterPortRange;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type FilterPortRange")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut from_port: Option<::Value<u32>> = None;
                    let mut to_port: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "FromPort" => {
                                from_port = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ToPort" => {
                                to_port = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(FilterPortRange {
                        from_port: from_port,
                        to_port: to_port,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::NetworkInsightsPath.PathFilter`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-pathfilter.html) property type.
    #[derive(Debug, Default)]
    pub struct PathFilter {
        /// Property [`DestinationAddress`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-pathfilter.html#cfn-ec2-networkinsightspath-pathfilter-destinationaddress).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub destination_address: Option<::Value<String>>,
        /// Property [`DestinationPortRange`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-pathfilter.html#cfn-ec2-networkinsightspath-pathfilter-destinationportrange).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub destination_port_range: Option<::Value<FilterPortRange>>,
        /// Property [`SourceAddress`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-pathfilter.html#cfn-ec2-networkinsightspath-pathfilter-sourceaddress).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub source_address: Option<::Value<String>>,
        /// Property [`SourcePortRange`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightspath-pathfilter.html#cfn-ec2-networkinsightspath-pathfilter-sourceportrange).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub source_port_range: Option<::Value<FilterPortRange>>,
    }

    impl ::codec::SerializeValue for PathFilter {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref destination_address) = self.destination_address {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "DestinationAddress", destination_address)?;
            }
            if let Some(ref destination_port_range) = self.destination_port_range {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "DestinationPortRange", destination_port_range)?;
            }
            if let Some(ref source_address) = self.source_address {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SourceAddress", source_address)?;
            }
            if let Some(ref source_port_range) = self.source_port_range {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SourcePortRange", source_port_range)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for PathFilter {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<PathFilter, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = PathFilter;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type PathFilter")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut destination_address: Option<::Value<String>> = None;
                    let mut destination_port_range: Option<::Value<FilterPortRange>> = None;
                    let mut source_address: Option<::Value<String>> = None;
                    let mut source_port_range: Option<::Value<FilterPortRange>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "DestinationAddress" => {
                                destination_address = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "DestinationPortRange" => {
                                destination_port_range = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SourceAddress" => {
                                source_address = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SourcePortRange" => {
                                source_port_range = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(PathFilter {
                        destination_address: destination_address,
                        destination_port_range: destination_port_range,
                        source_address: source_address,
                        source_port_range: source_port_range,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }
}

pub mod network_interface {
    //! Property types for the `NetworkInterface` resource.

    /// The [`AWS::EC2::NetworkInterface.ConnectionTrackingSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-connectiontrackingspecification.html) property type.
    #[derive(Debug, Default)]
    pub struct ConnectionTrackingSpecification {
        /// Property [`TcpEstablishedTimeout`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-connectiontrackingspecification.html#cfn-ec2-networkinterface-connectiontrackingspecification-tcpestablishedtimeout).
        ///
        /// Update type: _Conditional_.
        /// Conditional updates can be mutable or immutable, depending on, for example, which other properties you updated.
        /// For more information, see the relevant resource type documentation.
        pub tcp_established_timeout: Option<::Value<u32>>,
        /// Property [`UdpStreamTimeout`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-connectiontrackingspecification.html#cfn-ec2-networkinterface-connectiontrackingspecification-udpstreamtimeout).
        ///
        /// Update type: _Conditional_.
        /// Conditional updates can be mutable or immutable, depending on, for example, which other properties you updated.
        /// For more information, see the relevant resource type documentation.
        pub udp_stream_timeout: Option<::Value<u32>>,
        /// Property [`UdpTimeout`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-connectiontrackingspecification.html#cfn-ec2-networkinterface-connectiontrackingspecification-udptimeout).
        ///
        /// Update type: _Conditional_.
        /// Conditional updates can be mutable or immutable, depending on, for example, which other properties you updated.
        /// For more information, see the relevant resource type documentation.
        pub udp_timeout: Option<::Value<u32>>,
    }

    impl ::codec::SerializeValue for ConnectionTrackingSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref tcp_established_timeout) = self.tcp_established_timeout {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "TcpEstablishedTimeout", tcp_established_timeout)?;
            }
            if let Some(ref udp_stream_timeout) = self.udp_stream_timeout {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "UdpStreamTimeout", udp_stream_timeout)?;
            }
            if let Some(ref udp_timeout) = self.udp_timeout {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "UdpTimeout", udp_timeout)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for ConnectionTrackingSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<ConnectionTrackingSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = ConnectionTrackingSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type ConnectionTrackingSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut tcp_established_timeout: Option<::Value<u32>> = None;
                    let mut udp_stream_timeout: Option<::Value<u32>> = None;
                    let mut udp_timeout: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "TcpEstablishedTimeout" => {
                                tcp_established_timeout = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "UdpStreamTimeout" => {
                                udp_stream_timeout = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "UdpTimeout" => {
                                udp_timeout = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(ConnectionTrackingSpecification {
                        tcp_established_timeout: tcp_established_timeout,
                        udp_stream_timeout: udp_stream_timeout,
                        udp_timeout: udp_timeout,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::NetworkInterface.InstanceIpv6Address`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-instanceipv6address.html) property type.
    #[derive(Debug, Default)]
    pub struct InstanceIpv6Address {
        /// Property [`Ipv6Address`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-instanceipv6address.html#cfn-ec2-networkinterface-instanceipv6address-ipv6address).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub ipv6_address: ::Value<String>,
    }

    impl ::codec::SerializeValue for InstanceIpv6Address {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6Address", &self.ipv6_address)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for InstanceIpv6Address {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<InstanceIpv6Address, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = InstanceIpv6Address;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type InstanceIpv6Address")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut ipv6_address: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Ipv6Address" => {
                                ipv6_address = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(InstanceIpv6Address {
                        ipv6_address: ipv6_address.ok_or(::serde::de::Error::missing_field("Ipv6Address"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::NetworkInterface.Ipv4PrefixSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-ipv4prefixspecification.html) property type.
    #[derive(Debug, Default)]
    pub struct Ipv4PrefixSpecification {
        /// Property [`Ipv4Prefix`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-ipv4prefixspecification.html#cfn-ec2-networkinterface-ipv4prefixspecification-ipv4prefix).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub ipv4_prefix: ::Value<String>,
    }

    impl ::codec::SerializeValue for Ipv4PrefixSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv4Prefix", &self.ipv4_prefix)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for Ipv4PrefixSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<Ipv4PrefixSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = Ipv4PrefixSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type Ipv4PrefixSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut ipv4_prefix: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Ipv4Prefix" => {
                                ipv4_prefix = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(Ipv4PrefixSpecification {
                        ipv4_prefix: ipv4_prefix.ok_or(::serde::de::Error::missing_field("Ipv4Prefix"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::NetworkInterface.Ipv6PrefixSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-ipv6prefixspecification.html) property type.
    #[derive(Debug, Default)]
    pub struct Ipv6PrefixSpecification {
        /// Property [`Ipv6Prefix`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-ipv6prefixspecification.html#cfn-ec2-networkinterface-ipv6prefixspecification-ipv6prefix).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub ipv6_prefix: ::Value<String>,
    }

    impl ::codec::SerializeValue for Ipv6PrefixSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6Prefix", &self.ipv6_prefix)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for Ipv6PrefixSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<Ipv6PrefixSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = Ipv6PrefixSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type Ipv6PrefixSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut ipv6_prefix: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Ipv6Prefix" => {
                                ipv6_prefix = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(Ipv6PrefixSpecification {
                        ipv6_prefix: ipv6_prefix.ok_or(::serde::de::Error::missing_field("Ipv6Prefix"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::NetworkInterface.PrivateIpAddressSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-privateipaddressspecification.html) property type.
    #[derive(Debug, Default)]
    pub struct PrivateIpAddressSpecification {
        /// Property [`Primary`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-privateipaddressspecification.html#cfn-ec2-networkinterface-privateipaddressspecification-primary).
        ///
        /// Update type: _Conditional_.
        /// Conditional updates can be mutable or immutable, depending on, for example, which other properties you updated.
        /// For more information, see the relevant resource type documentation.
        pub primary: ::Value<bool>,
        /// Property [`PrivateIpAddress`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-privateipaddressspecification.html#cfn-ec2-networkinterface-privateipaddressspecification-privateipaddress).
        ///
        /// Update type: _Conditional_.
        /// Conditional updates can be mutable or immutable, depending on, for example, which other properties you updated.
        /// For more information, see the relevant resource type documentation.
        pub private_ip_address: ::Value<String>,
    }

    impl ::codec::SerializeValue for PrivateIpAddressSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Primary", &self.primary)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "PrivateIpAddress", &self.private_ip_address)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for PrivateIpAddressSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<PrivateIpAddressSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = PrivateIpAddressSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type PrivateIpAddressSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut primary: Option<::Value<bool>> = None;
                    let mut private_ip_address: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Primary" => {
                                primary = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "PrivateIpAddress" => {
                                private_ip_address = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(PrivateIpAddressSpecification {
                        primary: primary.ok_or(::serde::de::Error::missing_field("Primary"))?,
                        private_ip_address: private_ip_address.ok_or(::serde::de::Error::missing_field("PrivateIpAddress"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }
}

pub mod prefix_list {
    //! Property types for the `PrefixList` resource.

    /// The [`AWS::EC2::PrefixList.Entry`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-prefixlist-entry.html) property type.
    #[derive(Debug, Default)]
    pub struct Entry {
        /// Property [`Cidr`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-prefixlist-entry.html#cfn-ec2-prefixlist-entry-cidr).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub cidr: ::Value<String>,
        /// Property [`Description`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-prefixlist-entry.html#cfn-ec2-prefixlist-entry-description).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub description: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for Entry {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Cidr", &self.cidr)?;
            if let Some(ref description) = self.description {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Description", description)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for Entry {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<Entry, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = Entry;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type Entry")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut cidr: Option<::Value<String>> = None;
                    let mut description: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Cidr" => {
                                cidr = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Description" => {
                                description = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(Entry {
                        cidr: cidr.ok_or(::serde::de::Error::missing_field("Cidr"))?,
                        description: description,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }
}

pub mod security_group {
    //! Property types for the `SecurityGroup` resource.

    /// The [`AWS::EC2::SecurityGroup.Egress`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html) property type.
    #[derive(Debug, Default)]
    pub struct Egress {
        /// Property [`CidrIp`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-security-group-rule-cidrip).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub cidr_ip: Option<::Value<String>>,
        /// Property [`CidrIpv6`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-security-group-rule-cidripv6).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub cidr_ipv6: Option<::Value<String>>,
        /// Property [`Description`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-security-group-rule-description).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub description: Option<::Value<String>>,
        /// Property [`DestinationPrefixListId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-security-group-rule-destinationprefixlistid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub destination_prefix_list_id: Option<::Value<String>>,
        /// Property [`DestinationSecurityGroupId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-security-group-rule-destsecgroupid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub destination_security_group_id: Option<::Value<String>>,
        /// Property [`FromPort`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-security-group-rule-fromport).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub from_port: Option<::Value<u32>>,
        /// Property [`IpProtocol`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-security-group-rule-ipprotocol).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub ip_protocol: ::Value<String>,
        /// Property [`ToPort`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-security-group-rule-toport).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub to_port: Option<::Value<u32>>,
    }

    impl ::codec::SerializeValue for Egress {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref cidr_ip) = self.cidr_ip {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "CidrIp", cidr_ip)?;
            }
            if let Some(ref cidr_ipv6) = self.cidr_ipv6 {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "CidrIpv6", cidr_ipv6)?;
            }
            if let Some(ref description) = self.description {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Description", description)?;
            }
            if let Some(ref destination_prefix_list_id) = self.destination_prefix_list_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "DestinationPrefixListId", destination_prefix_list_id)?;
            }
            if let Some(ref destination_security_group_id) = self.destination_security_group_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "DestinationSecurityGroupId", destination_security_group_id)?;
            }
            if let Some(ref from_port) = self.from_port {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "FromPort", from_port)?;
            }
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "IpProtocol", &self.ip_protocol)?;
            if let Some(ref to_port) = self.to_port {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ToPort", to_port)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for Egress {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<Egress, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = Egress;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type Egress")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut cidr_ip: Option<::Value<String>> = None;
                    let mut cidr_ipv6: Option<::Value<String>> = None;
                    let mut description: Option<::Value<String>> = None;
                    let mut destination_prefix_list_id: Option<::Value<String>> = None;
                    let mut destination_security_group_id: Option<::Value<String>> = None;
                    let mut from_port: Option<::Value<u32>> = None;
                    let mut ip_protocol: Option<::Value<String>> = None;
                    let mut to_port: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "CidrIp" => {
                                cidr_ip = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "CidrIpv6" => {
                                cidr_ipv6 = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Description" => {
                                description = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "DestinationPrefixListId" => {
                                destination_prefix_list_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "DestinationSecurityGroupId" => {
                                destination_security_group_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "FromPort" => {
                                from_port = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "IpProtocol" => {
                                ip_protocol = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ToPort" => {
                                to_port = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(Egress {
                        cidr_ip: cidr_ip,
                        cidr_ipv6: cidr_ipv6,
                        description: description,
                        destination_prefix_list_id: destination_prefix_list_id,
                        destination_security_group_id: destination_security_group_id,
                        from_port: from_port,
                        ip_protocol: ip_protocol.ok_or(::serde::de::Error::missing_field("IpProtocol"))?,
                        to_port: to_port,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::SecurityGroup.Ingress`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html) property type.
    #[derive(Debug, Default)]
    pub struct Ingress {
        /// Property [`CidrIp`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-security-group-rule-cidrip).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub cidr_ip: Option<::Value<String>>,
        /// Property [`CidrIpv6`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-security-group-rule-cidripv6).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub cidr_ipv6: Option<::Value<String>>,
        /// Property [`Description`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-security-group-rule-description).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub description: Option<::Value<String>>,
        /// Property [`FromPort`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-security-group-rule-fromport).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub from_port: Option<::Value<u32>>,
        /// Property [`IpProtocol`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-security-group-rule-ipprotocol).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub ip_protocol: ::Value<String>,
        /// Property [`SourcePrefixListId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-securitygroup-ingress-sourceprefixlistid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub source_prefix_list_id: Option<::Value<String>>,
        /// Property [`SourceSecurityGroupId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-security-group-rule-sourcesecuritygroupid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub source_security_group_id: Option<::Value<String>>,
        /// Property [`SourceSecurityGroupName`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-security-group-rule-sourcesecuritygroupname).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub source_security_group_name: Option<::Value<String>>,
        /// Property [`SourceSecurityGroupOwnerId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-security-group-rule-sourcesecuritygroupownerid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub source_security_group_owner_id: Option<::Value<String>>,
        /// Property [`ToPort`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-security-group-rule-toport).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub to_port: Option<::Value<u32>>,
    }

    impl ::codec::SerializeValue for Ingress {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref cidr_ip) = self.cidr_ip {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "CidrIp", cidr_ip)?;
            }
            if let Some(ref cidr_ipv6) = self.cidr_ipv6 {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "CidrIpv6", cidr_ipv6)?;
            }
            if let Some(ref description) = self.description {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Description", description)?;
            }
            if let Some(ref from_port) = self.from_port {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "FromPort", from_port)?;
            }
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "IpProtocol", &self.ip_protocol)?;
            if let Some(ref source_prefix_list_id) = self.source_prefix_list_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SourcePrefixListId", source_prefix_list_id)?;
            }
            if let Some(ref source_security_group_id) = self.source_security_group_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SourceSecurityGroupId", source_security_group_id)?;
            }
            if let Some(ref source_security_group_name) = self.source_security_group_name {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SourceSecurityGroupName", source_security_group_name)?;
            }
            if let Some(ref source_security_group_owner_id) = self.source_security_group_owner_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SourceSecurityGroupOwnerId", source_security_group_owner_id)?;
            }
            if let Some(ref to_port) = self.to_port {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ToPort", to_port)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for Ingress {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<Ingress, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = Ingress;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type Ingress")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut cidr_ip: Option<::Value<String>> = None;
                    let mut cidr_ipv6: Option<::Value<String>> = None;
                    let mut description: Option<::Value<String>> = None;
                    let mut from_port: Option<::Value<u32>> = None;
                    let mut ip_protocol: Option<::Value<String>> = None;
                    let mut source_prefix_list_id: Option<::Value<String>> = None;
                    let mut source_security_group_id: Option<::Value<String>> = None;
                    let mut source_security_group_name: Option<::Value<String>> = None;
                    let mut source_security_group_owner_id: Option<::Value<String>> = None;
                    let mut to_port: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "CidrIp" => {
                                cidr_ip = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "CidrIpv6" => {
                                cidr_ipv6 = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Description" => {
                                description = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "FromPort" => {
                                from_port = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "IpProtocol" => {
                                ip_protocol = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SourcePrefixListId" => {
                                source_prefix_list_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SourceSecurityGroupId" => {
                                source_security_group_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SourceSecurityGroupName" => {
                                source_security_group_name = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SourceSecurityGroupOwnerId" => {
                                source_security_group_owner_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ToPort" => {
                                to_port = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(Ingress {
                        cidr_ip: cidr_ip,
                        cidr_ipv6: cidr_ipv6,
                        description: description,
                        from_port: from_port,
                        ip_protocol: ip_protocol.ok_or(::serde::de::Error::missing_field("IpProtocol"))?,
                        source_prefix_list_id: source_prefix_list_id,
                        source_security_group_id: source_security_group_id,
                        source_security_group_name: source_security_group_name,
                        source_security_group_owner_id: source_security_group_owner_id,
                        to_port: to_port,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }
}

pub mod spot_fleet {
    //! Property types for the `SpotFleet` resource.

    /// The [`AWS::EC2::SpotFleet.AcceleratorCountRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-acceleratorcountrequest.html) property type.
    #[derive(Debug, Default)]
    pub struct AcceleratorCountRequest {
        /// Property [`Max`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-acceleratorcountrequest.html#cfn-ec2-spotfleet-acceleratorcountrequest-max).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub max: Option<::Value<u32>>,
        /// Property [`Min`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-acceleratorcountrequest.html#cfn-ec2-spotfleet-acceleratorcountrequest-min).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub min: Option<::Value<u32>>,
    }

    impl ::codec::SerializeValue for AcceleratorCountRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref max) = self.max {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Max", max)?;
            }
            if let Some(ref min) = self.min {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Min", min)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for AcceleratorCountRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<AcceleratorCountRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = AcceleratorCountRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type AcceleratorCountRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut max: Option<::Value<u32>> = None;
                    let mut min: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Max" => {
                                max = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Min" => {
                                min = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(AcceleratorCountRequest {
                        max: max,
                        min: min,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::SpotFleet.AcceleratorTotalMemoryMiBRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-acceleratortotalmemorymibrequest.html) property type.
    #[derive(Debug, Default)]
    pub struct AcceleratorTotalMemoryMiBRequest {
        /// Property [`Max`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-acceleratortotalmemorymibrequest.html#cfn-ec2-spotfleet-acceleratortotalmemorymibrequest-max).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub max: Option<::Value<u32>>,
        /// Property [`Min`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-acceleratortotalmemorymibrequest.html#cfn-ec2-spotfleet-acceleratortotalmemorymibrequest-min).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub min: Option<::Value<u32>>,
    }

    impl ::codec::SerializeValue for AcceleratorTotalMemoryMiBRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref max) = self.max {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Max", max)?;
            }
            if let Some(ref min) = self.min {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Min", min)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for AcceleratorTotalMemoryMiBRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<AcceleratorTotalMemoryMiBRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = AcceleratorTotalMemoryMiBRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type AcceleratorTotalMemoryMiBRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut max: Option<::Value<u32>> = None;
                    let mut min: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Max" => {
                                max = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Min" => {
                                min = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(AcceleratorTotalMemoryMiBRequest {
                        max: max,
                        min: min,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::SpotFleet.BaselineEbsBandwidthMbpsRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-baselineebsbandwidthmbpsrequest.html) property type.
    #[derive(Debug, Default)]
    pub struct BaselineEbsBandwidthMbpsRequest {
        /// Property [`Max`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-baselineebsbandwidthmbpsrequest.html#cfn-ec2-spotfleet-baselineebsbandwidthmbpsrequest-max).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub max: Option<::Value<u32>>,
        /// Property [`Min`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-baselineebsbandwidthmbpsrequest.html#cfn-ec2-spotfleet-baselineebsbandwidthmbpsrequest-min).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub min: Option<::Value<u32>>,
    }

    impl ::codec::SerializeValue for BaselineEbsBandwidthMbpsRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref max) = self.max {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Max", max)?;
            }
            if let Some(ref min) = self.min {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Min", min)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for BaselineEbsBandwidthMbpsRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<BaselineEbsBandwidthMbpsRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = BaselineEbsBandwidthMbpsRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type BaselineEbsBandwidthMbpsRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut max: Option<::Value<u32>> = None;
                    let mut min: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Max" => {
                                max = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Min" => {
                                min = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(BaselineEbsBandwidthMbpsRequest {
                        max: max,
                        min: min,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::SpotFleet.BlockDeviceMapping`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-blockdevicemapping.html) property type.
    #[derive(Debug, Default)]
    pub struct BlockDeviceMapping {
        /// Property [`DeviceName`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-blockdevicemapping.html#cfn-ec2-spotfleet-blockdevicemapping-devicename).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub device_name: ::Value<String>,
        /// Property [`Ebs`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-blockdevicemapping.html#cfn-ec2-spotfleet-blockdevicemapping-ebs).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub ebs: Option<::Value<EbsBlockDevice>>,
        /// Property [`NoDevice`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-blockdevicemapping.html#cfn-ec2-spotfleet-blockdevicemapping-nodevice).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub no_device: Option<::Value<String>>,
        /// Property [`VirtualName`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-blockdevicemapping.html#cfn-ec2-spotfleet-blockdevicemapping-virtualname).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub virtual_name: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for BlockDeviceMapping {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "DeviceName", &self.device_name)?;
            if let Some(ref ebs) = self.ebs {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ebs", ebs)?;
            }
            if let Some(ref no_device) = self.no_device {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "NoDevice", no_device)?;
            }
            if let Some(ref virtual_name) = self.virtual_name {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "VirtualName", virtual_name)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for BlockDeviceMapping {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<BlockDeviceMapping, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = BlockDeviceMapping;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type BlockDeviceMapping")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut device_name: Option<::Value<String>> = None;
                    let mut ebs: Option<::Value<EbsBlockDevice>> = None;
                    let mut no_device: Option<::Value<String>> = None;
                    let mut virtual_name: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "DeviceName" => {
                                device_name = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Ebs" => {
                                ebs = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "NoDevice" => {
                                no_device = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "VirtualName" => {
                                virtual_name = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(BlockDeviceMapping {
                        device_name: device_name.ok_or(::serde::de::Error::missing_field("DeviceName"))?,
                        ebs: ebs,
                        no_device: no_device,
                        virtual_name: virtual_name,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::SpotFleet.ClassicLoadBalancer`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-classicloadbalancer.html) property type.
    #[derive(Debug, Default)]
    pub struct ClassicLoadBalancer {
        /// Property [`Name`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-classicloadbalancer.html#cfn-ec2-spotfleet-classicloadbalancer-name).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub name: ::Value<String>,
    }

    impl ::codec::SerializeValue for ClassicLoadBalancer {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Name", &self.name)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for ClassicLoadBalancer {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<ClassicLoadBalancer, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = ClassicLoadBalancer;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type ClassicLoadBalancer")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut name: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Name" => {
                                name = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(ClassicLoadBalancer {
                        name: name.ok_or(::serde::de::Error::missing_field("Name"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::SpotFleet.ClassicLoadBalancersConfig`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-classicloadbalancersconfig.html) property type.
    #[derive(Debug, Default)]
    pub struct ClassicLoadBalancersConfig {
        /// Property [`ClassicLoadBalancers`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-classicloadbalancersconfig.html#cfn-ec2-spotfleet-classicloadbalancersconfig-classicloadbalancers).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub classic_load_balancers: ::ValueList<ClassicLoadBalancer>,
    }

    impl ::codec::SerializeValue for ClassicLoadBalancersConfig {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "ClassicLoadBalancers", &self.classic_load_balancers)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for ClassicLoadBalancersConfig {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<ClassicLoadBalancersConfig, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = ClassicLoadBalancersConfig;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type ClassicLoadBalancersConfig")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut classic_load_balancers: Option<::ValueList<ClassicLoadBalancer>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "ClassicLoadBalancers" => {
                                classic_load_balancers = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(ClassicLoadBalancersConfig {
                        classic_load_balancers: classic_load_balancers.ok_or(::serde::de::Error::missing_field("ClassicLoadBalancers"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::SpotFleet.EbsBlockDevice`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html) property type.
    #[derive(Debug, Default)]
    pub struct EbsBlockDevice {
        /// Property [`DeleteOnTermination`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html#cfn-ec2-spotfleet-ebsblockdevice-deleteontermination).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub delete_on_termination: Option<::Value<bool>>,
        /// Property [`Encrypted`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html#cfn-ec2-spotfleet-ebsblockdevice-encrypted).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub encrypted: Option<::Value<bool>>,
        /// Property [`Iops`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html#cfn-ec2-spotfleet-ebsblockdevice-iops).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub iops: Option<::Value<u32>>,
        /// Property [`SnapshotId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html#cfn-ec2-spotfleet-ebsblockdevice-snapshotid).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub snapshot_id: Option<::Value<String>>,
        /// Property [`VolumeSize`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html#cfn-ec2-spotfleet-ebsblockdevice-volumesize).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub volume_size: Option<::Value<u32>>,
        /// Property [`VolumeType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html#cfn-ec2-spotfleet-ebsblockdevice-volumetype).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub volume_type: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for EbsBlockDevice {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref delete_on_termination) = self.delete_on_termination {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "DeleteOnTermination", delete_on_termination)?;
            }
            if let Some(ref encrypted) = self.encrypted {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Encrypted", encrypted)?;
            }
            if let Some(ref iops) = self.iops {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Iops", iops)?;
            }
            if let Some(ref snapshot_id) = self.snapshot_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SnapshotId", snapshot_id)?;
            }
            if let Some(ref volume_size) = self.volume_size {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "VolumeSize", volume_size)?;
            }
            if let Some(ref volume_type) = self.volume_type {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "VolumeType", volume_type)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for EbsBlockDevice {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<EbsBlockDevice, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = EbsBlockDevice;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type EbsBlockDevice")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut delete_on_termination: Option<::Value<bool>> = None;
                    let mut encrypted: Option<::Value<bool>> = None;
                    let mut iops: Option<::Value<u32>> = None;
                    let mut snapshot_id: Option<::Value<String>> = None;
                    let mut volume_size: Option<::Value<u32>> = None;
                    let mut volume_type: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "DeleteOnTermination" => {
                                delete_on_termination = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Encrypted" => {
                                encrypted = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Iops" => {
                                iops = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SnapshotId" => {
                                snapshot_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "VolumeSize" => {
                                volume_size = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "VolumeType" => {
                                volume_type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(EbsBlockDevice {
                        delete_on_termination: delete_on_termination,
                        encrypted: encrypted,
                        iops: iops,
                        snapshot_id: snapshot_id,
                        volume_size: volume_size,
                        volume_type: volume_type,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::SpotFleet.FleetLaunchTemplateSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-fleetlaunchtemplatespecification.html) property type.
    #[derive(Debug, Default)]
    pub struct FleetLaunchTemplateSpecification {
        /// Property [`LaunchTemplateId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-fleetlaunchtemplatespecification.html#cfn-ec2-spotfleet-fleetlaunchtemplatespecification-launchtemplateid).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub launch_template_id: Option<::Value<String>>,
        /// Property [`LaunchTemplateName`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-fleetlaunchtemplatespecification.html#cfn-ec2-spotfleet-fleetlaunchtemplatespecification-launchtemplatename).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub launch_template_name: Option<::Value<String>>,
        /// Property [`Version`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-fleetlaunchtemplatespecification.html#cfn-ec2-spotfleet-fleetlaunchtemplatespecification-version).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub version: ::Value<String>,
    }

    impl ::codec::SerializeValue for FleetLaunchTemplateSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref launch_template_id) = self.launch_template_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "LaunchTemplateId", launch_template_id)?;
            }
            if let Some(ref launch_template_name) = self.launch_template_name {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "LaunchTemplateName", launch_template_name)?;
            }
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Version", &self.version)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for FleetLaunchTemplateSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<FleetLaunchTemplateSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = FleetLaunchTemplateSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type FleetLaunchTemplateSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut launch_template_id: Option<::Value<String>> = None;
                    let mut launch_template_name: Option<::Value<String>> = None;
                    let mut version: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "LaunchTemplateId" => {
                                launch_template_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "LaunchTemplateName" => {
                                launch_template_name = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Version" => {
                                version = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(FleetLaunchTemplateSpecification {
                        launch_template_id: launch_template_id,
                        launch_template_name: launch_template_name,
                        version: version.ok_or(::serde::de::Error::missing_field("Version"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::SpotFleet.GroupIdentifier`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-groupidentifier.html) property type.
    #[derive(Debug, Default)]
    pub struct GroupIdentifier {
        /// Property [`GroupId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-groupidentifier.html#cfn-ec2-spotfleet-groupidentifier-groupid).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub group_id: ::Value<String>,
    }

    impl ::codec::SerializeValue for GroupIdentifier {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "GroupId", &self.group_id)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for GroupIdentifier {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<GroupIdentifier, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = GroupIdentifier;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type GroupIdentifier")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut group_id: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "GroupId" => {
                                group_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(GroupIdentifier {
                        group_id: group_id.ok_or(::serde::de::Error::missing_field("GroupId"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::SpotFleet.IamInstanceProfileSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-iaminstanceprofilespecification.html) property type.
    #[derive(Debug, Default)]
    pub struct IamInstanceProfileSpecification {
        /// Property [`Arn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-iaminstanceprofilespecification.html#cfn-ec2-spotfleet-iaminstanceprofilespecification-arn).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub arn: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for IamInstanceProfileSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref arn) = self.arn {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Arn", arn)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for IamInstanceProfileSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<IamInstanceProfileSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = IamInstanceProfileSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type IamInstanceProfileSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut arn: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Arn" => {
                                arn = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(IamInstanceProfileSpecification {
                        arn: arn,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::SpotFleet.InstanceIpv6Address`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instanceipv6address.html) property type.
    #[derive(Debug, Default)]
    pub struct InstanceIpv6Address {
        /// Property [`Ipv6Address`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instanceipv6address.html#cfn-ec2-spotfleet-instanceipv6address-ipv6address).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub ipv6_address: ::Value<String>,
    }

    impl ::codec::SerializeValue for InstanceIpv6Address {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6Address", &self.ipv6_address)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for InstanceIpv6Address {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<InstanceIpv6Address, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = InstanceIpv6Address;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type InstanceIpv6Address")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut ipv6_address: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Ipv6Address" => {
                                ipv6_address = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(InstanceIpv6Address {
                        ipv6_address: ipv6_address.ok_or(::serde::de::Error::missing_field("Ipv6Address"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::SpotFleet.InstanceNetworkInterfaceSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html) property type.
    #[derive(Debug, Default)]
    pub struct InstanceNetworkInterfaceSpecification {
        /// Property [`AssociatePublicIpAddress`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-associatepublicipaddress).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub associate_public_ip_address: Option<::Value<bool>>,
        /// Property [`DeleteOnTermination`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-deleteontermination).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub delete_on_termination: Option<::Value<bool>>,
        /// Property [`Description`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-description).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub description: Option<::Value<String>>,
        /// Property [`DeviceIndex`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-deviceindex).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub device_index: Option<::Value<u32>>,
        /// Property [`Groups`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-groups).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub groups: Option<::ValueList<String>>,
        /// Property [`Ipv6AddressCount`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-ipv6addresscount).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub ipv6_address_count: Option<::Value<u32>>,
        /// Property [`Ipv6Addresses`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-ipv6addresses).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub ipv6_addresses: Option<::ValueList<InstanceIpv6Address>>,
        /// Property [`NetworkInterfaceId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-networkinterfaceid).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub network_interface_id: Option<::Value<String>>,
        /// Property [`PrivateIpAddresses`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-privateipaddresses).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub private_ip_addresses: Option<::ValueList<PrivateIpAddressSpecification>>,
        /// Property [`SecondaryPrivateIpAddressCount`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-secondaryprivateipaddresscount).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub secondary_private_ip_address_count: Option<::Value<u32>>,
        /// Property [`SubnetId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-subnetid).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub subnet_id: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for InstanceNetworkInterfaceSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref associate_public_ip_address) = self.associate_public_ip_address {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AssociatePublicIpAddress", associate_public_ip_address)?;
            }
            if let Some(ref delete_on_termination) = self.delete_on_termination {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "DeleteOnTermination", delete_on_termination)?;
            }
            if let Some(ref description) = self.description {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Description", description)?;
            }
            if let Some(ref device_index) = self.device_index {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "DeviceIndex", device_index)?;
            }
            if let Some(ref groups) = self.groups {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Groups", groups)?;
            }
            if let Some(ref ipv6_address_count) = self.ipv6_address_count {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6AddressCount", ipv6_address_count)?;
            }
            if let Some(ref ipv6_addresses) = self.ipv6_addresses {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6Addresses", ipv6_addresses)?;
            }
            if let Some(ref network_interface_id) = self.network_interface_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetworkInterfaceId", network_interface_id)?;
            }
            if let Some(ref private_ip_addresses) = self.private_ip_addresses {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "PrivateIpAddresses", private_ip_addresses)?;
            }
            if let Some(ref secondary_private_ip_address_count) = self.secondary_private_ip_address_count {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SecondaryPrivateIpAddressCount", secondary_private_ip_address_count)?;
            }
            if let Some(ref subnet_id) = self.subnet_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SubnetId", subnet_id)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for InstanceNetworkInterfaceSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<InstanceNetworkInterfaceSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = InstanceNetworkInterfaceSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type InstanceNetworkInterfaceSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut associate_public_ip_address: Option<::Value<bool>> = None;
                    let mut delete_on_termination: Option<::Value<bool>> = None;
                    let mut description: Option<::Value<String>> = None;
                    let mut device_index: Option<::Value<u32>> = None;
                    let mut groups: Option<::ValueList<String>> = None;
                    let mut ipv6_address_count: Option<::Value<u32>> = None;
                    let mut ipv6_addresses: Option<::ValueList<InstanceIpv6Address>> = None;
                    let mut network_interface_id: Option<::Value<String>> = None;
                    let mut private_ip_addresses: Option<::ValueList<PrivateIpAddressSpecification>> = None;
                    let mut secondary_private_ip_address_count: Option<::Value<u32>> = None;
                    let mut subnet_id: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "AssociatePublicIpAddress" => {
                                associate_public_ip_address = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "DeleteOnTermination" => {
                                delete_on_termination = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Description" => {
                                description = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "DeviceIndex" => {
                                device_index = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Groups" => {
                                groups = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Ipv6AddressCount" => {
                                ipv6_address_count = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Ipv6Addresses" => {
                                ipv6_addresses = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "NetworkInterfaceId" => {
                                network_interface_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "PrivateIpAddresses" => {
                                private_ip_addresses = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SecondaryPrivateIpAddressCount" => {
                                secondary_private_ip_address_count = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SubnetId" => {
                                subnet_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(InstanceNetworkInterfaceSpecification {
                        associate_public_ip_address: associate_public_ip_address,
                        delete_on_termination: delete_on_termination,
                        description: description,
                        device_index: device_index,
                        groups: groups,
                        ipv6_address_count: ipv6_address_count,
                        ipv6_addresses: ipv6_addresses,
                        network_interface_id: network_interface_id,
                        private_ip_addresses: private_ip_addresses,
                        secondary_private_ip_address_count: secondary_private_ip_address_count,
                        subnet_id: subnet_id,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::SpotFleet.InstanceRequirementsRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html) property type.
    #[derive(Debug, Default)]
    pub struct InstanceRequirementsRequest {
        /// Property [`AcceleratorCount`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-acceleratorcount).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub accelerator_count: Option<::Value<AcceleratorCountRequest>>,
        /// Property [`AcceleratorManufacturers`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-acceleratormanufacturers).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub accelerator_manufacturers: Option<::ValueList<String>>,
        /// Property [`AcceleratorNames`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-acceleratornames).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub accelerator_names: Option<::ValueList<String>>,
        /// Property [`AcceleratorTotalMemoryMiB`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-acceleratortotalmemorymib).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub accelerator_total_memory_mi_b: Option<::Value<AcceleratorTotalMemoryMiBRequest>>,
        /// Property [`AcceleratorTypes`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-acceleratortypes).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub accelerator_types: Option<::ValueList<String>>,
        /// Property [`AllowedInstanceTypes`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-allowedinstancetypes).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub allowed_instance_types: Option<::ValueList<String>>,
        /// Property [`BareMetal`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-baremetal).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub bare_metal: Option<::Value<String>>,
        /// Property [`BaselineEbsBandwidthMbps`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-baselineebsbandwidthmbps).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub baseline_ebs_bandwidth_mbps: Option<::Value<BaselineEbsBandwidthMbpsRequest>>,
        /// Property [`BurstablePerformance`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-burstableperformance).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub burstable_performance: Option<::Value<String>>,
        /// Property [`CpuManufacturers`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-cpumanufacturers).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub cpu_manufacturers: Option<::ValueList<String>>,
        /// Property [`ExcludedInstanceTypes`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-excludedinstancetypes).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub excluded_instance_types: Option<::ValueList<String>>,
        /// Property [`InstanceGenerations`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-instancegenerations).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub instance_generations: Option<::ValueList<String>>,
        /// Property [`LocalStorage`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-localstorage).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub local_storage: Option<::Value<String>>,
        /// Property [`LocalStorageTypes`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-localstoragetypes).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub local_storage_types: Option<::ValueList<String>>,
        /// Property [`MemoryGiBPerVCpu`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-memorygibpervcpu).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub memory_gi_b_per_v_cpu: Option<::Value<MemoryGiBPerVCpuRequest>>,
        /// Property [`MemoryMiB`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-memorymib).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub memory_mi_b: Option<::Value<MemoryMiBRequest>>,
        /// Property [`NetworkBandwidthGbps`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-networkbandwidthgbps).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub network_bandwidth_gbps: Option<::Value<NetworkBandwidthGbpsRequest>>,
        /// Property [`NetworkInterfaceCount`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-networkinterfacecount).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub network_interface_count: Option<::Value<NetworkInterfaceCountRequest>>,
        /// Property [`OnDemandMaxPricePercentageOverLowestPrice`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-ondemandmaxpricepercentageoverlowestprice).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub on_demand_max_price_percentage_over_lowest_price: Option<::Value<u32>>,
        /// Property [`RequireHibernateSupport`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-requirehibernatesupport).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub require_hibernate_support: Option<::Value<bool>>,
        /// Property [`SpotMaxPricePercentageOverLowestPrice`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-spotmaxpricepercentageoverlowestprice).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub spot_max_price_percentage_over_lowest_price: Option<::Value<u32>>,
        /// Property [`TotalLocalStorageGB`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-totallocalstoragegb).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub total_local_storage_gb: Option<::Value<TotalLocalStorageGBRequest>>,
        /// Property [`VCpuCount`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-vcpucount).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub v_cpu_count: Option<::Value<VCpuCountRangeRequest>>,
    }

    impl ::codec::SerializeValue for InstanceRequirementsRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref accelerator_count) = self.accelerator_count {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AcceleratorCount", accelerator_count)?;
            }
            if let Some(ref accelerator_manufacturers) = self.accelerator_manufacturers {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AcceleratorManufacturers", accelerator_manufacturers)?;
            }
            if let Some(ref accelerator_names) = self.accelerator_names {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AcceleratorNames", accelerator_names)?;
            }
            if let Some(ref accelerator_total_memory_mi_b) = self.accelerator_total_memory_mi_b {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AcceleratorTotalMemoryMiB", accelerator_total_memory_mi_b)?;
            }
            if let Some(ref accelerator_types) = self.accelerator_types {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AcceleratorTypes", accelerator_types)?;
            }
            if let Some(ref allowed_instance_types) = self.allowed_instance_types {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AllowedInstanceTypes", allowed_instance_types)?;
            }
            if let Some(ref bare_metal) = self.bare_metal {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "BareMetal", bare_metal)?;
            }
            if let Some(ref baseline_ebs_bandwidth_mbps) = self.baseline_ebs_bandwidth_mbps {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "BaselineEbsBandwidthMbps", baseline_ebs_bandwidth_mbps)?;
            }
            if let Some(ref burstable_performance) = self.burstable_performance {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "BurstablePerformance", burstable_performance)?;
            }
            if let Some(ref cpu_manufacturers) = self.cpu_manufacturers {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "CpuManufacturers", cpu_manufacturers)?;
            }
            if let Some(ref excluded_instance_types) = self.excluded_instance_types {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ExcludedInstanceTypes", excluded_instance_types)?;
            }
            if let Some(ref instance_generations) = self.instance_generations {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstanceGenerations", instance_generations)?;
            }
            if let Some(ref local_storage) = self.local_storage {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "LocalStorage", local_storage)?;
            }
            if let Some(ref local_storage_types) = self.local_storage_types {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "LocalStorageTypes", local_storage_types)?;
            }
            if let Some(ref memory_gi_b_per_v_cpu) = self.memory_gi_b_per_v_cpu {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "MemoryGiBPerVCpu", memory_gi_b_per_v_cpu)?;
            }
            if let Some(ref memory_mi_b) = self.memory_mi_b {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "MemoryMiB", memory_mi_b)?;
            }
            if let Some(ref network_bandwidth_gbps) = self.network_bandwidth_gbps {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetworkBandwidthGbps", network_bandwidth_gbps)?;
            }
            if let Some(ref network_interface_count) = self.network_interface_count {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetworkInterfaceCount", network_interface_count)?;
            }
            if let Some(ref on_demand_max_price_percentage_over_lowest_price) = self.on_demand_max_price_percentage_over_lowest_price {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "OnDemandMaxPricePercentageOverLowestPrice", on_demand_max_price_percentage_over_lowest_price)?;
            }
            if let Some(ref require_hibernate_support) = self.require_hibernate_support {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "RequireHibernateSupport", require_hibernate_support)?;
            }
            if let Some(ref spot_max_price_percentage_over_lowest_price) = self.spot_max_price_percentage_over_lowest_price {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SpotMaxPricePercentageOverLowestPrice", spot_max_price_percentage_over_lowest_price)?;
            }
            if let Some(ref total_local_storage_gb) = self.total_local_storage_gb {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "TotalLocalStorageGB", total_local_storage_gb)?;
            }
            if let Some(ref v_cpu_count) = self.v_cpu_count {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "VCpuCount", v_cpu_count)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for InstanceRequirementsRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<InstanceRequirementsRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = InstanceRequirementsRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type InstanceRequirementsRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut accelerator_count: Option<::Value<AcceleratorCountRequest>> = None;
                    let mut accelerator_manufacturers: Option<::ValueList<String>> = None;
                    let mut accelerator_names: Option<::ValueList<String>> = None;
                    let mut accelerator_total_memory_mi_b: Option<::Value<AcceleratorTotalMemoryMiBRequest>> = None;
                    let mut accelerator_types: Option<::ValueList<String>> = None;
                    let mut allowed_instance_types: Option<::ValueList<String>> = None;
                    let mut bare_metal: Option<::Value<String>> = None;
                    let mut baseline_ebs_bandwidth_mbps: Option<::Value<BaselineEbsBandwidthMbpsRequest>> = None;
                    let mut burstable_performance: Option<::Value<String>> = None;
                    let mut cpu_manufacturers: Option<::ValueList<String>> = None;
                    let mut excluded_instance_types: Option<::ValueList<String>> = None;
                    let mut instance_generations: Option<::ValueList<String>> = None;
                    let mut local_storage: Option<::Value<String>> = None;
                    let mut local_storage_types: Option<::ValueList<String>> = None;
                    let mut memory_gi_b_per_v_cpu: Option<::Value<MemoryGiBPerVCpuRequest>> = None;
                    let mut memory_mi_b: Option<::Value<MemoryMiBRequest>> = None;
                    let mut network_bandwidth_gbps: Option<::Value<NetworkBandwidthGbpsRequest>> = None;
                    let mut network_interface_count: Option<::Value<NetworkInterfaceCountRequest>> = None;
                    let mut on_demand_max_price_percentage_over_lowest_price: Option<::Value<u32>> = None;
                    let mut require_hibernate_support: Option<::Value<bool>> = None;
                    let mut spot_max_price_percentage_over_lowest_price: Option<::Value<u32>> = None;
                    let mut total_local_storage_gb: Option<::Value<TotalLocalStorageGBRequest>> = None;
                    let mut v_cpu_count: Option<::Value<VCpuCountRangeRequest>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "AcceleratorCount" => {
                                accelerator_count = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "AcceleratorManufacturers" => {
                                accelerator_manufacturers = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "AcceleratorNames" => {
                                accelerator_names = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "AcceleratorTotalMemoryMiB" => {
                                accelerator_total_memory_mi_b = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "AcceleratorTypes" => {
                                accelerator_types = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "AllowedInstanceTypes" => {
                                allowed_instance_types = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "BareMetal" => {
                                bare_metal = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "BaselineEbsBandwidthMbps" => {
                                baseline_ebs_bandwidth_mbps = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "BurstablePerformance" => {
                                burstable_performance = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "CpuManufacturers" => {
                                cpu_manufacturers = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ExcludedInstanceTypes" => {
                                excluded_instance_types = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "InstanceGenerations" => {
                                instance_generations = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "LocalStorage" => {
                                local_storage = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "LocalStorageTypes" => {
                                local_storage_types = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "MemoryGiBPerVCpu" => {
                                memory_gi_b_per_v_cpu = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "MemoryMiB" => {
                                memory_mi_b = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "NetworkBandwidthGbps" => {
                                network_bandwidth_gbps = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "NetworkInterfaceCount" => {
                                network_interface_count = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "OnDemandMaxPricePercentageOverLowestPrice" => {
                                on_demand_max_price_percentage_over_lowest_price = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "RequireHibernateSupport" => {
                                require_hibernate_support = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SpotMaxPricePercentageOverLowestPrice" => {
                                spot_max_price_percentage_over_lowest_price = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "TotalLocalStorageGB" => {
                                total_local_storage_gb = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "VCpuCount" => {
                                v_cpu_count = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(InstanceRequirementsRequest {
                        accelerator_count: accelerator_count,
                        accelerator_manufacturers: accelerator_manufacturers,
                        accelerator_names: accelerator_names,
                        accelerator_total_memory_mi_b: accelerator_total_memory_mi_b,
                        accelerator_types: accelerator_types,
                        allowed_instance_types: allowed_instance_types,
                        bare_metal: bare_metal,
                        baseline_ebs_bandwidth_mbps: baseline_ebs_bandwidth_mbps,
                        burstable_performance: burstable_performance,
                        cpu_manufacturers: cpu_manufacturers,
                        excluded_instance_types: excluded_instance_types,
                        instance_generations: instance_generations,
                        local_storage: local_storage,
                        local_storage_types: local_storage_types,
                        memory_gi_b_per_v_cpu: memory_gi_b_per_v_cpu,
                        memory_mi_b: memory_mi_b,
                        network_bandwidth_gbps: network_bandwidth_gbps,
                        network_interface_count: network_interface_count,
                        on_demand_max_price_percentage_over_lowest_price: on_demand_max_price_percentage_over_lowest_price,
                        require_hibernate_support: require_hibernate_support,
                        spot_max_price_percentage_over_lowest_price: spot_max_price_percentage_over_lowest_price,
                        total_local_storage_gb: total_local_storage_gb,
                        v_cpu_count: v_cpu_count,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::SpotFleet.LaunchTemplateConfig`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateconfig.html) property type.
    #[derive(Debug, Default)]
    pub struct LaunchTemplateConfig {
        /// Property [`LaunchTemplateSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateconfig.html#cfn-ec2-spotfleet-launchtemplateconfig-launchtemplatespecification).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub launch_template_specification: Option<::Value<FleetLaunchTemplateSpecification>>,
        /// Property [`Overrides`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateconfig.html#cfn-ec2-spotfleet-launchtemplateconfig-overrides).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub overrides: Option<::ValueList<LaunchTemplateOverrides>>,
    }

    impl ::codec::SerializeValue for LaunchTemplateConfig {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref launch_template_specification) = self.launch_template_specification {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "LaunchTemplateSpecification", launch_template_specification)?;
            }
            if let Some(ref overrides) = self.overrides {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Overrides", overrides)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for LaunchTemplateConfig {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<LaunchTemplateConfig, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = LaunchTemplateConfig;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type LaunchTemplateConfig")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut launch_template_specification: Option<::Value<FleetLaunchTemplateSpecification>> = None;
                    let mut overrides: Option<::ValueList<LaunchTemplateOverrides>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "LaunchTemplateSpecification" => {
                                launch_template_specification = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Overrides" => {
                                overrides = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(LaunchTemplateConfig {
                        launch_template_specification: launch_template_specification,
                        overrides: overrides,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::SpotFleet.LaunchTemplateOverrides`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html) property type.
    #[derive(Debug, Default)]
    pub struct LaunchTemplateOverrides {
        /// Property [`AvailabilityZone`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-availabilityzone).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub availability_zone: Option<::Value<String>>,
        /// Property [`InstanceRequirements`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-instancerequirements).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub instance_requirements: Option<::Value<InstanceRequirementsRequest>>,
        /// Property [`InstanceType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-instancetype).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub instance_type: Option<::Value<String>>,
        /// Property [`Priority`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-priority).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub priority: Option<::Value<f64>>,
        /// Property [`SpotPrice`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-spotprice).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub spot_price: Option<::Value<String>>,
        /// Property [`SubnetId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-subnetid).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub subnet_id: Option<::Value<String>>,
        /// Property [`WeightedCapacity`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-weightedcapacity).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub weighted_capacity: Option<::Value<f64>>,
    }

    impl ::codec::SerializeValue for LaunchTemplateOverrides {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref availability_zone) = self.availability_zone {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AvailabilityZone", availability_zone)?;
            }
            if let Some(ref instance_requirements) = self.instance_requirements {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstanceRequirements", instance_requirements)?;
            }
            if let Some(ref instance_type) = self.instance_type {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstanceType", instance_type)?;
            }
            if let Some(ref priority) = self.priority {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Priority", priority)?;
            }
            if let Some(ref spot_price) = self.spot_price {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SpotPrice", spot_price)?;
            }
            if let Some(ref subnet_id) = self.subnet_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SubnetId", subnet_id)?;
            }
            if let Some(ref weighted_capacity) = self.weighted_capacity {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "WeightedCapacity", weighted_capacity)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for LaunchTemplateOverrides {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<LaunchTemplateOverrides, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = LaunchTemplateOverrides;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type LaunchTemplateOverrides")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut availability_zone: Option<::Value<String>> = None;
                    let mut instance_requirements: Option<::Value<InstanceRequirementsRequest>> = None;
                    let mut instance_type: Option<::Value<String>> = None;
                    let mut priority: Option<::Value<f64>> = None;
                    let mut spot_price: Option<::Value<String>> = None;
                    let mut subnet_id: Option<::Value<String>> = None;
                    let mut weighted_capacity: Option<::Value<f64>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "AvailabilityZone" => {
                                availability_zone = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "InstanceRequirements" => {
                                instance_requirements = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "InstanceType" => {
                                instance_type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Priority" => {
                                priority = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SpotPrice" => {
                                spot_price = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SubnetId" => {
                                subnet_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "WeightedCapacity" => {
                                weighted_capacity = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(LaunchTemplateOverrides {
                        availability_zone: availability_zone,
                        instance_requirements: instance_requirements,
                        instance_type: instance_type,
                        priority: priority,
                        spot_price: spot_price,
                        subnet_id: subnet_id,
                        weighted_capacity: weighted_capacity,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::SpotFleet.LoadBalancersConfig`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-loadbalancersconfig.html) property type.
    #[derive(Debug, Default)]
    pub struct LoadBalancersConfig {
        /// Property [`ClassicLoadBalancersConfig`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-loadbalancersconfig.html#cfn-ec2-spotfleet-loadbalancersconfig-classicloadbalancersconfig).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub classic_load_balancers_config: Option<::Value<ClassicLoadBalancersConfig>>,
        /// Property [`TargetGroupsConfig`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-loadbalancersconfig.html#cfn-ec2-spotfleet-loadbalancersconfig-targetgroupsconfig).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub target_groups_config: Option<::Value<TargetGroupsConfig>>,
    }

    impl ::codec::SerializeValue for LoadBalancersConfig {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref classic_load_balancers_config) = self.classic_load_balancers_config {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ClassicLoadBalancersConfig", classic_load_balancers_config)?;
            }
            if let Some(ref target_groups_config) = self.target_groups_config {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "TargetGroupsConfig", target_groups_config)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for LoadBalancersConfig {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<LoadBalancersConfig, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = LoadBalancersConfig;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type LoadBalancersConfig")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut classic_load_balancers_config: Option<::Value<ClassicLoadBalancersConfig>> = None;
                    let mut target_groups_config: Option<::Value<TargetGroupsConfig>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "ClassicLoadBalancersConfig" => {
                                classic_load_balancers_config = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "TargetGroupsConfig" => {
                                target_groups_config = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(LoadBalancersConfig {
                        classic_load_balancers_config: classic_load_balancers_config,
                        target_groups_config: target_groups_config,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::SpotFleet.MemoryGiBPerVCpuRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-memorygibpervcpurequest.html) property type.
    #[derive(Debug, Default)]
    pub struct MemoryGiBPerVCpuRequest {
        /// Property [`Max`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-memorygibpervcpurequest.html#cfn-ec2-spotfleet-memorygibpervcpurequest-max).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub max: Option<::Value<f64>>,
        /// Property [`Min`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-memorygibpervcpurequest.html#cfn-ec2-spotfleet-memorygibpervcpurequest-min).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub min: Option<::Value<f64>>,
    }

    impl ::codec::SerializeValue for MemoryGiBPerVCpuRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref max) = self.max {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Max", max)?;
            }
            if let Some(ref min) = self.min {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Min", min)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for MemoryGiBPerVCpuRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<MemoryGiBPerVCpuRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = MemoryGiBPerVCpuRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type MemoryGiBPerVCpuRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut max: Option<::Value<f64>> = None;
                    let mut min: Option<::Value<f64>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Max" => {
                                max = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Min" => {
                                min = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(MemoryGiBPerVCpuRequest {
                        max: max,
                        min: min,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::SpotFleet.MemoryMiBRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-memorymibrequest.html) property type.
    #[derive(Debug, Default)]
    pub struct MemoryMiBRequest {
        /// Property [`Max`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-memorymibrequest.html#cfn-ec2-spotfleet-memorymibrequest-max).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub max: Option<::Value<u32>>,
        /// Property [`Min`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-memorymibrequest.html#cfn-ec2-spotfleet-memorymibrequest-min).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub min: Option<::Value<u32>>,
    }

    impl ::codec::SerializeValue for MemoryMiBRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref max) = self.max {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Max", max)?;
            }
            if let Some(ref min) = self.min {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Min", min)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for MemoryMiBRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<MemoryMiBRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = MemoryMiBRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type MemoryMiBRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut max: Option<::Value<u32>> = None;
                    let mut min: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Max" => {
                                max = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Min" => {
                                min = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(MemoryMiBRequest {
                        max: max,
                        min: min,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::SpotFleet.NetworkBandwidthGbpsRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-networkbandwidthgbpsrequest.html) property type.
    #[derive(Debug, Default)]
    pub struct NetworkBandwidthGbpsRequest {
        /// Property [`Max`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-networkbandwidthgbpsrequest.html#cfn-ec2-spotfleet-networkbandwidthgbpsrequest-max).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub max: Option<::Value<f64>>,
        /// Property [`Min`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-networkbandwidthgbpsrequest.html#cfn-ec2-spotfleet-networkbandwidthgbpsrequest-min).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub min: Option<::Value<f64>>,
    }

    impl ::codec::SerializeValue for NetworkBandwidthGbpsRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref max) = self.max {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Max", max)?;
            }
            if let Some(ref min) = self.min {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Min", min)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for NetworkBandwidthGbpsRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<NetworkBandwidthGbpsRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = NetworkBandwidthGbpsRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type NetworkBandwidthGbpsRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut max: Option<::Value<f64>> = None;
                    let mut min: Option<::Value<f64>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Max" => {
                                max = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Min" => {
                                min = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(NetworkBandwidthGbpsRequest {
                        max: max,
                        min: min,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::SpotFleet.NetworkInterfaceCountRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-networkinterfacecountrequest.html) property type.
    #[derive(Debug, Default)]
    pub struct NetworkInterfaceCountRequest {
        /// Property [`Max`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-networkinterfacecountrequest.html#cfn-ec2-spotfleet-networkinterfacecountrequest-max).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub max: Option<::Value<u32>>,
        /// Property [`Min`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-networkinterfacecountrequest.html#cfn-ec2-spotfleet-networkinterfacecountrequest-min).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub min: Option<::Value<u32>>,
    }

    impl ::codec::SerializeValue for NetworkInterfaceCountRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref max) = self.max {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Max", max)?;
            }
            if let Some(ref min) = self.min {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Min", min)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for NetworkInterfaceCountRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<NetworkInterfaceCountRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = NetworkInterfaceCountRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type NetworkInterfaceCountRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut max: Option<::Value<u32>> = None;
                    let mut min: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Max" => {
                                max = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Min" => {
                                min = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(NetworkInterfaceCountRequest {
                        max: max,
                        min: min,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::SpotFleet.PrivateIpAddressSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-privateipaddressspecification.html) property type.
    #[derive(Debug, Default)]
    pub struct PrivateIpAddressSpecification {
        /// Property [`Primary`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-privateipaddressspecification.html#cfn-ec2-spotfleet-privateipaddressspecification-primary).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub primary: Option<::Value<bool>>,
        /// Property [`PrivateIpAddress`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-privateipaddressspecification.html#cfn-ec2-spotfleet-privateipaddressspecification-privateipaddress).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub private_ip_address: ::Value<String>,
    }

    impl ::codec::SerializeValue for PrivateIpAddressSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref primary) = self.primary {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Primary", primary)?;
            }
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "PrivateIpAddress", &self.private_ip_address)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for PrivateIpAddressSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<PrivateIpAddressSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = PrivateIpAddressSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type PrivateIpAddressSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut primary: Option<::Value<bool>> = None;
                    let mut private_ip_address: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Primary" => {
                                primary = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "PrivateIpAddress" => {
                                private_ip_address = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(PrivateIpAddressSpecification {
                        primary: primary,
                        private_ip_address: private_ip_address.ok_or(::serde::de::Error::missing_field("PrivateIpAddress"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::SpotFleet.SpotCapacityRebalance`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotcapacityrebalance.html) property type.
    #[derive(Debug, Default)]
    pub struct SpotCapacityRebalance {
        /// Property [`ReplacementStrategy`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotcapacityrebalance.html#cfn-ec2-spotfleet-spotcapacityrebalance-replacementstrategy).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub replacement_strategy: Option<::Value<String>>,
        /// Property [`TerminationDelay`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotcapacityrebalance.html#cfn-ec2-spotfleet-spotcapacityrebalance-terminationdelay).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub termination_delay: Option<::Value<u32>>,
    }

    impl ::codec::SerializeValue for SpotCapacityRebalance {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref replacement_strategy) = self.replacement_strategy {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ReplacementStrategy", replacement_strategy)?;
            }
            if let Some(ref termination_delay) = self.termination_delay {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "TerminationDelay", termination_delay)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for SpotCapacityRebalance {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<SpotCapacityRebalance, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = SpotCapacityRebalance;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type SpotCapacityRebalance")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut replacement_strategy: Option<::Value<String>> = None;
                    let mut termination_delay: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "ReplacementStrategy" => {
                                replacement_strategy = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "TerminationDelay" => {
                                termination_delay = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(SpotCapacityRebalance {
                        replacement_strategy: replacement_strategy,
                        termination_delay: termination_delay,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::SpotFleet.SpotFleetLaunchSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html) property type.
    #[derive(Debug, Default)]
    pub struct SpotFleetLaunchSpecification {
        /// Property [`BlockDeviceMappings`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-blockdevicemappings).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub block_device_mappings: Option<::ValueList<BlockDeviceMapping>>,
        /// Property [`EbsOptimized`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-ebsoptimized).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub ebs_optimized: Option<::Value<bool>>,
        /// Property [`IamInstanceProfile`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-iaminstanceprofile).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub iam_instance_profile: Option<::Value<IamInstanceProfileSpecification>>,
        /// Property [`ImageId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-imageid).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub image_id: ::Value<String>,
        /// Property [`InstanceRequirements`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-instancerequirements).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub instance_requirements: Option<::Value<InstanceRequirementsRequest>>,
        /// Property [`InstanceType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-instancetype).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub instance_type: Option<::Value<String>>,
        /// Property [`KernelId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-kernelid).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub kernel_id: Option<::Value<String>>,
        /// Property [`KeyName`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-keyname).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub key_name: Option<::Value<String>>,
        /// Property [`Monitoring`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-monitoring).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub monitoring: Option<::Value<SpotFleetMonitoring>>,
        /// Property [`NetworkInterfaces`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-networkinterfaces).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub network_interfaces: Option<::ValueList<InstanceNetworkInterfaceSpecification>>,
        /// Property [`Placement`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-placement).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub placement: Option<::Value<SpotPlacement>>,
        /// Property [`RamdiskId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-ramdiskid).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub ramdisk_id: Option<::Value<String>>,
        /// Property [`SecurityGroups`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-securitygroups).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub security_groups: Option<::ValueList<GroupIdentifier>>,
        /// Property [`SpotPrice`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-spotprice).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub spot_price: Option<::Value<String>>,
        /// Property [`SubnetId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-subnetid).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub subnet_id: Option<::Value<String>>,
        /// Property [`TagSpecifications`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-tagspecifications).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub tag_specifications: Option<::ValueList<SpotFleetTagSpecification>>,
        /// Property [`UserData`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-userdata).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub user_data: Option<::Value<String>>,
        /// Property [`WeightedCapacity`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-weightedcapacity).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub weighted_capacity: Option<::Value<f64>>,
    }

    impl ::codec::SerializeValue for SpotFleetLaunchSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref block_device_mappings) = self.block_device_mappings {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "BlockDeviceMappings", block_device_mappings)?;
            }
            if let Some(ref ebs_optimized) = self.ebs_optimized {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "EbsOptimized", ebs_optimized)?;
            }
            if let Some(ref iam_instance_profile) = self.iam_instance_profile {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "IamInstanceProfile", iam_instance_profile)?;
            }
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "ImageId", &self.image_id)?;
            if let Some(ref instance_requirements) = self.instance_requirements {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstanceRequirements", instance_requirements)?;
            }
            if let Some(ref instance_type) = self.instance_type {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstanceType", instance_type)?;
            }
            if let Some(ref kernel_id) = self.kernel_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "KernelId", kernel_id)?;
            }
            if let Some(ref key_name) = self.key_name {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "KeyName", key_name)?;
            }
            if let Some(ref monitoring) = self.monitoring {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Monitoring", monitoring)?;
            }
            if let Some(ref network_interfaces) = self.network_interfaces {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetworkInterfaces", network_interfaces)?;
            }
            if let Some(ref placement) = self.placement {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Placement", placement)?;
            }
            if let Some(ref ramdisk_id) = self.ramdisk_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "RamdiskId", ramdisk_id)?;
            }
            if let Some(ref security_groups) = self.security_groups {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SecurityGroups", security_groups)?;
            }
            if let Some(ref spot_price) = self.spot_price {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SpotPrice", spot_price)?;
            }
            if let Some(ref subnet_id) = self.subnet_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SubnetId", subnet_id)?;
            }
            if let Some(ref tag_specifications) = self.tag_specifications {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "TagSpecifications", tag_specifications)?;
            }
            if let Some(ref user_data) = self.user_data {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "UserData", user_data)?;
            }
            if let Some(ref weighted_capacity) = self.weighted_capacity {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "WeightedCapacity", weighted_capacity)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for SpotFleetLaunchSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<SpotFleetLaunchSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = SpotFleetLaunchSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type SpotFleetLaunchSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut block_device_mappings: Option<::ValueList<BlockDeviceMapping>> = None;
                    let mut ebs_optimized: Option<::Value<bool>> = None;
                    let mut iam_instance_profile: Option<::Value<IamInstanceProfileSpecification>> = None;
                    let mut image_id: Option<::Value<String>> = None;
                    let mut instance_requirements: Option<::Value<InstanceRequirementsRequest>> = None;
                    let mut instance_type: Option<::Value<String>> = None;
                    let mut kernel_id: Option<::Value<String>> = None;
                    let mut key_name: Option<::Value<String>> = None;
                    let mut monitoring: Option<::Value<SpotFleetMonitoring>> = None;
                    let mut network_interfaces: Option<::ValueList<InstanceNetworkInterfaceSpecification>> = None;
                    let mut placement: Option<::Value<SpotPlacement>> = None;
                    let mut ramdisk_id: Option<::Value<String>> = None;
                    let mut security_groups: Option<::ValueList<GroupIdentifier>> = None;
                    let mut spot_price: Option<::Value<String>> = None;
                    let mut subnet_id: Option<::Value<String>> = None;
                    let mut tag_specifications: Option<::ValueList<SpotFleetTagSpecification>> = None;
                    let mut user_data: Option<::Value<String>> = None;
                    let mut weighted_capacity: Option<::Value<f64>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "BlockDeviceMappings" => {
                                block_device_mappings = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "EbsOptimized" => {
                                ebs_optimized = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "IamInstanceProfile" => {
                                iam_instance_profile = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ImageId" => {
                                image_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "InstanceRequirements" => {
                                instance_requirements = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "InstanceType" => {
                                instance_type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "KernelId" => {
                                kernel_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "KeyName" => {
                                key_name = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Monitoring" => {
                                monitoring = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "NetworkInterfaces" => {
                                network_interfaces = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Placement" => {
                                placement = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "RamdiskId" => {
                                ramdisk_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SecurityGroups" => {
                                security_groups = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SpotPrice" => {
                                spot_price = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SubnetId" => {
                                subnet_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "TagSpecifications" => {
                                tag_specifications = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "UserData" => {
                                user_data = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "WeightedCapacity" => {
                                weighted_capacity = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(SpotFleetLaunchSpecification {
                        block_device_mappings: block_device_mappings,
                        ebs_optimized: ebs_optimized,
                        iam_instance_profile: iam_instance_profile,
                        image_id: image_id.ok_or(::serde::de::Error::missing_field("ImageId"))?,
                        instance_requirements: instance_requirements,
                        instance_type: instance_type,
                        kernel_id: kernel_id,
                        key_name: key_name,
                        monitoring: monitoring,
                        network_interfaces: network_interfaces,
                        placement: placement,
                        ramdisk_id: ramdisk_id,
                        security_groups: security_groups,
                        spot_price: spot_price,
                        subnet_id: subnet_id,
                        tag_specifications: tag_specifications,
                        user_data: user_data,
                        weighted_capacity: weighted_capacity,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::SpotFleet.SpotFleetMonitoring`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetmonitoring.html) property type.
    #[derive(Debug, Default)]
    pub struct SpotFleetMonitoring {
        /// Property [`Enabled`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetmonitoring.html#cfn-ec2-spotfleet-spotfleetmonitoring-enabled).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub enabled: Option<::Value<bool>>,
    }

    impl ::codec::SerializeValue for SpotFleetMonitoring {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref enabled) = self.enabled {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Enabled", enabled)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for SpotFleetMonitoring {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<SpotFleetMonitoring, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = SpotFleetMonitoring;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type SpotFleetMonitoring")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut enabled: Option<::Value<bool>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Enabled" => {
                                enabled = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(SpotFleetMonitoring {
                        enabled: enabled,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::SpotFleet.SpotFleetRequestConfigData`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html) property type.
    #[derive(Debug, Default)]
    pub struct SpotFleetRequestConfigData {
        /// Property [`AllocationStrategy`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-allocationstrategy).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub allocation_strategy: Option<::Value<String>>,
        /// Property [`Context`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-context).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub context: Option<::Value<String>>,
        /// Property [`ExcessCapacityTerminationPolicy`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-excesscapacityterminationpolicy).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub excess_capacity_termination_policy: Option<::Value<String>>,
        /// Property [`IamFleetRole`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-iamfleetrole).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub iam_fleet_role: ::Value<String>,
        /// Property [`InstanceInterruptionBehavior`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-instanceinterruptionbehavior).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub instance_interruption_behavior: Option<::Value<String>>,
        /// Property [`InstancePoolsToUseCount`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-instancepoolstousecount).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub instance_pools_to_use_count: Option<::Value<u32>>,
        /// Property [`LaunchSpecifications`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-launchspecifications).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub launch_specifications: Option<::ValueList<SpotFleetLaunchSpecification>>,
        /// Property [`LaunchTemplateConfigs`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-launchtemplateconfigs).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub launch_template_configs: Option<::ValueList<LaunchTemplateConfig>>,
        /// Property [`LoadBalancersConfig`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-loadbalancersconfig).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub load_balancers_config: Option<::Value<LoadBalancersConfig>>,
        /// Property [`OnDemandAllocationStrategy`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-ondemandallocationstrategy).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub on_demand_allocation_strategy: Option<::Value<String>>,
        /// Property [`OnDemandMaxTotalPrice`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-ondemandmaxtotalprice).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub on_demand_max_total_price: Option<::Value<String>>,
        /// Property [`OnDemandTargetCapacity`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-ondemandtargetcapacity).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub on_demand_target_capacity: Option<::Value<u32>>,
        /// Property [`ReplaceUnhealthyInstances`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-replaceunhealthyinstances).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub replace_unhealthy_instances: Option<::Value<bool>>,
        /// Property [`SpotMaintenanceStrategies`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-spotmaintenancestrategies).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub spot_maintenance_strategies: Option<::Value<SpotMaintenanceStrategies>>,
        /// Property [`SpotMaxTotalPrice`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-spotmaxtotalprice).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub spot_max_total_price: Option<::Value<String>>,
        /// Property [`SpotPrice`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-spotprice).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub spot_price: Option<::Value<String>>,
        /// Property [`TagSpecifications`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-tagspecifications).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub tag_specifications: Option<::ValueList<SpotFleetTagSpecification>>,
        /// Property [`TargetCapacity`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-targetcapacity).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub target_capacity: ::Value<u32>,
        /// Property [`TargetCapacityUnitType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-targetcapacityunittype).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub target_capacity_unit_type: Option<::Value<String>>,
        /// Property [`TerminateInstancesWithExpiration`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-terminateinstanceswithexpiration).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub terminate_instances_with_expiration: Option<::Value<bool>>,
        /// Property [`Type`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-type).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub r#type: Option<::Value<String>>,
        /// Property [`ValidFrom`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-validfrom).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub valid_from: Option<::Value<String>>,
        /// Property [`ValidUntil`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-validuntil).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub valid_until: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for SpotFleetRequestConfigData {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref allocation_strategy) = self.allocation_strategy {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AllocationStrategy", allocation_strategy)?;
            }
            if let Some(ref context) = self.context {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Context", context)?;
            }
            if let Some(ref excess_capacity_termination_policy) = self.excess_capacity_termination_policy {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ExcessCapacityTerminationPolicy", excess_capacity_termination_policy)?;
            }
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "IamFleetRole", &self.iam_fleet_role)?;
            if let Some(ref instance_interruption_behavior) = self.instance_interruption_behavior {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstanceInterruptionBehavior", instance_interruption_behavior)?;
            }
            if let Some(ref instance_pools_to_use_count) = self.instance_pools_to_use_count {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "InstancePoolsToUseCount", instance_pools_to_use_count)?;
            }
            if let Some(ref launch_specifications) = self.launch_specifications {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "LaunchSpecifications", launch_specifications)?;
            }
            if let Some(ref launch_template_configs) = self.launch_template_configs {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "LaunchTemplateConfigs", launch_template_configs)?;
            }
            if let Some(ref load_balancers_config) = self.load_balancers_config {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "LoadBalancersConfig", load_balancers_config)?;
            }
            if let Some(ref on_demand_allocation_strategy) = self.on_demand_allocation_strategy {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "OnDemandAllocationStrategy", on_demand_allocation_strategy)?;
            }
            if let Some(ref on_demand_max_total_price) = self.on_demand_max_total_price {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "OnDemandMaxTotalPrice", on_demand_max_total_price)?;
            }
            if let Some(ref on_demand_target_capacity) = self.on_demand_target_capacity {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "OnDemandTargetCapacity", on_demand_target_capacity)?;
            }
            if let Some(ref replace_unhealthy_instances) = self.replace_unhealthy_instances {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ReplaceUnhealthyInstances", replace_unhealthy_instances)?;
            }
            if let Some(ref spot_maintenance_strategies) = self.spot_maintenance_strategies {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SpotMaintenanceStrategies", spot_maintenance_strategies)?;
            }
            if let Some(ref spot_max_total_price) = self.spot_max_total_price {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SpotMaxTotalPrice", spot_max_total_price)?;
            }
            if let Some(ref spot_price) = self.spot_price {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SpotPrice", spot_price)?;
            }
            if let Some(ref tag_specifications) = self.tag_specifications {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "TagSpecifications", tag_specifications)?;
            }
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "TargetCapacity", &self.target_capacity)?;
            if let Some(ref target_capacity_unit_type) = self.target_capacity_unit_type {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "TargetCapacityUnitType", target_capacity_unit_type)?;
            }
            if let Some(ref terminate_instances_with_expiration) = self.terminate_instances_with_expiration {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "TerminateInstancesWithExpiration", terminate_instances_with_expiration)?;
            }
            if let Some(ref r#type) = self.r#type {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Type", r#type)?;
            }
            if let Some(ref valid_from) = self.valid_from {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ValidFrom", valid_from)?;
            }
            if let Some(ref valid_until) = self.valid_until {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ValidUntil", valid_until)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for SpotFleetRequestConfigData {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<SpotFleetRequestConfigData, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = SpotFleetRequestConfigData;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type SpotFleetRequestConfigData")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut allocation_strategy: Option<::Value<String>> = None;
                    let mut context: Option<::Value<String>> = None;
                    let mut excess_capacity_termination_policy: Option<::Value<String>> = None;
                    let mut iam_fleet_role: Option<::Value<String>> = None;
                    let mut instance_interruption_behavior: Option<::Value<String>> = None;
                    let mut instance_pools_to_use_count: Option<::Value<u32>> = None;
                    let mut launch_specifications: Option<::ValueList<SpotFleetLaunchSpecification>> = None;
                    let mut launch_template_configs: Option<::ValueList<LaunchTemplateConfig>> = None;
                    let mut load_balancers_config: Option<::Value<LoadBalancersConfig>> = None;
                    let mut on_demand_allocation_strategy: Option<::Value<String>> = None;
                    let mut on_demand_max_total_price: Option<::Value<String>> = None;
                    let mut on_demand_target_capacity: Option<::Value<u32>> = None;
                    let mut replace_unhealthy_instances: Option<::Value<bool>> = None;
                    let mut spot_maintenance_strategies: Option<::Value<SpotMaintenanceStrategies>> = None;
                    let mut spot_max_total_price: Option<::Value<String>> = None;
                    let mut spot_price: Option<::Value<String>> = None;
                    let mut tag_specifications: Option<::ValueList<SpotFleetTagSpecification>> = None;
                    let mut target_capacity: Option<::Value<u32>> = None;
                    let mut target_capacity_unit_type: Option<::Value<String>> = None;
                    let mut terminate_instances_with_expiration: Option<::Value<bool>> = None;
                    let mut r#type: Option<::Value<String>> = None;
                    let mut valid_from: Option<::Value<String>> = None;
                    let mut valid_until: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "AllocationStrategy" => {
                                allocation_strategy = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Context" => {
                                context = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ExcessCapacityTerminationPolicy" => {
                                excess_capacity_termination_policy = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "IamFleetRole" => {
                                iam_fleet_role = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "InstanceInterruptionBehavior" => {
                                instance_interruption_behavior = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "InstancePoolsToUseCount" => {
                                instance_pools_to_use_count = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "LaunchSpecifications" => {
                                launch_specifications = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "LaunchTemplateConfigs" => {
                                launch_template_configs = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "LoadBalancersConfig" => {
                                load_balancers_config = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "OnDemandAllocationStrategy" => {
                                on_demand_allocation_strategy = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "OnDemandMaxTotalPrice" => {
                                on_demand_max_total_price = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "OnDemandTargetCapacity" => {
                                on_demand_target_capacity = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ReplaceUnhealthyInstances" => {
                                replace_unhealthy_instances = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SpotMaintenanceStrategies" => {
                                spot_maintenance_strategies = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SpotMaxTotalPrice" => {
                                spot_max_total_price = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SpotPrice" => {
                                spot_price = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "TagSpecifications" => {
                                tag_specifications = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "TargetCapacity" => {
                                target_capacity = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "TargetCapacityUnitType" => {
                                target_capacity_unit_type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "TerminateInstancesWithExpiration" => {
                                terminate_instances_with_expiration = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Type" => {
                                r#type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ValidFrom" => {
                                valid_from = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ValidUntil" => {
                                valid_until = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(SpotFleetRequestConfigData {
                        allocation_strategy: allocation_strategy,
                        context: context,
                        excess_capacity_termination_policy: excess_capacity_termination_policy,
                        iam_fleet_role: iam_fleet_role.ok_or(::serde::de::Error::missing_field("IamFleetRole"))?,
                        instance_interruption_behavior: instance_interruption_behavior,
                        instance_pools_to_use_count: instance_pools_to_use_count,
                        launch_specifications: launch_specifications,
                        launch_template_configs: launch_template_configs,
                        load_balancers_config: load_balancers_config,
                        on_demand_allocation_strategy: on_demand_allocation_strategy,
                        on_demand_max_total_price: on_demand_max_total_price,
                        on_demand_target_capacity: on_demand_target_capacity,
                        replace_unhealthy_instances: replace_unhealthy_instances,
                        spot_maintenance_strategies: spot_maintenance_strategies,
                        spot_max_total_price: spot_max_total_price,
                        spot_price: spot_price,
                        tag_specifications: tag_specifications,
                        target_capacity: target_capacity.ok_or(::serde::de::Error::missing_field("TargetCapacity"))?,
                        target_capacity_unit_type: target_capacity_unit_type,
                        terminate_instances_with_expiration: terminate_instances_with_expiration,
                        r#type: r#type,
                        valid_from: valid_from,
                        valid_until: valid_until,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::SpotFleet.SpotFleetTagSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleettagspecification.html) property type.
    #[derive(Debug, Default)]
    pub struct SpotFleetTagSpecification {
        /// Property [`ResourceType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleettagspecification.html#cfn-ec2-spotfleet-spotfleettagspecification-resourcetype).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub resource_type: Option<::Value<String>>,
        /// Property [`Tags`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleettagspecification.html#cfn-ec2-spotfleet-spotfleettagspecification-tags).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub tags: Option<::ValueList<::Tag>>,
    }

    impl ::codec::SerializeValue for SpotFleetTagSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref resource_type) = self.resource_type {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ResourceType", resource_type)?;
            }
            if let Some(ref tags) = self.tags {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tags", tags)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for SpotFleetTagSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<SpotFleetTagSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = SpotFleetTagSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type SpotFleetTagSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut resource_type: Option<::Value<String>> = None;
                    let mut tags: Option<::ValueList<::Tag>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "ResourceType" => {
                                resource_type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Tags" => {
                                tags = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(SpotFleetTagSpecification {
                        resource_type: resource_type,
                        tags: tags,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::SpotFleet.SpotMaintenanceStrategies`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotmaintenancestrategies.html) property type.
    #[derive(Debug, Default)]
    pub struct SpotMaintenanceStrategies {
        /// Property [`CapacityRebalance`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotmaintenancestrategies.html#cfn-ec2-spotfleet-spotmaintenancestrategies-capacityrebalance).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub capacity_rebalance: Option<::Value<SpotCapacityRebalance>>,
    }

    impl ::codec::SerializeValue for SpotMaintenanceStrategies {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref capacity_rebalance) = self.capacity_rebalance {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "CapacityRebalance", capacity_rebalance)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for SpotMaintenanceStrategies {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<SpotMaintenanceStrategies, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = SpotMaintenanceStrategies;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type SpotMaintenanceStrategies")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut capacity_rebalance: Option<::Value<SpotCapacityRebalance>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "CapacityRebalance" => {
                                capacity_rebalance = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(SpotMaintenanceStrategies {
                        capacity_rebalance: capacity_rebalance,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::SpotFleet.SpotPlacement`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotplacement.html) property type.
    #[derive(Debug, Default)]
    pub struct SpotPlacement {
        /// Property [`AvailabilityZone`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotplacement.html#cfn-ec2-spotfleet-spotplacement-availabilityzone).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub availability_zone: Option<::Value<String>>,
        /// Property [`GroupName`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotplacement.html#cfn-ec2-spotfleet-spotplacement-groupname).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub group_name: Option<::Value<String>>,
        /// Property [`Tenancy`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotplacement.html#cfn-ec2-spotfleet-spotplacement-tenancy).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub tenancy: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for SpotPlacement {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref availability_zone) = self.availability_zone {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AvailabilityZone", availability_zone)?;
            }
            if let Some(ref group_name) = self.group_name {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "GroupName", group_name)?;
            }
            if let Some(ref tenancy) = self.tenancy {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Tenancy", tenancy)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for SpotPlacement {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<SpotPlacement, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = SpotPlacement;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type SpotPlacement")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut availability_zone: Option<::Value<String>> = None;
                    let mut group_name: Option<::Value<String>> = None;
                    let mut tenancy: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "AvailabilityZone" => {
                                availability_zone = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "GroupName" => {
                                group_name = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Tenancy" => {
                                tenancy = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(SpotPlacement {
                        availability_zone: availability_zone,
                        group_name: group_name,
                        tenancy: tenancy,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::SpotFleet.TargetGroup`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-targetgroup.html) property type.
    #[derive(Debug, Default)]
    pub struct TargetGroup {
        /// Property [`Arn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-targetgroup.html#cfn-ec2-spotfleet-targetgroup-arn).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub arn: ::Value<String>,
    }

    impl ::codec::SerializeValue for TargetGroup {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "Arn", &self.arn)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for TargetGroup {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<TargetGroup, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = TargetGroup;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type TargetGroup")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut arn: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Arn" => {
                                arn = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(TargetGroup {
                        arn: arn.ok_or(::serde::de::Error::missing_field("Arn"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::SpotFleet.TargetGroupsConfig`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-targetgroupsconfig.html) property type.
    #[derive(Debug, Default)]
    pub struct TargetGroupsConfig {
        /// Property [`TargetGroups`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-targetgroupsconfig.html#cfn-ec2-spotfleet-targetgroupsconfig-targetgroups).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub target_groups: ::ValueList<TargetGroup>,
    }

    impl ::codec::SerializeValue for TargetGroupsConfig {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "TargetGroups", &self.target_groups)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for TargetGroupsConfig {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<TargetGroupsConfig, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = TargetGroupsConfig;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type TargetGroupsConfig")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut target_groups: Option<::ValueList<TargetGroup>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "TargetGroups" => {
                                target_groups = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(TargetGroupsConfig {
                        target_groups: target_groups.ok_or(::serde::de::Error::missing_field("TargetGroups"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::SpotFleet.TotalLocalStorageGBRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-totallocalstoragegbrequest.html) property type.
    #[derive(Debug, Default)]
    pub struct TotalLocalStorageGBRequest {
        /// Property [`Max`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-totallocalstoragegbrequest.html#cfn-ec2-spotfleet-totallocalstoragegbrequest-max).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub max: Option<::Value<f64>>,
        /// Property [`Min`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-totallocalstoragegbrequest.html#cfn-ec2-spotfleet-totallocalstoragegbrequest-min).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub min: Option<::Value<f64>>,
    }

    impl ::codec::SerializeValue for TotalLocalStorageGBRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref max) = self.max {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Max", max)?;
            }
            if let Some(ref min) = self.min {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Min", min)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for TotalLocalStorageGBRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<TotalLocalStorageGBRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = TotalLocalStorageGBRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type TotalLocalStorageGBRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut max: Option<::Value<f64>> = None;
                    let mut min: Option<::Value<f64>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Max" => {
                                max = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Min" => {
                                min = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(TotalLocalStorageGBRequest {
                        max: max,
                        min: min,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::SpotFleet.VCpuCountRangeRequest`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-vcpucountrangerequest.html) property type.
    #[derive(Debug, Default)]
    pub struct VCpuCountRangeRequest {
        /// Property [`Max`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-vcpucountrangerequest.html#cfn-ec2-spotfleet-vcpucountrangerequest-max).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub max: Option<::Value<u32>>,
        /// Property [`Min`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-vcpucountrangerequest.html#cfn-ec2-spotfleet-vcpucountrangerequest-min).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub min: Option<::Value<u32>>,
    }

    impl ::codec::SerializeValue for VCpuCountRangeRequest {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref max) = self.max {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Max", max)?;
            }
            if let Some(ref min) = self.min {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Min", min)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for VCpuCountRangeRequest {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<VCpuCountRangeRequest, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = VCpuCountRangeRequest;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type VCpuCountRangeRequest")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut max: Option<::Value<u32>> = None;
                    let mut min: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Max" => {
                                max = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Min" => {
                                min = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(VCpuCountRangeRequest {
                        max: max,
                        min: min,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }
}

pub mod subnet {
    //! Property types for the `Subnet` resource.

    /// The [`AWS::EC2::Subnet.PrivateDnsNameOptionsOnLaunch`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-privatednsnameoptionsonlaunch.html) property type.
    #[derive(Debug, Default)]
    pub struct PrivateDnsNameOptionsOnLaunch {
        /// Property [`EnableResourceNameDnsAAAARecord`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-privatednsnameoptionsonlaunch.html#cfn-ec2-subnet-privatednsnameoptionsonlaunch-enableresourcenamednsaaaarecord).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub enable_resource_name_dns_aaaa_record: Option<::Value<bool>>,
        /// Property [`EnableResourceNameDnsARecord`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-privatednsnameoptionsonlaunch.html#cfn-ec2-subnet-privatednsnameoptionsonlaunch-enableresourcenamednsarecord).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub enable_resource_name_dns_a_record: Option<::Value<bool>>,
        /// Property [`HostnameType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-privatednsnameoptionsonlaunch.html#cfn-ec2-subnet-privatednsnameoptionsonlaunch-hostnametype).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub hostname_type: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for PrivateDnsNameOptionsOnLaunch {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref enable_resource_name_dns_aaaa_record) = self.enable_resource_name_dns_aaaa_record {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "EnableResourceNameDnsAAAARecord", enable_resource_name_dns_aaaa_record)?;
            }
            if let Some(ref enable_resource_name_dns_a_record) = self.enable_resource_name_dns_a_record {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "EnableResourceNameDnsARecord", enable_resource_name_dns_a_record)?;
            }
            if let Some(ref hostname_type) = self.hostname_type {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "HostnameType", hostname_type)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for PrivateDnsNameOptionsOnLaunch {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<PrivateDnsNameOptionsOnLaunch, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = PrivateDnsNameOptionsOnLaunch;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type PrivateDnsNameOptionsOnLaunch")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut enable_resource_name_dns_aaaa_record: Option<::Value<bool>> = None;
                    let mut enable_resource_name_dns_a_record: Option<::Value<bool>> = None;
                    let mut hostname_type: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "EnableResourceNameDnsAAAARecord" => {
                                enable_resource_name_dns_aaaa_record = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "EnableResourceNameDnsARecord" => {
                                enable_resource_name_dns_a_record = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "HostnameType" => {
                                hostname_type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(PrivateDnsNameOptionsOnLaunch {
                        enable_resource_name_dns_aaaa_record: enable_resource_name_dns_aaaa_record,
                        enable_resource_name_dns_a_record: enable_resource_name_dns_a_record,
                        hostname_type: hostname_type,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }
}

pub mod traffic_mirror_filter_rule {
    //! Property types for the `TrafficMirrorFilterRule` resource.

    /// The [`AWS::EC2::TrafficMirrorFilterRule.TrafficMirrorPortRange`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorfilterrule-trafficmirrorportrange.html) property type.
    #[derive(Debug, Default)]
    pub struct TrafficMirrorPortRange {
        /// Property [`FromPort`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorfilterrule-trafficmirrorportrange.html#cfn-ec2-trafficmirrorfilterrule-trafficmirrorportrange-fromport).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub from_port: ::Value<u32>,
        /// Property [`ToPort`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorfilterrule-trafficmirrorportrange.html#cfn-ec2-trafficmirrorfilterrule-trafficmirrorportrange-toport).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub to_port: ::Value<u32>,
    }

    impl ::codec::SerializeValue for TrafficMirrorPortRange {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "FromPort", &self.from_port)?;
            ::serde::ser::SerializeMap::serialize_entry(&mut map, "ToPort", &self.to_port)?;
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for TrafficMirrorPortRange {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<TrafficMirrorPortRange, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = TrafficMirrorPortRange;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type TrafficMirrorPortRange")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut from_port: Option<::Value<u32>> = None;
                    let mut to_port: Option<::Value<u32>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "FromPort" => {
                                from_port = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ToPort" => {
                                to_port = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(TrafficMirrorPortRange {
                        from_port: from_port.ok_or(::serde::de::Error::missing_field("FromPort"))?,
                        to_port: to_port.ok_or(::serde::de::Error::missing_field("ToPort"))?,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }
}

pub mod transit_gateway_attachment {
    //! Property types for the `TransitGatewayAttachment` resource.

    /// The [`AWS::EC2::TransitGatewayAttachment.Options`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayattachment-options.html) property type.
    #[derive(Debug, Default)]
    pub struct Options {
        /// Property [`ApplianceModeSupport`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayattachment-options.html#cfn-ec2-transitgatewayattachment-options-appliancemodesupport).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub appliance_mode_support: Option<::Value<String>>,
        /// Property [`DnsSupport`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayattachment-options.html#cfn-ec2-transitgatewayattachment-options-dnssupport).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub dns_support: Option<::Value<String>>,
        /// Property [`Ipv6Support`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayattachment-options.html#cfn-ec2-transitgatewayattachment-options-ipv6support).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub ipv6_support: Option<::Value<String>>,
        /// Property [`SecurityGroupReferencingSupport`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayattachment-options.html#cfn-ec2-transitgatewayattachment-options-securitygroupreferencingsupport).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub security_group_referencing_support: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for Options {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref appliance_mode_support) = self.appliance_mode_support {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ApplianceModeSupport", appliance_mode_support)?;
            }
            if let Some(ref dns_support) = self.dns_support {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "DnsSupport", dns_support)?;
            }
            if let Some(ref ipv6_support) = self.ipv6_support {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6Support", ipv6_support)?;
            }
            if let Some(ref security_group_referencing_support) = self.security_group_referencing_support {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SecurityGroupReferencingSupport", security_group_referencing_support)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for Options {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<Options, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = Options;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type Options")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut appliance_mode_support: Option<::Value<String>> = None;
                    let mut dns_support: Option<::Value<String>> = None;
                    let mut ipv6_support: Option<::Value<String>> = None;
                    let mut security_group_referencing_support: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "ApplianceModeSupport" => {
                                appliance_mode_support = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "DnsSupport" => {
                                dns_support = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Ipv6Support" => {
                                ipv6_support = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SecurityGroupReferencingSupport" => {
                                security_group_referencing_support = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(Options {
                        appliance_mode_support: appliance_mode_support,
                        dns_support: dns_support,
                        ipv6_support: ipv6_support,
                        security_group_referencing_support: security_group_referencing_support,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }
}

pub mod transit_gateway_connect {
    //! Property types for the `TransitGatewayConnect` resource.

    /// The [`AWS::EC2::TransitGatewayConnect.TransitGatewayConnectOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayconnect-transitgatewayconnectoptions.html) property type.
    #[derive(Debug, Default)]
    pub struct TransitGatewayConnectOptions {
        /// Property [`Protocol`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayconnect-transitgatewayconnectoptions.html#cfn-ec2-transitgatewayconnect-transitgatewayconnectoptions-protocol).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub protocol: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for TransitGatewayConnectOptions {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref protocol) = self.protocol {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Protocol", protocol)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for TransitGatewayConnectOptions {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<TransitGatewayConnectOptions, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = TransitGatewayConnectOptions;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type TransitGatewayConnectOptions")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut protocol: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Protocol" => {
                                protocol = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(TransitGatewayConnectOptions {
                        protocol: protocol,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }
}

pub mod transit_gateway_multicast_domain {
    //! Property types for the `TransitGatewayMulticastDomain` resource.

    /// The [`AWS::EC2::TransitGatewayMulticastDomain.Options`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaymulticastdomain-options.html) property type.
    #[derive(Debug, Default)]
    pub struct Options {
        /// Property [`AutoAcceptSharedAssociations`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaymulticastdomain-options.html#cfn-ec2-transitgatewaymulticastdomain-options-autoacceptsharedassociations).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub auto_accept_shared_associations: Option<::Value<String>>,
        /// Property [`Igmpv2Support`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaymulticastdomain-options.html#cfn-ec2-transitgatewaymulticastdomain-options-igmpv2support).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub igmpv2_support: Option<::Value<String>>,
        /// Property [`StaticSourcesSupport`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaymulticastdomain-options.html#cfn-ec2-transitgatewaymulticastdomain-options-staticsourcessupport).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub static_sources_support: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for Options {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref auto_accept_shared_associations) = self.auto_accept_shared_associations {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AutoAcceptSharedAssociations", auto_accept_shared_associations)?;
            }
            if let Some(ref igmpv2_support) = self.igmpv2_support {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Igmpv2Support", igmpv2_support)?;
            }
            if let Some(ref static_sources_support) = self.static_sources_support {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "StaticSourcesSupport", static_sources_support)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for Options {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<Options, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = Options;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type Options")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut auto_accept_shared_associations: Option<::Value<String>> = None;
                    let mut igmpv2_support: Option<::Value<String>> = None;
                    let mut static_sources_support: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "AutoAcceptSharedAssociations" => {
                                auto_accept_shared_associations = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Igmpv2Support" => {
                                igmpv2_support = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "StaticSourcesSupport" => {
                                static_sources_support = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(Options {
                        auto_accept_shared_associations: auto_accept_shared_associations,
                        igmpv2_support: igmpv2_support,
                        static_sources_support: static_sources_support,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }
}

pub mod transit_gateway_peering_attachment {
    //! Property types for the `TransitGatewayPeeringAttachment` resource.

    /// The [`AWS::EC2::TransitGatewayPeeringAttachment.PeeringAttachmentStatus`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaypeeringattachment-peeringattachmentstatus.html) property type.
    #[derive(Debug, Default)]
    pub struct PeeringAttachmentStatus {
        /// Property [`Code`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaypeeringattachment-peeringattachmentstatus.html#cfn-ec2-transitgatewaypeeringattachment-peeringattachmentstatus-code).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub code: Option<::Value<String>>,
        /// Property [`Message`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaypeeringattachment-peeringattachmentstatus.html#cfn-ec2-transitgatewaypeeringattachment-peeringattachmentstatus-message).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub message: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for PeeringAttachmentStatus {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref code) = self.code {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Code", code)?;
            }
            if let Some(ref message) = self.message {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Message", message)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for PeeringAttachmentStatus {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<PeeringAttachmentStatus, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = PeeringAttachmentStatus;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type PeeringAttachmentStatus")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut code: Option<::Value<String>> = None;
                    let mut message: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Code" => {
                                code = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Message" => {
                                message = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(PeeringAttachmentStatus {
                        code: code,
                        message: message,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }
}

pub mod transit_gateway_vpc_attachment {
    //! Property types for the `TransitGatewayVpcAttachment` resource.

    /// The [`AWS::EC2::TransitGatewayVpcAttachment.Options`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayvpcattachment-options.html) property type.
    #[derive(Debug, Default)]
    pub struct Options {
        /// Property [`ApplianceModeSupport`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayvpcattachment-options.html#cfn-ec2-transitgatewayvpcattachment-options-appliancemodesupport).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub appliance_mode_support: Option<::Value<String>>,
        /// Property [`DnsSupport`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayvpcattachment-options.html#cfn-ec2-transitgatewayvpcattachment-options-dnssupport).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub dns_support: Option<::Value<String>>,
        /// Property [`Ipv6Support`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayvpcattachment-options.html#cfn-ec2-transitgatewayvpcattachment-options-ipv6support).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub ipv6_support: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for Options {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref appliance_mode_support) = self.appliance_mode_support {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ApplianceModeSupport", appliance_mode_support)?;
            }
            if let Some(ref dns_support) = self.dns_support {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "DnsSupport", dns_support)?;
            }
            if let Some(ref ipv6_support) = self.ipv6_support {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Ipv6Support", ipv6_support)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for Options {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<Options, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = Options;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type Options")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut appliance_mode_support: Option<::Value<String>> = None;
                    let mut dns_support: Option<::Value<String>> = None;
                    let mut ipv6_support: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "ApplianceModeSupport" => {
                                appliance_mode_support = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "DnsSupport" => {
                                dns_support = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Ipv6Support" => {
                                ipv6_support = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(Options {
                        appliance_mode_support: appliance_mode_support,
                        dns_support: dns_support,
                        ipv6_support: ipv6_support,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }
}

pub mod vpn_connection {
    //! Property types for the `VPNConnection` resource.

    /// The [`AWS::EC2::VPNConnection.VpnTunnelOptionsSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html) property type.
    #[derive(Debug, Default)]
    pub struct VpnTunnelOptionsSpecification {
        /// Property [`PreSharedKey`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-presharedkey).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub pre_shared_key: Option<::Value<String>>,
        /// Property [`TunnelInsideCidr`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-tunnelinsidecidr).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub tunnel_inside_cidr: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for VpnTunnelOptionsSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref pre_shared_key) = self.pre_shared_key {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "PreSharedKey", pre_shared_key)?;
            }
            if let Some(ref tunnel_inside_cidr) = self.tunnel_inside_cidr {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "TunnelInsideCidr", tunnel_inside_cidr)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for VpnTunnelOptionsSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<VpnTunnelOptionsSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = VpnTunnelOptionsSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type VpnTunnelOptionsSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut pre_shared_key: Option<::Value<String>> = None;
                    let mut tunnel_inside_cidr: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "PreSharedKey" => {
                                pre_shared_key = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "TunnelInsideCidr" => {
                                tunnel_inside_cidr = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(VpnTunnelOptionsSpecification {
                        pre_shared_key: pre_shared_key,
                        tunnel_inside_cidr: tunnel_inside_cidr,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }
}

pub mod verified_access_endpoint {
    //! Property types for the `VerifiedAccessEndpoint` resource.

    /// The [`AWS::EC2::VerifiedAccessEndpoint.LoadBalancerOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html) property type.
    #[derive(Debug, Default)]
    pub struct LoadBalancerOptions {
        /// Property [`LoadBalancerArn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions-loadbalancerarn).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub load_balancer_arn: Option<::Value<String>>,
        /// Property [`Port`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions-port).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub port: Option<::Value<u32>>,
        /// Property [`Protocol`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions-protocol).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub protocol: Option<::Value<String>>,
        /// Property [`SubnetIds`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-loadbalanceroptions.html#cfn-ec2-verifiedaccessendpoint-loadbalanceroptions-subnetids).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub subnet_ids: Option<::ValueList<String>>,
    }

    impl ::codec::SerializeValue for LoadBalancerOptions {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref load_balancer_arn) = self.load_balancer_arn {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "LoadBalancerArn", load_balancer_arn)?;
            }
            if let Some(ref port) = self.port {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Port", port)?;
            }
            if let Some(ref protocol) = self.protocol {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Protocol", protocol)?;
            }
            if let Some(ref subnet_ids) = self.subnet_ids {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "SubnetIds", subnet_ids)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for LoadBalancerOptions {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<LoadBalancerOptions, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = LoadBalancerOptions;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type LoadBalancerOptions")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut load_balancer_arn: Option<::Value<String>> = None;
                    let mut port: Option<::Value<u32>> = None;
                    let mut protocol: Option<::Value<String>> = None;
                    let mut subnet_ids: Option<::ValueList<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "LoadBalancerArn" => {
                                load_balancer_arn = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Port" => {
                                port = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Protocol" => {
                                protocol = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "SubnetIds" => {
                                subnet_ids = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(LoadBalancerOptions {
                        load_balancer_arn: load_balancer_arn,
                        port: port,
                        protocol: protocol,
                        subnet_ids: subnet_ids,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::VerifiedAccessEndpoint.NetworkInterfaceOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-networkinterfaceoptions.html) property type.
    #[derive(Debug, Default)]
    pub struct NetworkInterfaceOptions {
        /// Property [`NetworkInterfaceId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-networkinterfaceoptions.html#cfn-ec2-verifiedaccessendpoint-networkinterfaceoptions-networkinterfaceid).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub network_interface_id: Option<::Value<String>>,
        /// Property [`Port`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-networkinterfaceoptions.html#cfn-ec2-verifiedaccessendpoint-networkinterfaceoptions-port).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub port: Option<::Value<u32>>,
        /// Property [`Protocol`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-networkinterfaceoptions.html#cfn-ec2-verifiedaccessendpoint-networkinterfaceoptions-protocol).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub protocol: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for NetworkInterfaceOptions {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref network_interface_id) = self.network_interface_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "NetworkInterfaceId", network_interface_id)?;
            }
            if let Some(ref port) = self.port {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Port", port)?;
            }
            if let Some(ref protocol) = self.protocol {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Protocol", protocol)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for NetworkInterfaceOptions {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<NetworkInterfaceOptions, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = NetworkInterfaceOptions;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type NetworkInterfaceOptions")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut network_interface_id: Option<::Value<String>> = None;
                    let mut port: Option<::Value<u32>> = None;
                    let mut protocol: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "NetworkInterfaceId" => {
                                network_interface_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Port" => {
                                port = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Protocol" => {
                                protocol = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(NetworkInterfaceOptions {
                        network_interface_id: network_interface_id,
                        port: port,
                        protocol: protocol,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::VerifiedAccessEndpoint.SseSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-ssespecification.html) property type.
    #[derive(Debug, Default)]
    pub struct SseSpecification {
        /// Property [`CustomerManagedKeyEnabled`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-ssespecification.html#cfn-ec2-verifiedaccessendpoint-ssespecification-customermanagedkeyenabled).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub customer_managed_key_enabled: Option<::Value<bool>>,
        /// Property [`KmsKeyArn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessendpoint-ssespecification.html#cfn-ec2-verifiedaccessendpoint-ssespecification-kmskeyarn).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub kms_key_arn: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for SseSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref customer_managed_key_enabled) = self.customer_managed_key_enabled {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "CustomerManagedKeyEnabled", customer_managed_key_enabled)?;
            }
            if let Some(ref kms_key_arn) = self.kms_key_arn {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "KmsKeyArn", kms_key_arn)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for SseSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<SseSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = SseSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type SseSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut customer_managed_key_enabled: Option<::Value<bool>> = None;
                    let mut kms_key_arn: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "CustomerManagedKeyEnabled" => {
                                customer_managed_key_enabled = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "KmsKeyArn" => {
                                kms_key_arn = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(SseSpecification {
                        customer_managed_key_enabled: customer_managed_key_enabled,
                        kms_key_arn: kms_key_arn,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }
}

pub mod verified_access_group {
    //! Property types for the `VerifiedAccessGroup` resource.

    /// The [`AWS::EC2::VerifiedAccessGroup.SseSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessgroup-ssespecification.html) property type.
    #[derive(Debug, Default)]
    pub struct SseSpecification {
        /// Property [`CustomerManagedKeyEnabled`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessgroup-ssespecification.html#cfn-ec2-verifiedaccessgroup-ssespecification-customermanagedkeyenabled).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub customer_managed_key_enabled: Option<::Value<bool>>,
        /// Property [`KmsKeyArn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessgroup-ssespecification.html#cfn-ec2-verifiedaccessgroup-ssespecification-kmskeyarn).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub kms_key_arn: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for SseSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref customer_managed_key_enabled) = self.customer_managed_key_enabled {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "CustomerManagedKeyEnabled", customer_managed_key_enabled)?;
            }
            if let Some(ref kms_key_arn) = self.kms_key_arn {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "KmsKeyArn", kms_key_arn)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for SseSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<SseSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = SseSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type SseSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut customer_managed_key_enabled: Option<::Value<bool>> = None;
                    let mut kms_key_arn: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "CustomerManagedKeyEnabled" => {
                                customer_managed_key_enabled = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "KmsKeyArn" => {
                                kms_key_arn = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(SseSpecification {
                        customer_managed_key_enabled: customer_managed_key_enabled,
                        kms_key_arn: kms_key_arn,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }
}

pub mod verified_access_instance {
    //! Property types for the `VerifiedAccessInstance` resource.

    /// The [`AWS::EC2::VerifiedAccessInstance.CloudWatchLogs`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-cloudwatchlogs.html) property type.
    #[derive(Debug, Default)]
    pub struct CloudWatchLogs {
        /// Property [`Enabled`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-cloudwatchlogs.html#cfn-ec2-verifiedaccessinstance-cloudwatchlogs-enabled).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub enabled: Option<::Value<bool>>,
        /// Property [`LogGroup`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-cloudwatchlogs.html#cfn-ec2-verifiedaccessinstance-cloudwatchlogs-loggroup).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub log_group: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for CloudWatchLogs {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref enabled) = self.enabled {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Enabled", enabled)?;
            }
            if let Some(ref log_group) = self.log_group {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "LogGroup", log_group)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for CloudWatchLogs {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<CloudWatchLogs, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = CloudWatchLogs;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type CloudWatchLogs")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut enabled: Option<::Value<bool>> = None;
                    let mut log_group: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Enabled" => {
                                enabled = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "LogGroup" => {
                                log_group = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(CloudWatchLogs {
                        enabled: enabled,
                        log_group: log_group,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::VerifiedAccessInstance.KinesisDataFirehose`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-kinesisdatafirehose.html) property type.
    #[derive(Debug, Default)]
    pub struct KinesisDataFirehose {
        /// Property [`DeliveryStream`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-kinesisdatafirehose.html#cfn-ec2-verifiedaccessinstance-kinesisdatafirehose-deliverystream).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub delivery_stream: Option<::Value<String>>,
        /// Property [`Enabled`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-kinesisdatafirehose.html#cfn-ec2-verifiedaccessinstance-kinesisdatafirehose-enabled).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub enabled: Option<::Value<bool>>,
    }

    impl ::codec::SerializeValue for KinesisDataFirehose {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref delivery_stream) = self.delivery_stream {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "DeliveryStream", delivery_stream)?;
            }
            if let Some(ref enabled) = self.enabled {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Enabled", enabled)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for KinesisDataFirehose {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<KinesisDataFirehose, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = KinesisDataFirehose;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type KinesisDataFirehose")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut delivery_stream: Option<::Value<String>> = None;
                    let mut enabled: Option<::Value<bool>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "DeliveryStream" => {
                                delivery_stream = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Enabled" => {
                                enabled = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(KinesisDataFirehose {
                        delivery_stream: delivery_stream,
                        enabled: enabled,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::VerifiedAccessInstance.S3`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-s3.html) property type.
    #[derive(Debug, Default)]
    pub struct S3 {
        /// Property [`BucketName`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-s3.html#cfn-ec2-verifiedaccessinstance-s3-bucketname).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub bucket_name: Option<::Value<String>>,
        /// Property [`BucketOwner`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-s3.html#cfn-ec2-verifiedaccessinstance-s3-bucketowner).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub bucket_owner: Option<::Value<String>>,
        /// Property [`Enabled`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-s3.html#cfn-ec2-verifiedaccessinstance-s3-enabled).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub enabled: Option<::Value<bool>>,
        /// Property [`Prefix`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-s3.html#cfn-ec2-verifiedaccessinstance-s3-prefix).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub prefix: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for S3 {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref bucket_name) = self.bucket_name {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "BucketName", bucket_name)?;
            }
            if let Some(ref bucket_owner) = self.bucket_owner {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "BucketOwner", bucket_owner)?;
            }
            if let Some(ref enabled) = self.enabled {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Enabled", enabled)?;
            }
            if let Some(ref prefix) = self.prefix {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Prefix", prefix)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for S3 {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<S3, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = S3;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type S3")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut bucket_name: Option<::Value<String>> = None;
                    let mut bucket_owner: Option<::Value<String>> = None;
                    let mut enabled: Option<::Value<bool>> = None;
                    let mut prefix: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "BucketName" => {
                                bucket_name = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "BucketOwner" => {
                                bucket_owner = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Enabled" => {
                                enabled = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Prefix" => {
                                prefix = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(S3 {
                        bucket_name: bucket_name,
                        bucket_owner: bucket_owner,
                        enabled: enabled,
                        prefix: prefix,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::VerifiedAccessInstance.VerifiedAccessLogs`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesslogs.html) property type.
    #[derive(Debug, Default)]
    pub struct VerifiedAccessLogs {
        /// Property [`CloudWatchLogs`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesslogs.html#cfn-ec2-verifiedaccessinstance-verifiedaccesslogs-cloudwatchlogs).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub cloud_watch_logs: Option<::Value<CloudWatchLogs>>,
        /// Property [`IncludeTrustContext`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesslogs.html#cfn-ec2-verifiedaccessinstance-verifiedaccesslogs-includetrustcontext).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub include_trust_context: Option<::Value<bool>>,
        /// Property [`KinesisDataFirehose`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesslogs.html#cfn-ec2-verifiedaccessinstance-verifiedaccesslogs-kinesisdatafirehose).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub kinesis_data_firehose: Option<::Value<KinesisDataFirehose>>,
        /// Property [`LogVersion`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesslogs.html#cfn-ec2-verifiedaccessinstance-verifiedaccesslogs-logversion).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub log_version: Option<::Value<String>>,
        /// Property [`S3`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesslogs.html#cfn-ec2-verifiedaccessinstance-verifiedaccesslogs-s3).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub s3: Option<::Value<S3>>,
    }

    impl ::codec::SerializeValue for VerifiedAccessLogs {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref cloud_watch_logs) = self.cloud_watch_logs {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "CloudWatchLogs", cloud_watch_logs)?;
            }
            if let Some(ref include_trust_context) = self.include_trust_context {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "IncludeTrustContext", include_trust_context)?;
            }
            if let Some(ref kinesis_data_firehose) = self.kinesis_data_firehose {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "KinesisDataFirehose", kinesis_data_firehose)?;
            }
            if let Some(ref log_version) = self.log_version {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "LogVersion", log_version)?;
            }
            if let Some(ref s3) = self.s3 {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "S3", s3)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for VerifiedAccessLogs {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<VerifiedAccessLogs, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = VerifiedAccessLogs;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type VerifiedAccessLogs")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut cloud_watch_logs: Option<::Value<CloudWatchLogs>> = None;
                    let mut include_trust_context: Option<::Value<bool>> = None;
                    let mut kinesis_data_firehose: Option<::Value<KinesisDataFirehose>> = None;
                    let mut log_version: Option<::Value<String>> = None;
                    let mut s3: Option<::Value<S3>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "CloudWatchLogs" => {
                                cloud_watch_logs = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "IncludeTrustContext" => {
                                include_trust_context = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "KinesisDataFirehose" => {
                                kinesis_data_firehose = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "LogVersion" => {
                                log_version = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "S3" => {
                                s3 = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(VerifiedAccessLogs {
                        cloud_watch_logs: cloud_watch_logs,
                        include_trust_context: include_trust_context,
                        kinesis_data_firehose: kinesis_data_firehose,
                        log_version: log_version,
                        s3: s3,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::VerifiedAccessInstance.VerifiedAccessTrustProvider`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesstrustprovider.html) property type.
    #[derive(Debug, Default)]
    pub struct VerifiedAccessTrustProvider {
        /// Property [`Description`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustprovider-description).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub description: Option<::Value<String>>,
        /// Property [`DeviceTrustProviderType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustprovider-devicetrustprovidertype).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub device_trust_provider_type: Option<::Value<String>>,
        /// Property [`TrustProviderType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustprovider-trustprovidertype).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub trust_provider_type: Option<::Value<String>>,
        /// Property [`UserTrustProviderType`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustprovider-usertrustprovidertype).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub user_trust_provider_type: Option<::Value<String>>,
        /// Property [`VerifiedAccessTrustProviderId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccessinstance-verifiedaccesstrustprovider.html#cfn-ec2-verifiedaccessinstance-verifiedaccesstrustprovider-verifiedaccesstrustproviderid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub verified_access_trust_provider_id: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for VerifiedAccessTrustProvider {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref description) = self.description {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Description", description)?;
            }
            if let Some(ref device_trust_provider_type) = self.device_trust_provider_type {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "DeviceTrustProviderType", device_trust_provider_type)?;
            }
            if let Some(ref trust_provider_type) = self.trust_provider_type {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "TrustProviderType", trust_provider_type)?;
            }
            if let Some(ref user_trust_provider_type) = self.user_trust_provider_type {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "UserTrustProviderType", user_trust_provider_type)?;
            }
            if let Some(ref verified_access_trust_provider_id) = self.verified_access_trust_provider_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "VerifiedAccessTrustProviderId", verified_access_trust_provider_id)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for VerifiedAccessTrustProvider {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<VerifiedAccessTrustProvider, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = VerifiedAccessTrustProvider;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type VerifiedAccessTrustProvider")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut description: Option<::Value<String>> = None;
                    let mut device_trust_provider_type: Option<::Value<String>> = None;
                    let mut trust_provider_type: Option<::Value<String>> = None;
                    let mut user_trust_provider_type: Option<::Value<String>> = None;
                    let mut verified_access_trust_provider_id: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "Description" => {
                                description = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "DeviceTrustProviderType" => {
                                device_trust_provider_type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "TrustProviderType" => {
                                trust_provider_type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "UserTrustProviderType" => {
                                user_trust_provider_type = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "VerifiedAccessTrustProviderId" => {
                                verified_access_trust_provider_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(VerifiedAccessTrustProvider {
                        description: description,
                        device_trust_provider_type: device_trust_provider_type,
                        trust_provider_type: trust_provider_type,
                        user_trust_provider_type: user_trust_provider_type,
                        verified_access_trust_provider_id: verified_access_trust_provider_id,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }
}

pub mod verified_access_trust_provider {
    //! Property types for the `VerifiedAccessTrustProvider` resource.

    /// The [`AWS::EC2::VerifiedAccessTrustProvider.DeviceOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-deviceoptions.html) property type.
    #[derive(Debug, Default)]
    pub struct DeviceOptions {
        /// Property [`PublicSigningKeyUrl`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-deviceoptions.html#cfn-ec2-verifiedaccesstrustprovider-deviceoptions-publicsigningkeyurl).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub public_signing_key_url: Option<::Value<String>>,
        /// Property [`TenantId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-deviceoptions.html#cfn-ec2-verifiedaccesstrustprovider-deviceoptions-tenantid).
        ///
        /// Update type: _Immutable_.
        /// AWS CloudFormation replaces the resource when you change this property.
        pub tenant_id: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for DeviceOptions {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref public_signing_key_url) = self.public_signing_key_url {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "PublicSigningKeyUrl", public_signing_key_url)?;
            }
            if let Some(ref tenant_id) = self.tenant_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "TenantId", tenant_id)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for DeviceOptions {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<DeviceOptions, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = DeviceOptions;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type DeviceOptions")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut public_signing_key_url: Option<::Value<String>> = None;
                    let mut tenant_id: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "PublicSigningKeyUrl" => {
                                public_signing_key_url = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "TenantId" => {
                                tenant_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(DeviceOptions {
                        public_signing_key_url: public_signing_key_url,
                        tenant_id: tenant_id,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::VerifiedAccessTrustProvider.OidcOptions`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html) property type.
    #[derive(Debug, Default)]
    pub struct OidcOptions {
        /// Property [`AuthorizationEndpoint`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-authorizationendpoint).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub authorization_endpoint: Option<::Value<String>>,
        /// Property [`ClientId`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-clientid).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub client_id: Option<::Value<String>>,
        /// Property [`ClientSecret`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-clientsecret).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub client_secret: Option<::Value<String>>,
        /// Property [`Issuer`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-issuer).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub issuer: Option<::Value<String>>,
        /// Property [`Scope`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-scope).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub scope: Option<::Value<String>>,
        /// Property [`TokenEndpoint`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-tokenendpoint).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub token_endpoint: Option<::Value<String>>,
        /// Property [`UserInfoEndpoint`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-oidcoptions.html#cfn-ec2-verifiedaccesstrustprovider-oidcoptions-userinfoendpoint).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub user_info_endpoint: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for OidcOptions {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref authorization_endpoint) = self.authorization_endpoint {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "AuthorizationEndpoint", authorization_endpoint)?;
            }
            if let Some(ref client_id) = self.client_id {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ClientId", client_id)?;
            }
            if let Some(ref client_secret) = self.client_secret {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "ClientSecret", client_secret)?;
            }
            if let Some(ref issuer) = self.issuer {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Issuer", issuer)?;
            }
            if let Some(ref scope) = self.scope {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "Scope", scope)?;
            }
            if let Some(ref token_endpoint) = self.token_endpoint {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "TokenEndpoint", token_endpoint)?;
            }
            if let Some(ref user_info_endpoint) = self.user_info_endpoint {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "UserInfoEndpoint", user_info_endpoint)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for OidcOptions {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<OidcOptions, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = OidcOptions;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type OidcOptions")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut authorization_endpoint: Option<::Value<String>> = None;
                    let mut client_id: Option<::Value<String>> = None;
                    let mut client_secret: Option<::Value<String>> = None;
                    let mut issuer: Option<::Value<String>> = None;
                    let mut scope: Option<::Value<String>> = None;
                    let mut token_endpoint: Option<::Value<String>> = None;
                    let mut user_info_endpoint: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "AuthorizationEndpoint" => {
                                authorization_endpoint = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ClientId" => {
                                client_id = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "ClientSecret" => {
                                client_secret = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Issuer" => {
                                issuer = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "Scope" => {
                                scope = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "TokenEndpoint" => {
                                token_endpoint = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "UserInfoEndpoint" => {
                                user_info_endpoint = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(OidcOptions {
                        authorization_endpoint: authorization_endpoint,
                        client_id: client_id,
                        client_secret: client_secret,
                        issuer: issuer,
                        scope: scope,
                        token_endpoint: token_endpoint,
                        user_info_endpoint: user_info_endpoint,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }

    /// The [`AWS::EC2::VerifiedAccessTrustProvider.SseSpecification`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-ssespecification.html) property type.
    #[derive(Debug, Default)]
    pub struct SseSpecification {
        /// Property [`CustomerManagedKeyEnabled`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-ssespecification.html#cfn-ec2-verifiedaccesstrustprovider-ssespecification-customermanagedkeyenabled).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub customer_managed_key_enabled: Option<::Value<bool>>,
        /// Property [`KmsKeyArn`](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-verifiedaccesstrustprovider-ssespecification.html#cfn-ec2-verifiedaccesstrustprovider-ssespecification-kmskeyarn).
        ///
        /// Update type: _Mutable_.
        /// AWS CloudFormation doesn't replace the resource when you change this property.
        pub kms_key_arn: Option<::Value<String>>,
    }

    impl ::codec::SerializeValue for SseSpecification {
        fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {
            let mut map = ::serde::Serializer::serialize_map(s, None)?;
            if let Some(ref customer_managed_key_enabled) = self.customer_managed_key_enabled {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "CustomerManagedKeyEnabled", customer_managed_key_enabled)?;
            }
            if let Some(ref kms_key_arn) = self.kms_key_arn {
                ::serde::ser::SerializeMap::serialize_entry(&mut map, "KmsKeyArn", kms_key_arn)?;
            }
            ::serde::ser::SerializeMap::end(map)
        }
    }

    impl ::codec::DeserializeValue for SseSpecification {
        fn deserialize<'de, D: ::serde::Deserializer<'de>>(d: D) -> Result<SseSpecification, D::Error> {
            struct Visitor;

            impl<'de> ::serde::de::Visitor<'de> for Visitor {
                type Value = SseSpecification;

                fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "a struct of type SseSpecification")
                }

                fn visit_map<A: ::serde::de::MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {
                    let mut customer_managed_key_enabled: Option<::Value<bool>> = None;
                    let mut kms_key_arn: Option<::Value<String>> = None;

                    while let Some(__cfn_key) = ::serde::de::MapAccess::next_key::<String>(&mut map)? {
                        match __cfn_key.as_ref() {
                            "CustomerManagedKeyEnabled" => {
                                customer_managed_key_enabled = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            "KmsKeyArn" => {
                                kms_key_arn = ::serde::de::MapAccess::next_value(&mut map)?;
                            }
                            _ => {}
                        }
                    }

                    Ok(SseSpecification {
                        customer_managed_key_enabled: customer_managed_key_enabled,
                        kms_key_arn: kms_key_arn,
                    })
                }
            }

            d.deserialize_map(Visitor)
        }
    }
}
